---
description: Redis usage guidelines and best practices
globs: ["**/server/**/*.{ts,tsx}", "**/lib/**/*.{ts,tsx}", "**/api/**/*.{ts,tsx}", "**/services/**/*.{ts,tsx}"]
alwaysApply: true
---

# Redis Key Rules

## Infra
- Managed/serverless prod; local dev parity.
- Document conn/TLS/auth per env.

## Channels/Keys
- Bounded prefixes (e.g., `events:chat`).
- Registry: purpose/payload/retention.
- Migrate deprecations.

## Validation/Safety
- Schema validate pub/consume; reject/log invalid.
- No sensitive/long-lived (use DB).
- Timeouts/retries/circuit breakers.

## Events
- Fan-out with checkpoints/replay.
- Metrics: latency/failures/backlog.
- Back-pressure slow consumers.

## Reactive Streams Implementation

### Producer Pattern
- XADD event to Streams for persistence/durability.
- PUBLISH to Pub/Sub channels for immediate fan-out.
- Combine both: Streams for replay, Pub/Sub for real-time delivery.

### Relay Pattern
- XREAD with cursor for backlog replay from Streams (non-blocking).
- Safe transition to Pub/Sub when caught up (avoid message loss with deduplication).
- Subscribe to Pub/Sub for new real-time events.
- Push to frontend via SSE/WebSocket with entry IDs.
- Implement deduplication to prevent missed messages during transition.

### Client Pattern
- SSE/WebSocket connection for real-time events.
- Use Streams entryId as cursor for resume/playback.
- Store last processed entryId for reconnection recovery.
- Handle connection drops gracefully with cursor-based resume.

### Stream Management
- Use auto-generated entry IDs (`XADD *`) as authoritative cursors.
- Implement back-pressure for slow consumers.
- Set appropriate retention policies for Streams.
- Monitor backlog depth and consumer lag.

## Avoid
- Unvalidated/schemaless payloads.
- Blocking/long ops.
- Swallowed errors/auto-retries sans alert.
