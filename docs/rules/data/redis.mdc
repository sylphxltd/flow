---
description: Redis usage guidelines and best practices
globs: ["**/server/**/*.{ts,tsx}", "**/lib/**/*.{ts,tsx}", "**/api/**/*.{ts,tsx}", "**/services/**/*.{ts,tsx}"]
alwaysApply: true
---

# Redis Key Rules

## Infra
- Managed/serverless prod; local dev parity.
- Document conn/TLS/auth per env.

## Channels/Keys
- Bounded prefixes (e.g., `events:chat`).
- Registry: purpose/payload/retention.
- Migrate deprecations.

## Validation/Safety
- Schema validate pub/consume; reject/log invalid.
- No sensitive/long-lived (use DB).
- Timeouts/retries/circuit breakers.

## Events
- Fan-out with checkpoints/replay.
- Metrics: latency/failures/backlog.
- Back-pressure slow consumers.

## Reactive Streams Implementation

### Producer Pattern
- XADD event to Streams for persistence/durability and real-time delivery.
- Single source of truth: Streams handle both persistence and real-time.

### Relay Pattern
- XREAD with blocking (no timeout) for real-time event consumption.
- Use cursor-based reading for backlog replay and live updates.
- Retry XREAD immediately on failure without sleep delays.
- Push to frontend via SSE/WebSocket with entry IDs.

### Client Pattern
- SSE/WebSocket connection for real-time events.
- Use Streams entryId as cursor for resume/playback.
- Store last processed entryId for reconnection recovery.
- Handle connection drops gracefully with cursor-based resume.

### Stream Management
- Use auto-generated entry IDs (`XADD *`) as authoritative cursors.
- Implement back-pressure for slow consumers.
- Set appropriate retention policies for Streams.
- Monitor backlog depth and consumer lag.

## Avoid
- Unvalidated/schemaless payloads.
- Blocking/long ops.
- Swallowed errors/auto-retries sans alert.
