---
description: Universal development practices applicable to all languages and frameworks
globs: ["**/*"]
alwaysApply: true
---

# General Development Rules

## Architecture & Design
- Separation of concerns
- Single responsibility principle
- Dependency injection for testability
- Interface segregation

## Code Organization
- Feature-based folder structure
- Clear module boundaries
- Centralized utilities
- Consistent naming conventions
- Modular design with clear separation of concerns
- DRY and SOLID principles
- Continuous refactoring; split monolithic files into focused modules (≈200–300 lines)
- Extract reusable components and utilities

## Clean Code
- Remove dead code immediately
- No magic numbers (use constants)
- Functions/methods < 50 lines
- Max 3 levels of nesting

## Documentation
- Documentation first: business requirements, acceptance criteria, architectural decisions
- Comment complex business logic
- Update docs with code changes
- Clear commit messages
- API documentation for public interfaces

## Testing Principles
- Unit tests for functions/components
- Integration tests for interactions
- E2E tests for critical user journeys
- Contract tests for APIs
- Tests match code structure
- Descriptive test names
- Realistic test data
- Independent test isolation

## Performance Optimization
- Build-time over run-time: move work to build time (codegen, config, optimization)
- Static imports preferred over dynamic
- Runtime focuses on business logic execution
- Resolve canonical paths/endpoints at build time where possible
- Lazy load components and routes
- Bundle splitting for better caching
- Tree-shake unused code
- Async operations for non-blocking UI
- Clean up event listeners and resources
- Efficient algorithms and data structures
- Memory leak prevention

## Security Principles
- Validate all user inputs and authentication
- Use parameterized queries to prevent SQL injection
- Store secrets in environment variables only
- HTTPS only in production environments
- Sanitize all user content before processing
- Encrypt sensitive data at rest and in transit
- Implement rate limiting for API endpoints
- Never log secrets or PII (redact tokens/emails/IDs)

## Development Workflow
- Plan before implementing (incremental development)
- Code reviews mandatory for all changes
- Automated testing in CI/CD pipelines
- Consistent package management across environments
- Shared code formatting standards
- Proper version control and descriptive commit messages
- Environment variables properly validated at startup

## Path Discipline
- No multi-path guessing or fallback chains
- Consult official docs/specs to determine single canonical path
- Store canonical paths and versions as typed constants
- Validate env-derived paths at startup; fail fast
- Remove legacy fallbacks; handle deprecations via explicit version gates

## Development Environment
- Avoid executing live environments during edits (use hot reload)
- Run isolated tests and scripts as needed
- Maintain separate development, staging, and production configurations

## Design System
- Unified color palette, spacing scale, and component library
- Progressive enhancement: core functionality works everywhere

## Quality Assurance
- Understand requirements before implementation
- Cross-browser and device testing
- Error recovery: re-read files carefully if edits fail
- Continuous integration with automated testing

## Forbidden
- Hardcode secrets or API keys
- Commit directly to main/master
- Leave dead/unused code
- Skip input validation
- Create circular dependencies
- Use global mutable state
- Unsafe type assertions or error suppression without justification

## Avoid Without Justification
- Large functions/methods (>50 lines)
- Deep nesting (>3 levels)
- Heavy library imports without performance analysis
- Dynamic imports without performance impact assessment
- Unnecessary abstractions that increase complexity