---
description: Flutter framework-specific rules and best practices
globs: ["**/*.dart", "**/lib/**/*", "**/test/**/*"]
alwaysApply: true
---

# Flutter Rules

## ðŸ—ï¸ Framework Patterns
- Use Flutter's declarative UI approach
- Leverage widget composition
- State management with Provider/Riverpod
- Proper widget lifecycle management

## ðŸ“ Project Structure
```
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ core/             # Core utilities
â”‚   â”œâ”€â”€ features/         # Feature modules
â”‚   â”œâ”€â”€ shared/           # Shared components
â”‚   â””â”€â”€ models/           # Data models
â”œâ”€â”€ test/                 # Unit and widget tests
â”œâ”€â”€ integration_test/     # Integration tests
â””â”€â”€ pubspec.yaml          # Dependencies
```

## ðŸŽ¯ Widget Design
- Use stateless widgets when possible
- Proper key usage for list items
- Efficient widget rebuilding
- Widget composition over inheritance

## ðŸ“Š State Management & Signals
- **Signals Approach**: Reactive state management patterns
- Provider for simple state (signals-like reactivity)
- Riverpod for complex state (modern signals pattern)
- Bloc pattern for business logic (event-driven signals)
- Signals for fine-grained reactivity when available
- Proper state disposal and lifecycle management

## ðŸ”„ Data Fetching
- Repository pattern for data access
- Proper error handling
- Loading states management
- Offline data handling

## ðŸš€ Performance
- Use const constructors
- Avoid unnecessary rebuilds
- Efficient list rendering
- Memory leak prevention

## ðŸš« Forbidden Practices
- `print()` statements in production code
- `debugPrint()` in production (use proper logging)
- Direct `print()` for error logging (use logging library)
- Large widgets (>200 lines)
- Business logic in widgets
- Improper state management
- Missing error boundaries

## ðŸ§ª Testing
- Unit tests for business logic
- Widget tests for UI components
- Integration tests for critical flows
- Mock external dependencies

## ðŸŽ¯ Best Practices
- Use Dart's null safety
- Proper async/await usage
- Effective debugging techniques
- Platform-specific considerations