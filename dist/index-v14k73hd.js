import{l as jf}from"./index-d8t4mrca.js";import{n as I2,o as r,q as i}from"./index-rkcgv5z5.js";var $1=r((T)=>{var a0=T&&T.__createBinding||(Object.create?function(f,X,$,A){if(A===void 0)A=$;var J=Object.getOwnPropertyDescriptor(X,$);if(!J||("get"in J?!X.__esModule:J.writable||J.configurable))J={enumerable:!0,get:function(){return X[$]}};Object.defineProperty(f,A,J)}:function(f,X,$,A){if(A===void 0)A=$;f[A]=X[$]}),o0=T&&T.__setModuleDefault||(Object.create?function(f,X){Object.defineProperty(f,"default",{enumerable:!0,value:X})}:function(f,X){f.default=X}),X1=T&&T.__importStar||function(f){if(f&&f.__esModule)return f;var X={};if(f!=null){for(var $ in f)if($!=="default"&&Object.prototype.hasOwnProperty.call(f,$))a0(X,f,$)}return o0(X,f),X};Object.defineProperty(T,"__esModule",{value:!0});T.load=T.currentTarget=void 0;var r0=X1(i("path")),e0=X1(i("fs"));function f6(){let f=null;switch(process.platform){case"android":switch(process.arch){case"arm":return"android-arm-eabi";case"arm64":return"android-arm64"}f="Android";break;case"win32":switch(process.arch){case"x64":return"win32-x64-msvc";case"arm64":return"win32-arm64-msvc";case"ia32":return"win32-ia32-msvc"}f="Windows";break;case"darwin":switch(process.arch){case"x64":return"darwin-x64";case"arm64":return"darwin-arm64"}f="macOS";break;case"linux":switch(process.arch){case"x64":case"arm64":return X6()?`linux-${process.arch}-gnu`:`linux-${process.arch}-musl`;case"arm":return"linux-arm-gnueabihf"}f="Linux";break;case"freebsd":if(process.arch==="x64")return"freebsd-x64";f="FreeBSD";break}if(f)throw Error(`Neon: unsupported ${f} architecture: ${process.arch}`);throw Error(`Neon: unsupported system: ${process.platform}`)}T.currentTarget=f6;function X6(){let f=process.report?.getReport();if(typeof f!=="object"||!f||!("header"in f))return!1;let X=f.header;return typeof X==="object"&&!!X&&"glibcVersionRuntime"in X}function $6(f){let X=r0.join(f,"index.node");return e0.existsSync(X)?i(X):null}T.load=$6});var R1=r((V4,J1)=>{var A1=()=>process.platform==="linux",D2=null,A6=()=>{if(!D2)D2=A1()&&process.report?process.report.getReport():{};return D2};J1.exports={isLinux:A1,getReport:A6}});var _1=r((H4,Y1)=>{var Z1=i("fs"),J6=(f)=>Z1.readFileSync(f,"utf-8"),R6=(f)=>new Promise((X,$)=>{Z1.readFile(f,"utf-8",(A,J)=>{if(A)$(A);else X(J)})});Y1.exports={LDD_PATH:"/usr/bin/ldd",readFileSync:J6,readFile:R6}});var T1=r((L4,L1)=>{var N1=i("child_process"),{isLinux:Kf,getReport:K1}=R1(),{LDD_PATH:lf,readFile:G1,readFileSync:O1}=_1(),P,k,d="",D1=()=>{if(!d)return new Promise((f)=>{N1.exec("getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true",(X,$)=>{d=X?" ":$,f(d)})});return d},W1=()=>{if(!d)try{d=N1.execSync("getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true",{encoding:"utf8"})}catch(f){d=" "}return d},b="glibc",x1=/GLIBC\s(\d+\.\d+)/,e="musl",Z6=b.toUpperCase(),Y6=e.toLowerCase(),_6=(f)=>f.includes("libc.musl-")||f.includes("ld-musl-"),Q1=()=>{let f=K1();if(f.header&&f.header.glibcVersionRuntime)return b;if(Array.isArray(f.sharedObjects)){if(f.sharedObjects.some(_6))return e}return null},I1=(f)=>{let[X,$]=f.split(/[\r\n]+/);if(X&&X.includes(b))return b;if($&&$.includes(e))return e;return null},B1=(f)=>{if(f.includes(Y6))return e;if(f.includes(Z6))return b;return null},z6=async()=>{if(P!==void 0)return P;P=null;try{let f=await G1(lf);P=B1(f)}catch(f){}return P},N6=()=>{if(P!==void 0)return P;P=null;try{let f=O1(lf);P=B1(f)}catch(f){}return P},U1=async()=>{let f=null;if(Kf()){if(f=await z6(),!f)f=Q1();if(!f){let X=await D1();f=I1(X)}}return f},y1=()=>{let f=null;if(Kf()){if(f=N6(),!f)f=Q1();if(!f){let X=W1();f=I1(X)}}return f},K6=async()=>Kf()&&await U1()!==b,G6=()=>Kf()&&y1()!==b,O6=async()=>{if(k!==void 0)return k;k=null;try{let X=(await G1(lf)).match(x1);if(X)k=X[1]}catch(f){}return k},D6=()=>{if(k!==void 0)return k;k=null;try{let X=O1(lf).match(x1);if(X)k=X[1]}catch(f){}return k},V1=()=>{let f=K1();if(f.header&&f.header.glibcVersionRuntime)return f.header.glibcVersionRuntime;return null},z1=(f)=>f.trim().split(/\s+/)[1],H1=(f)=>{let[X,$,A]=f.split(/[\r\n]+/);if(X&&X.includes(b))return z1(X);if($&&A&&$.includes(e))return z1(A);return null},W6=async()=>{let f=null;if(Kf()){if(f=await O6(),!f)f=V1();if(!f){let X=await D1();f=H1(X)}}return f},x6=()=>{let f=null;if(Kf()){if(f=D6(),!f)f=V1();if(!f){let X=W1();f=H1(X)}}return f};L1.exports={GLIBC:b,MUSL:e,family:U1,familySync:y1,isNonGlibcLinux:K6,isNonGlibcLinuxSync:G6,version:W6,versionSync:x6}});var M1=r((T4,F1)=>{var W2={value:"SqliteError",writable:!0,enumerable:!1,configurable:!0};function ff(f,X,$){if(new.target!==ff)return new ff(f,X);if(typeof X!=="string")throw TypeError("Expected second argument to be a string");Error.call(this,f),W2.value=""+f,Object.defineProperty(this,"message",W2),Error.captureStackTrace(this,ff),this.code=X,this.rawCode=$}Object.setPrototypeOf(ff,Error);Object.setPrototypeOf(ff.prototype,Error.prototype);Object.defineProperty(ff.prototype,"name",W2);F1.exports=ff});var q1=r((F4,Q2)=>{var __dirname="/Users/kyle/rules/node_modules/libsql",{load:Q6,currentTarget:I6}=$1(),{familySync:B6,GLIBC:U6}=T1();function y6(){if(process.env.LIBSQL_JS_DEV)return Q6(__dirname);let f=I6();if(B6()==U6)switch(f){case"linux-x64-musl":f="linux-x64-gnu";break;case"linux-arm64-musl":f="linux-arm64-gnu";break}return i(`@libsql/${f}`)}var{databaseOpen:V6,databaseOpenWithRpcSync:H6,databaseInTransaction:L6,databaseClose:T6,databaseSyncSync:F6,databaseSyncUntilSync:M6,databaseExecSync:w6,databasePrepareSync:j6,databaseDefaultSafeIntegers:h6,databaseLoadExtension:E6,databaseMaxWriteReplicationIndex:P6,statementRaw:k6,statementIsReader:q6,statementGet:w1,statementRun:j1,statementRowsSync:h1,statementColumns:C6,statementSafeIntegers:p6,rowsNext:b6}=y6(),E1=M1();function x2(f){if(f.libsqlError)return new E1(f.message,f.code,f.rawCode);return f}class P1{constructor(f,X){let $=X?.encryptionCipher??"aes256cbc";if(X&&X.syncUrl){var A="";if(X.syncAuth)console.warn("Warning: The `syncAuth` option is deprecated, please use `authToken` option instead."),A=X.syncAuth;else if(X.authToken)A=X.authToken;let R=X?.encryptionKey??"",Z=X?.syncPeriod??0,Y=X?.readYourWrites??!0;this.db=H6(f,X.syncUrl,A,$,R,Z,Y)}else{let R=X?.authToken??"",Z=X?.encryptionKey??"";this.db=V6(f,R,$,Z)}this.memory=f===":memory:",this.readonly=!1,this.name="",this.open=!0;let J=this.db;Object.defineProperties(this,{inTransaction:{get(){return L6(J)}}})}sync(){return F6.call(this.db)}syncUntil(f){return M6.call(this.db,f)}prepare(f){try{let X=j6.call(this.db,f);return new k1(X)}catch(X){throw x2(X)}}transaction(f){if(typeof f!=="function")throw TypeError("Expected first argument to be a function");let X=this,$=(J)=>{return(...R)=>{X.exec("BEGIN "+J);try{let Z=f(...R);return X.exec("COMMIT"),Z}catch(Z){throw X.exec("ROLLBACK"),Z}}},A={default:{value:$("")},deferred:{value:$("DEFERRED")},immediate:{value:$("IMMEDIATE")},exclusive:{value:$("EXCLUSIVE")},database:{value:this,enumerable:!0}};return Object.defineProperties(A.default.value,A),Object.defineProperties(A.deferred.value,A),Object.defineProperties(A.immediate.value,A),Object.defineProperties(A.exclusive.value,A),A.default.value}pragma(f,X){if(X==null)X={};if(typeof f!=="string")throw TypeError("Expected first argument to be a string");if(typeof X!=="object")throw TypeError("Expected second argument to be an options object");let $=X.simple,A=this.prepare(`PRAGMA ${f}`,this,!0);return $?A.pluck().get():A.all()}backup(f,X){throw Error("not implemented")}serialize(f){throw Error("not implemented")}function(f,X,$){if(X==null)X={};if(typeof X==="function")$=X,X={};if(typeof f!=="string")throw TypeError("Expected first argument to be a string");if(typeof $!=="function")throw TypeError("Expected last argument to be a function");if(typeof X!=="object")throw TypeError("Expected second argument to be an options object");if(!f)throw TypeError("User-defined function name cannot be an empty string");throw Error("not implemented")}aggregate(f,X){if(typeof f!=="string")throw TypeError("Expected first argument to be a string");if(typeof X!=="object"||X===null)throw TypeError("Expected second argument to be an options object");if(!f)throw TypeError("User-defined function name cannot be an empty string");throw Error("not implemented")}table(f,X){if(typeof f!=="string")throw TypeError("Expected first argument to be a string");if(!f)throw TypeError("Virtual table module name cannot be an empty string");throw Error("not implemented")}loadExtension(...f){E6.call(this.db,...f)}maxWriteReplicationIndex(){return P6.call(this.db)}exec(f){try{w6.call(this.db,f)}catch(X){throw x2(X)}}close(){T6.call(this.db),this.open=!1}defaultSafeIntegers(f){return h6.call(this.db,f??!0),this}unsafeMode(...f){throw Error("not implemented")}}class k1{constructor(f){this.stmt=f}raw(f){return k6.call(this.stmt,f??!0),this}get reader(){return q6.call(this.stmt)}run(...f){try{if(f.length==1&&typeof f[0]==="object")return j1.call(this.stmt,f[0]);else return j1.call(this.stmt,f.flat())}catch(X){throw x2(X)}}get(...f){if(f.length==1&&typeof f[0]==="object")return w1.call(this.stmt,f[0]);else return w1.call(this.stmt,f.flat())}iterate(...f){var X=void 0;if(f.length==1&&typeof f[0]==="object")X=h1.call(this.stmt,f[0]);else X=h1.call(this.stmt,f.flat());return{nextRows:Array(100),nextRowIndex:100,next(){if(this.nextRowIndex===100)b6.call(X,this.nextRows),this.nextRowIndex=0;let A=this.nextRows[this.nextRowIndex];if(this.nextRows[this.nextRowIndex]=void 0,!A)return{done:!0};return this.nextRowIndex++,{value:A,done:!1}},[Symbol.iterator](){return this}}}all(...f){let X=[];for(let $ of this.iterate(...f))X.push($);return X}columns(){return C6.call(this.stmt)}safeIntegers(f){return p6.call(this.stmt,f??!0),this}}Q2.exports=P1;Q2.exports.SqliteError=E1});var k2=r((E$,y0)=>{function J4(f){var X=0,$=[];function A(){if(X--,X<f)J()}function J(){var _=$.shift();if(Y.queue=$.length,_)Z(_.fn).then(_.resolve).catch(_.reject)}function R(_){return new Promise(function(N,V){$.push({fn:_,resolve:N,reject:V}),Y.queue=$.length})}function Z(_){X++;try{return Promise.resolve(_()).then(function(N){return A(),N},function(N){throw A(),N})}catch(N){return A(),Promise.reject(N)}}var Y=function(_){if(X>=f)return R(_);else return Z(_)};return Y}function R4(f,X){var $=!1,A=this;return Promise.all(f.map(function(){var J=arguments;return A(function(){if(!$)return X.apply(void 0,J).catch(function(R){throw $=!0,R})})}))}function U0(f){return f.queue=0,f.map=R4,f}y0.exports=function(f){if(f)return U0(J4(f));else return U0(function(X){return X()})}});import*as z2 from"node:fs";import*as q2 from"node:path";class K extends Error{code;rawCode;constructor(f,X,$,A){if(X!==void 0)f=`${X}: ${f}`;super(f,{cause:A});this.code=X,this.rawCode=$,this.name="LibsqlError"}}function C2(f){let X=k0.exec(f);if(X===null)throw new K(`The URL '${f}' is not in a valid format`,"URL_INVALID");let $=X.groups,A=$.scheme,J=$.authority!==void 0?q0($.authority):void 0,R=o($.path),Z=$.query!==void 0?p0($.query):void 0,Y=$.fragment!==void 0?o($.fragment):void 0;return{scheme:A,authority:J,path:R,query:Z,fragment:Y}}var k0=(()=>{return new RegExp("^(?<scheme>[A-Za-z][A-Za-z.+-]*):(//(?<authority>[^/?#]*))?(?<path>[^?#]*)(\\?(?<query>[^#]*))?(#(?<fragment>.*))?$","su")})();function q0(f){let X=C0.exec(f);if(X===null)throw new K("The authority part of the URL is not in a valid format","URL_INVALID");let $=X.groups,A=o($.host_br??$.host),J=$.port?parseInt($.port,10):void 0,R=$.username!==void 0?{username:o($.username),password:$.password!==void 0?o($.password):void 0}:void 0;return{host:A,port:J,userinfo:R}}var C0=(()=>{return new RegExp("^((?<username>[^:]*)(:(?<password>.*))?@)?((?<host>[^:\\[\\]]*)|(\\[(?<host_br>[^\\[\\]]*)\\]))(:(?<port>[0-9]*))?$","su")})();function p0(f){let X=f.split("&"),$=[];for(let A of X){if(A==="")continue;let J,R,Z=A.indexOf("=");if(Z<0)J=A,R="";else J=A.substring(0,Z),R=A.substring(Z+1);$.push({key:o(J.replaceAll("+"," ")),value:o(R.replaceAll("+"," "))})}return{pairs:$}}function o(f){try{return decodeURIComponent(f)}catch(X){if(X instanceof URIError)throw new K(`URL component has invalid percent encoding: ${X}`,"URL_INVALID",void 0,X);throw X}}function Ff(f,X,$){if(X===void 0)throw new K(`URL with scheme ${JSON.stringify(f+":")} requires authority (the "//" part)`,"URL_INVALID");let A=`${f}:`,J=b0(X.host),R=S0(X.port),Y=`//${v0(X.userinfo)}${J}${R}`,_=$.split("/").map(encodeURIComponent).join("/");if(_!==""&&!_.startsWith("/"))_="/"+_;return new URL(`${A}${Y}${_}`)}function b0(f){return f.includes(":")?`[${encodeURI(f)}]`:encodeURI(f)}function S0(f){return f!==void 0?`:${f}`:""}function v0(f){if(f===void 0)return"";let X=encodeURIComponent(f.username),$=f.password!==void 0?`:${encodeURIComponent(f.password)}`:"";return`${X}${$}@`}var _f=typeof Buffer==="function",p2=typeof TextDecoder==="function"?new TextDecoder:void 0,b2=typeof TextEncoder==="function"?new TextEncoder:void 0;var Mf=Array.prototype.slice.call("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="),cf=((f)=>{let X={};return f.forEach(($,A)=>X[$]=A),X})(Mf),u0=/^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/,U=String.fromCharCode.bind(String),S2=typeof Uint8Array.from==="function"?Uint8Array.from.bind(Uint8Array):(f)=>new Uint8Array(Array.prototype.slice.call(f,0)),g2=(f)=>f.replace(/=/g,"").replace(/[+\/]/g,(X)=>X=="+"?"-":"_"),i2=(f)=>f.replace(/[^A-Za-z0-9\+\/]/g,""),d2=(f)=>{let X,$,A,J,R="",Z=f.length%3;for(let Y=0;Y<f.length;){if(($=f.charCodeAt(Y++))>255||(A=f.charCodeAt(Y++))>255||(J=f.charCodeAt(Y++))>255)throw TypeError("invalid character found");X=$<<16|A<<8|J,R+=Mf[X>>18&63]+Mf[X>>12&63]+Mf[X>>6&63]+Mf[X&63]}return Z?R.slice(0,Z-3)+"===".substring(Z):R},G2=typeof btoa==="function"?(f)=>btoa(f):_f?(f)=>Buffer.from(f,"binary").toString("base64"):d2,N2=_f?(f)=>Buffer.from(f).toString("base64"):(f)=>{let $=[];for(let A=0,J=f.length;A<J;A+=4096)$.push(U.apply(null,f.subarray(A,A+4096)));return G2($.join(""))},tf=(f,X=!1)=>X?g2(N2(f)):N2(f),g0=(f)=>{if(f.length<2){var X=f.charCodeAt(0);return X<128?f:X<2048?U(192|X>>>6)+U(128|X&63):U(224|X>>>12&15)+U(128|X>>>6&63)+U(128|X&63)}else{var X=65536+(f.charCodeAt(0)-55296)*1024+(f.charCodeAt(1)-56320);return U(240|X>>>18&7)+U(128|X>>>12&63)+U(128|X>>>6&63)+U(128|X&63)}},i0=/[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g,n2=(f)=>f.replace(i0,g0),v2=_f?(f)=>Buffer.from(f,"utf8").toString("base64"):b2?(f)=>N2(b2.encode(f)):(f)=>G2(n2(f)),Yf=(f,X=!1)=>X?g2(v2(f)):v2(f),u2=(f)=>Yf(f,!0),d0=/[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g,n0=(f)=>{switch(f.length){case 4:var X=(7&f.charCodeAt(0))<<18|(63&f.charCodeAt(1))<<12|(63&f.charCodeAt(2))<<6|63&f.charCodeAt(3),$=X-65536;return U(($>>>10)+55296)+U(($&1023)+56320);case 3:return U((15&f.charCodeAt(0))<<12|(63&f.charCodeAt(1))<<6|63&f.charCodeAt(2));default:return U((31&f.charCodeAt(0))<<6|63&f.charCodeAt(1))}},m2=(f)=>f.replace(d0,n0),c2=(f)=>{if(f=f.replace(/\s+/g,""),!u0.test(f))throw TypeError("malformed base64.");f+="==".slice(2-(f.length&3));let X,$,A,J=[];for(let R=0;R<f.length;)if(X=cf[f.charAt(R++)]<<18|cf[f.charAt(R++)]<<12|($=cf[f.charAt(R++)])<<6|(A=cf[f.charAt(R++)]),$===64)J.push(U(X>>16&255));else if(A===64)J.push(U(X>>16&255,X>>8&255));else J.push(U(X>>16&255,X>>8&255,X&255));return J.join("")},O2=typeof atob==="function"?(f)=>atob(i2(f)):_f?(f)=>Buffer.from(f,"base64").toString("binary"):c2,t2=_f?(f)=>S2(Buffer.from(f,"base64")):(f)=>S2(O2(f).split("").map((X)=>X.charCodeAt(0))),l2=(f)=>t2(s2(f)),m0=_f?(f)=>Buffer.from(f,"base64").toString("utf8"):p2?(f)=>p2.decode(t2(f)):(f)=>m2(O2(f)),s2=(f)=>i2(f.replace(/[-_]/g,(X)=>X=="-"?"+":"/")),K2=(f)=>m0(s2(f)),c0=(f)=>{if(typeof f!=="string")return!1;let X=f.replace(/\s+/g,"").replace(/={0,2}$/,"");return!/[^\s0-9a-zA-Z\+/]/.test(X)||!/[^\s0-9a-zA-Z\-_]/.test(X)},a2=(f)=>{return{value:f,enumerable:!1,writable:!0,configurable:!0}},o2=function(){let f=(X,$)=>Object.defineProperty(String.prototype,X,a2($));f("fromBase64",function(){return K2(this)}),f("toBase64",function(X){return Yf(this,X)}),f("toBase64URI",function(){return Yf(this,!0)}),f("toBase64URL",function(){return Yf(this,!0)}),f("toUint8Array",function(){return l2(this)})},r2=function(){let f=(X,$)=>Object.defineProperty(Uint8Array.prototype,X,a2($));f("toBase64",function(X){return tf(this,X)}),f("toBase64URI",function(){return tf(this,!0)}),f("toBase64URL",function(){return tf(this,!0)})},t0=()=>{o2(),r2()},zf={version:"3.7.8",VERSION:"3.7.8",atob:O2,atobPolyfill:c2,btoa:G2,btoaPolyfill:d2,fromBase64:K2,toBase64:Yf,encode:Yf,encodeURI:u2,encodeURL:u2,utob:n2,btou:m2,decode:K2,isValid:c0,fromUint8Array:tf,toUint8Array:l2,extendString:o2,extendUint8Array:r2,extendBuiltins:t0};var E="https://github.com/libsql/libsql-client-ts#supported-urls";function g(f){if(f==="write")return"BEGIN IMMEDIATE";else if(f==="read")return"BEGIN TRANSACTION READONLY";else if(f==="deferred")return"BEGIN DEFERRED";else throw RangeError('Unknown transaction mode, supported values are "write", "read" and "deferred"')}class Nf{columns;columnTypes;rows;rowsAffected;lastInsertRowid;constructor(f,X,$,A,J){this.columns=f,this.columnTypes=X,this.rows=$,this.rowsAffected=A,this.lastInsertRowid=J}toJSON(){return{columns:this.columns,columnTypes:this.columnTypes,rows:this.rows.map(l0),rowsAffected:this.rowsAffected,lastInsertRowid:this.lastInsertRowid!==void 0?""+this.lastInsertRowid:null}}}function l0(f){return Array.prototype.map.call(f,s0)}function s0(f){if(typeof f==="bigint")return""+f;else if(f instanceof ArrayBuffer)return zf.fromUint8Array(new Uint8Array(f));else return f}var e2=":memory:";function f1(f){return f.scheme==="file"&&(f.path===":memory:"||f.path.startsWith(":memory:?"))}function wf(f,X){if(typeof f!=="object")throw TypeError(`Expected client configuration as object, got ${typeof f}`);let{url:$,authToken:A,tls:J,intMode:R,concurrency:Z}=f;Z=Math.max(0,Z||20),R??="number";let Y=[];if($===e2)$="file::memory:";let _=C2($),N=_.scheme.toLowerCase(),V=N==="file"&&_.path===e2&&_.authority===void 0,C;if(V)C={cache:{values:["shared","private"],update:(M,p)=>Y.push(`${M}=${p}`)}};else C={tls:{values:["0","1"],update:(M,p)=>J=p==="1"},authToken:{update:(M,p)=>A=p}};for(let{key:M,value:p}of _.query?.pairs??[]){if(!Object.hasOwn(C,M))throw new K(`Unsupported URL query parameter ${JSON.stringify(M)}`,"URL_PARAM_NOT_SUPPORTED");let Tf=C[M];if(Tf.values!==void 0&&!Tf.values.includes(p))throw new K(`Unknown value for the "${M}" query argument: ${JSON.stringify(p)}. Supported values are: [${Tf.values.map((P0)=>'"'+P0+'"').join(", ")}]`,"URL_INVALID");if(Tf.update!==void 0)Tf?.update(M,p)}let h=Y.length===0?"":`?${Y.join("&")}`,a=_.path+h,B;if(N==="libsql")if(J===!1){if(_.authority?.port===void 0)throw new K('A "libsql:" URL with ?tls=0 must specify an explicit port',"URL_INVALID");B=X?"http":"ws"}else B=X?"https":"wss";else B=N;if(B==="http"||B==="ws")J??=!1;else J??=!0;if(B!=="http"&&B!=="ws"&&B!=="https"&&B!=="wss"&&B!=="file")throw new K(`The client supports only "libsql:", "wss:", "ws:", "https:", "http:" and "file:" URLs, got ${JSON.stringify(_.scheme+":")}. For more information, please read ${E}`,"URL_SCHEME_NOT_SUPPORTED");if(R!=="number"&&R!=="bigint"&&R!=="string")throw TypeError(`Invalid value for intMode, expected "number", "bigint" or "string", got ${JSON.stringify(R)}`);if(_.fragment!==void 0)throw new K(`URL fragments are not supported: ${JSON.stringify("#"+_.fragment)}`,"URL_INVALID");if(V)return{scheme:"file",tls:!1,path:a,intMode:R,concurrency:Z,syncUrl:f.syncUrl,syncInterval:f.syncInterval,fetch:f.fetch,authToken:void 0,encryptionKey:void 0,authority:void 0};return{scheme:B,tls:J,authority:_.authority,path:a,authToken:A,intMode:R,concurrency:Z,encryptionKey:f.encryptionKey,syncUrl:f.syncUrl,syncInterval:f.syncInterval,fetch:f.fetch}}var sf=I2(q1(),1);import{Buffer as p1}from"node:buffer";function b1(f){if(f.scheme!=="file")throw new K(`URL scheme ${JSON.stringify(f.scheme+":")} is not supported by the local sqlite3 client. For more information, please read ${E}`,"URL_SCHEME_NOT_SUPPORTED");let X=f.authority;if(X!==void 0){let Z=X.host.toLowerCase();if(Z!==""&&Z!=="localhost")throw new K(`Invalid host in file URL: ${JSON.stringify(X.host)}. A "file:" URL with an absolute path should start with one slash ("file:/absolute/path.db") or with three slashes ("file:///absolute/path.db"). For more information, please read ${E}`,"URL_INVALID");if(X.port!==void 0)throw new K("File URL cannot have a port","URL_INVALID");if(X.userinfo!==void 0)throw new K("File URL cannot have username and password","URL_INVALID")}let $=f1(f);if($&&f.syncUrl)throw new K(`Embedded replica must use file for local db but URI with in-memory mode were provided instead: ${f.path}`,"URL_INVALID");let A=f.path;if($)A=`${f.scheme}:${f.path}`;let J={authToken:f.authToken,encryptionKey:f.encryptionKey,syncUrl:f.syncUrl,syncPeriod:f.syncInterval},R=new sf.default(A,J);return I(R,"SELECT 1 AS checkThatTheDatabaseCanBeOpened",f.intMode),new S1(A,J,R,f.intMode)}class S1{#f;#X;#$;#A;closed;protocol;constructor(f,X,$,A){this.#f=f,this.#X=X,this.#$=$,this.#A=A,this.closed=!1,this.protocol="file"}async execute(f,X){let $;if(typeof f==="string")$={sql:f,args:X||[]};else $=f;return this.#R(),I(this.#J(),$,this.#A)}async batch(f,X="deferred"){this.#R();let $=this.#J();try{I($,g(X),this.#A);let A=f.map((J)=>{if(!$.inTransaction)throw new K("The transaction has been rolled back","TRANSACTION_CLOSED");return I($,J,this.#A)});return I($,"COMMIT",this.#A),A}finally{if($.inTransaction)I($,"ROLLBACK",this.#A)}}async migrate(f){this.#R();let X=this.#J();try{I(X,"PRAGMA foreign_keys=off",this.#A),I(X,g("deferred"),this.#A);let $=f.map((A)=>{if(!X.inTransaction)throw new K("The transaction has been rolled back","TRANSACTION_CLOSED");return I(X,A,this.#A)});return I(X,"COMMIT",this.#A),$}finally{if(X.inTransaction)I(X,"ROLLBACK",this.#A);I(X,"PRAGMA foreign_keys=on",this.#A)}}async transaction(f="write"){let X=this.#J();return I(X,g(f),this.#A),this.#$=null,new v1(X,this.#A)}async executeMultiple(f){this.#R();let X=this.#J();try{return u1(X,f)}finally{if(X.inTransaction)I(X,"ROLLBACK",this.#A)}}async sync(){this.#R();let f=await this.#J().sync();return{frames_synced:f.frames_synced,frame_no:f.frame_no}}close(){if(this.closed=!0,this.#$!==null)this.#$.close()}#R(){if(this.closed)throw new K("The client is closed","CLIENT_CLOSED")}#J(){if(this.#$===null)this.#$=new sf.default(this.#f,this.#X);return this.#$}}class v1{#f;#X;constructor(f,X){this.#f=f,this.#X=X}async execute(f,X){let $;if(typeof f==="string")$={sql:f,args:X||[]};else $=f;return this.#$(),I(this.#f,$,this.#X)}async batch(f){return f.map((X)=>{return this.#$(),I(this.#f,X,this.#X)})}async executeMultiple(f){return this.#$(),u1(this.#f,f)}async rollback(){if(!this.#f.open)return;this.#$(),I(this.#f,"ROLLBACK",this.#X)}async commit(){this.#$(),I(this.#f,"COMMIT",this.#X)}close(){if(this.#f.inTransaction)I(this.#f,"ROLLBACK",this.#X)}get closed(){return!this.#f.inTransaction}#$(){if(this.closed)throw new K("The transaction is closed","TRANSACTION_CLOSED")}}function I(f,X,$){let A,J;if(typeof X==="string")A=X,J=[];else if(A=X.sql,Array.isArray(X.args))J=X.args.map((R)=>C1(R,$));else{J={};for(let R in X.args){let Z=R[0]==="@"||R[0]==="$"||R[0]===":"?R.substring(1):R;J[Z]=C1(X.args[R],$)}}try{let R=f.prepare(A);R.safeIntegers(!0);let Z=!0;try{R.raw(!0)}catch{Z=!1}if(Z){let Y=Array.from(R.columns().map((h)=>h.name)),_=Array.from(R.columns().map((h)=>h.type??"")),N=R.all(J).map((h)=>{return S6(h,Y,$)}),V=0,C=void 0;return new Nf(Y,_,N,0,void 0)}else{let Y=R.run(J),_=Y.changes,N=BigInt(Y.lastInsertRowid);return new Nf([],[],[],_,N)}}catch(R){throw g1(R)}}function S6(f,X,$){let A={};Object.defineProperty(A,"length",{value:f.length});for(let J=0;J<f.length;++J){let R=v6(f[J],$);Object.defineProperty(A,J,{value:R});let Z=X[J];if(!Object.hasOwn(A,Z))Object.defineProperty(A,Z,{value:R,enumerable:!0,configurable:!0,writable:!0})}return A}function v6(f,X){if(typeof f==="bigint")if(X==="number"){if(f<u6||f>g6)throw RangeError("Received integer which cannot be safely represented as a JavaScript number");return Number(f)}else if(X==="bigint")return f;else if(X==="string")return""+f;else throw Error("Invalid value for IntMode");else if(f instanceof p1)return f.buffer;return f}var u6=-9007199254740991n,g6=9007199254740991n;function C1(f,X){if(typeof f==="number"){if(!Number.isFinite(f))throw RangeError("Only finite numbers (not Infinity or NaN) can be passed as arguments");return f}else if(typeof f==="bigint"){if(f<i6||f>d6)throw RangeError("bigint is too large to be represented as a 64-bit integer and passed as argument");return f}else if(typeof f==="boolean")switch(X){case"bigint":return f?1n:0n;case"string":return f?"1":"0";default:return f?1:0}else if(f instanceof ArrayBuffer)return p1.from(f);else if(f instanceof Date)return f.valueOf();else if(f===void 0)throw TypeError("undefined cannot be passed as argument to the database");else return f}var i6=-9223372036854775808n,d6=9223372036854775807n;function u1(f,X){try{f.exec(X)}catch($){throw g1($)}}function g1(f){if(f instanceof sf.default.SqliteError)return new K(f.message,f.code,f.rawCode,f);return f}class Gf{constructor(){this.intMode="number"}intMode}class O extends Error{constructor(f){super(f);this.name="ClientError"}}class z extends O{constructor(f){super(f);this.name="ProtoError"}}class hf extends O{code;proto;constructor(f,X){super(f);this.name="ResponseError",this.code=X.code,this.proto=X,this.stack=void 0}}class x extends O{constructor(f,X){if(X!==void 0){super(`${f}: ${X}`);this.cause=X}else super(f);this.name="ClosedError"}}class Ef extends O{constructor(f){super(f);this.name="WebSocketUnsupportedError"}}class Of extends O{constructor(f){super(f);this.name="WebSocketError"}}class Xf extends O{status;constructor(f,X){super(f);this.status=X,this.name="HttpServerError"}}class w extends O{constructor(f){super(f);this.name="ProtocolVersionError"}}class y extends O{constructor(f){super(f);this.name="InternalError"}}class q extends O{constructor(f){super(f);this.name="MisuseError"}}function H(f){if(typeof f==="string")return f;throw Df(f,"string")}function L(f){if(f===null||f===void 0)return;else if(typeof f==="string")return f;throw Df(f,"string or null")}function S(f){if(typeof f==="number")return f;throw Df(f,"number")}function n(f){if(typeof f==="boolean")return f;throw Df(f,"boolean")}function Pf(f){if(Array.isArray(f))return f;throw Df(f,"array")}function Q(f){if(f!==null&&typeof f==="object"&&!Array.isArray(f))return f;throw Df(f,"object")}function j(f,X){return Pf(f).map(($)=>X(Q($)))}function Df(f,X){if(f===void 0)return new z(`Expected ${X}, but the property was missing`);let $=typeof f;if(f===null)$="null";else if(Array.isArray(f))$="array";return new z(`Expected ${X}, received ${$}`)}function $f(f,X){return X(Q(f))}class i1{#f;#X;constructor(f){this.#f=f,this.#X=!1}begin(){this.#f.push("{"),this.#X=!0}end(){this.#f.push("}"),this.#X=!1}#$(f){if(this.#X)this.#f.push('"'),this.#X=!1;else this.#f.push(',"');this.#f.push(f),this.#f.push('":')}string(f,X){this.#$(f),this.#f.push(JSON.stringify(X))}stringRaw(f,X){this.#$(f),this.#f.push('"'),this.#f.push(X),this.#f.push('"')}number(f,X){this.#$(f),this.#f.push(""+X)}boolean(f,X){this.#$(f),this.#f.push(X?"true":"false")}object(f,X,$){this.#$(f),this.begin(),$(this,X),this.end()}arrayObjects(f,X,$){this.#$(f),this.#f.push("[");for(let A=0;A<X.length;++A){if(A!==0)this.#f.push(",");this.begin(),$(this,X[A]),this.end()}this.#f.push("]")}}function kf(f,X){let $=[],A=new i1($);return A.begin(),X(A,f),A.end(),$.join("")}var Af=0,qf=1,Cf=2;var d1=5;class n1{#f;#X;#$;constructor(f){this.#f=f,this.#X=new DataView(f.buffer,f.byteOffset,f.byteLength),this.#$=0}varint(){let f=0;for(let X=0;;X+=7){let $=this.#f[this.#$++];if(f|=($&127)<<X,!($&128))break}return f}varintBig(){let f=0n;for(let X=0n;;X+=7n){let $=this.#f[this.#$++];if(f|=BigInt($&127)<<X,!($&128))break}return f}bytes(f){let X=new Uint8Array(this.#f.buffer,this.#f.byteOffset+this.#$,f);return this.#$+=f,X}double(){let f=this.#X.getFloat64(this.#$,!0);return this.#$+=8,f}skipVarint(){for(;;)if(!(this.#f[this.#$++]&128))break}skip(f){this.#$+=f}eof(){return this.#$>=this.#f.byteLength}}class m1{#f;#X;constructor(f){this.#f=f,this.#X=-1}setup(f){this.#X=f}#$(f){if(this.#X!==f)throw new z(`Expected wire type ${f}, got ${this.#X}`);this.#X=-1}bytes(){this.#$(Cf);let f=this.#f.varint();return this.#f.bytes(f)}string(){return new TextDecoder().decode(this.bytes())}message(f){return m(this.bytes(),f)}int32(){return this.#$(Af),this.#f.varint()}uint32(){return this.int32()}bool(){return this.int32()!==0}uint64(){return this.#$(Af),this.#f.varintBig()}sint64(){let f=this.uint64();return f>>1n^-(f&1n)}double(){return this.#$(qf),this.#f.double()}maybeSkip(){if(this.#X<0)return;else if(this.#X===Af)this.#f.skipVarint();else if(this.#X===qf)this.#f.skip(8);else if(this.#X===Cf){let f=this.#f.varint();this.#f.skip(f)}else if(this.#X===d1)this.#f.skip(4);else throw new z(`Unexpected wire type ${this.#X}`);this.#X=-1}}function m(f,X){let $=new n1(f),A=new m1($),J=X.default();while(!$.eof()){let R=$.varint(),Z=R>>3,Y=R&7;A.setup(Y);let _=X[Z];if(_!==void 0){let N=_(A,J);if(N!==void 0)J=N}A.maybeSkip()}return J}class B2{#f;#X;#$;#A;constructor(){this.#f=new ArrayBuffer(256),this.#X=new Uint8Array(this.#f),this.#$=new DataView(this.#f),this.#A=0}#R(f){if(this.#A+f<=this.#f.byteLength)return;let X=this.#f.byteLength;while(X<this.#A+f)X*=2;let $=new ArrayBuffer(X),A=new Uint8Array($),J=new DataView($);A.set(new Uint8Array(this.#f,0,this.#A)),this.#f=$,this.#X=A,this.#$=J}#J(f){this.#R(5),f=0|f;do{let X=f&127;f>>>=7,X|=f?128:0,this.#X[this.#A++]=X}while(f)}#Y(f){this.#R(10),f=f&0xffffffffffffffffn;do{let X=Number(f&0x7fn);f>>=7n,X|=f?128:0,this.#X[this.#A++]=X}while(f)}#Z(f,X){this.#J(f<<3|X)}bytes(f,X){this.#Z(f,Cf),this.#J(X.byteLength),this.#R(X.byteLength),this.#X.set(X,this.#A),this.#A+=X.byteLength}string(f,X){this.bytes(f,new TextEncoder().encode(X))}message(f,X,$){let A=new B2;$(A,X),this.bytes(f,A.data())}int32(f,X){this.#Z(f,Af),this.#J(X)}uint32(f,X){this.int32(f,X)}bool(f,X){this.int32(f,X?1:0)}sint64(f,X){this.#Z(f,Af),this.#Y(X<<1n^X>>63n)}double(f,X){this.#Z(f,qf),this.#R(8),this.#$.setFloat64(this.#A,X,!0),this.#A+=8}data(){return new Uint8Array(this.#f,0,this.#A)}}function pf(f,X){let $=new B2;return X($,f),$.data()}class c{#f;#X;constructor(){this.#f=new Set,this.#X=new Set}alloc(){for(let X of this.#X){if(this.#X.delete(X),this.#f.add(X),!this.#f.has(this.#f.size-1))this.#X.add(this.#f.size-1);return X}let f=this.#f.size;return this.#f.add(f),f}free(f){if(!this.#f.delete(f))throw new y("Freeing an id that is not allocated");if(this.#X.delete(this.#f.size),f<this.#f.size)this.#X.add(f)}}function G(f,X){throw new y(X)}function Wf(f){if(f===null)return null;else if(typeof f==="string")return f;else if(typeof f==="number"){if(!Number.isFinite(f))throw RangeError("Only finite numbers (not Infinity or NaN) can be passed as arguments");return f}else if(typeof f==="bigint"){if(f<m6||f>c6)throw RangeError("This bigint value is too large to be represented as a 64-bit integer and passed as argument");return f}else if(typeof f==="boolean")return f?1n:0n;else if(f instanceof ArrayBuffer)return new Uint8Array(f);else if(f instanceof Uint8Array)return f;else if(f instanceof Date)return+f.valueOf();else if(typeof f==="object")return""+f.toString();else throw TypeError("Unsupported type of value")}var m6=-9223372036854775808n,c6=9223372036854775807n;function U2(f,X){if(f===null)return null;else if(typeof f==="number")return f;else if(typeof f==="string")return f;else if(typeof f==="bigint")if(X==="number"){let $=Number(f);if(!Number.isSafeInteger($))throw RangeError("Received integer which is too large to be safely represented as a JavaScript number");return $}else if(X==="bigint")return f;else if(X==="string")return""+f;else throw new q("Invalid value for IntMode");else if(f instanceof Uint8Array)return f.slice().buffer;else if(f===void 0)throw new z("Received unrecognized type of Value");else throw G(f,"Impossible type of Value")}function Jf(f){return{affectedRowCount:f.affectedRowCount,lastInsertRowid:f.lastInsertRowid,columnNames:f.cols.map((X)=>X.name),columnDecltypes:f.cols.map((X)=>X.decltype)}}function of(f,X){let $=Jf(f),A=f.rows.map((J)=>c1($.columnNames,J,X));return{...$,rows:A}}function rf(f,X){let $=Jf(f),A;if(f.rows.length>0)A=c1($.columnNames,f.rows[0],X);return{...$,row:A}}function ef(f,X){let $=Jf(f),A;if(f.rows.length>0&&$.columnNames.length>0)A=U2(f.rows[0][0],X);return{...$,value:A}}function c1(f,X,$){let A={};Object.defineProperty(A,"length",{value:X.length});for(let J=0;J<X.length;++J){let R=U2(X[J],$);Object.defineProperty(A,J,{value:R});let Z=f[J];if(Z!==void 0&&!Object.hasOwn(A,Z))Object.defineProperty(A,Z,{value:R,enumerable:!0,configurable:!0,writable:!0})}return A}function v(f){return new hf(f.message,f)}class Rf{#f;#X;#$;constructor(f,X){this.#f=f,this.#X=X,this.#$=void 0}_getSqlId(f){if(this.#f!==f)throw new q("Attempted to use SQL text opened with other object");else if(this.#$!==void 0)throw new x("SQL text is closed",this.#$);return this.#X}close(){this._setClosed(new O("SQL text was manually closed"))}_setClosed(f){if(this.#$===void 0)this.#$=f,this.#f._closeSql(this.#X)}get closed(){return this.#$!==void 0}}function bf(f,X){if(X instanceof Rf)return{sqlId:X._getSqlId(f)};else return{sql:""+X}}class t{#f;#X;constructor(){this.#f=[],this.#X=[]}get length(){return this.#f.length+this.#X.length}push(f){this.#f.push(f)}shift(){if(this.#X.length===0&&this.#f.length>0)this.#X=this.#f.reverse(),this.#f=[];return this.#X.pop()}first(){return this.#X.length!==0?this.#X[this.#X.length-1]:this.#f[0]}}class xf{sql;_args;_namedArgs;constructor(f){this.sql=f,this._args=[],this._namedArgs=new Map}bindIndexes(f){this._args.length=0;for(let X of f)this._args.push(Wf(X));return this}bindIndex(f,X){if(f!==(f|0)||f<=0)throw RangeError("Index of a positional argument must be positive integer");while(this._args.length<f)this._args.push(null);return this._args[f-1]=Wf(X),this}bindName(f,X){return this._namedArgs.set(f,Wf(X)),this}unbindAll(){return this._args.length=0,this._namedArgs.clear(),this}}function f2(f,X,$){let A,J=[],R=[];if(X instanceof xf){A=X.sql,J=X._args;for(let[_,N]of X._namedArgs.entries())R.push({name:_,value:N})}else if(Array.isArray(X))if(A=X[0],Array.isArray(X[1]))J=X[1].map((_)=>Wf(_));else R=Object.entries(X[1]).map(([_,N])=>{return{name:_,value:Wf(N)}});else A=X;let{sql:Z,sqlId:Y}=bf(f,A);return{sql:Z,sqlId:Y,args:J,namedArgs:R,wantRows:$}}class X2{_stream;#f;_steps;#X;constructor(f,X){this._stream=f,this.#f=X,this._steps=[],this.#X=!1}step(){return new y2(this)}execute(){if(this.#X)throw new q("This batch has already been executed");this.#X=!0;let f={steps:this._steps.map((X)=>X.proto)};if(this.#f)return l6(this._stream,this._steps,f);else return t6(this._stream,this._steps,f)}}function t6(f,X,$){return f._batch($).then((A)=>{for(let J=0;J<X.length;++J){let R=A.stepResults.get(J),Z=A.stepErrors.get(J);X[J].callback(R,Z)}})}async function l6(f,X,$){let A=await f._openCursor($);try{let J=0,R=void 0,Z=[];for(;;){let Y=await A.next();if(Y===void 0)break;if(Y.type==="step_begin"){if(Y.step<J||Y.step>=X.length)throw new z("Server produced StepBeginEntry for unexpected step");else if(R!==void 0)throw new z("Server produced StepBeginEntry before terminating previous step");for(let _=J;_<Y.step;++_)X[_].callback(void 0,void 0);J=Y.step+1,R=Y,Z=[]}else if(Y.type==="step_end"){if(R===void 0)throw new z("Server produced StepEndEntry but no step is active");let _={cols:R.cols,rows:Z,affectedRowCount:Y.affectedRowCount,lastInsertRowid:Y.lastInsertRowid};X[R.step].callback(_,void 0),R=void 0,Z=[]}else if(Y.type==="step_error"){if(R===void 0){if(Y.step>=X.length)throw new z("Server produced StepErrorEntry for unexpected step");for(let _=J;_<Y.step;++_)X[_].callback(void 0,void 0)}else{if(Y.step!==R.step)throw new z("Server produced StepErrorEntry for unexpected step");R=void 0,Z=[]}X[Y.step].callback(void 0,Y.error),J=Y.step+1}else if(Y.type==="row"){if(R===void 0)throw new z("Server produced RowEntry but no step is active");Z.push(Y.row)}else if(Y.type==="error")throw v(Y.error);else if(Y.type==="none")throw new z("Server produced unrecognized CursorEntry");else throw G(Y,"Impossible CursorEntry")}if(R!==void 0)throw new z("Server closed Cursor before terminating active step");for(let Y=J;Y<X.length;++Y)X[Y].callback(void 0,void 0)}finally{A.close()}}class y2{_batch;#f;_index;constructor(f){this._batch=f,this.#f=[],this._index=void 0}condition(f){return this.#f.push(f._proto),this}query(f){return this.#X(f,!0,of)}queryRow(f){return this.#X(f,!0,rf)}queryValue(f){return this.#X(f,!0,ef)}run(f){return this.#X(f,!1,Jf)}#X(f,X,$){if(this._index!==void 0)throw new q("This BatchStep has already been added to the batch");let A=f2(this._batch._stream._sqlOwner(),f,X),J;if(this.#f.length===0)J=void 0;else if(this.#f.length===1)J=this.#f[0];else J={type:"and",conds:this.#f.slice()};let R={stmt:A,condition:J};return new Promise((Z,Y)=>{let _=(N,V)=>{if(N!==void 0&&V!==void 0)Y(new z("Server returned both result and error"));else if(V!==void 0)Y(v(V));else if(N!==void 0)Z($(N,this._batch._stream.intMode));else Z(void 0)};this._index=this._batch._steps.length,this._batch._steps.push({proto:R,callback:_})})}}class D{_batch;_proto;constructor(f,X){this._batch=f,this._proto=X}static ok(f){return new D(f._batch,{type:"ok",step:t1(f)})}static error(f){return new D(f._batch,{type:"error",step:t1(f)})}static not(f){return new D(f._batch,{type:"not",cond:f._proto})}static and(f,X){for(let $ of X)l1(f,$);return new D(f,{type:"and",conds:X.map(($)=>$._proto)})}static or(f,X){for(let $ of X)l1(f,$);return new D(f,{type:"or",conds:X.map(($)=>$._proto)})}static isAutocommit(f){return f._stream.client()._ensureVersion(3,"BatchCond.isAutocommit()"),new D(f,{type:"is_autocommit"})}}function t1(f){if(f._index===void 0)throw new q("Cannot add a condition referencing a step that has not been added to the batch");return f._index}function l1(f,X){if(X._batch!==f)throw new q("Cannot mix BatchCond objects for different Batch objects")}function s1(f){return{paramNames:f.params.map((X)=>X.name),columns:f.cols,isExplain:f.isExplain,isReadonly:f.isReadonly}}class Qf{constructor(f){this.intMode=f}query(f){return this.#f(f,!0,of)}queryRow(f){return this.#f(f,!0,rf)}queryValue(f){return this.#f(f,!0,ef)}run(f){return this.#f(f,!1,Jf)}#f(f,X,$){let A=f2(this._sqlOwner(),f,X);return this._execute(A).then((J)=>$(J,this.intMode))}batch(f=!1){return new X2(this,f)}describe(f){let X=bf(this._sqlOwner(),f);return this._describe(X).then(s1)}sequence(f){let X=bf(this._sqlOwner(),f);return this._sequence(X)}intMode}class Sf{}var s6=1000,a6=10;class V2 extends Sf{#f;#X;#$;#A;#R;#J;#Y;constructor(f,X,$){super();this.#f=f,this.#X=X,this.#$=$,this.#A=new t,this.#R=new t,this.#J=void 0,this.#Y=!1}async next(){for(;;){if(this.#J!==void 0)throw new x("Cursor is closed",this.#J);while(!this.#Y&&this.#R.length<a6)this.#R.push(this.#Z());let f=this.#A.shift();if(this.#Y||f!==void 0)return f;await this.#R.shift().then((X)=>{if(X===void 0)return;for(let $ of X.entries)this.#A.push($);this.#Y||=X.done})}}#Z(){return this.#X._sendCursorRequest(this,{type:"fetch_cursor",cursorId:this.#$,maxCount:s6}).then((f)=>f,(f)=>{this._setClosed(f);return})}_setClosed(f){if(this.#J!==void 0)return;this.#J=f,this.#X._sendCursorRequest(this,{type:"close_cursor",cursorId:this.#$}).catch(()=>{return}),this.#X._cursorClosed(this)}close(){this._setClosed(new O("Cursor was manually closed"))}get closed(){return this.#J!==void 0}}class vf extends Qf{#f;#X;#$;#A;#R;#J;static open(f){let X=f._streamIdAlloc.alloc(),$=new vf(f,X),A=()=>{return},J=(Z)=>$.#z(Z),R={type:"open_stream",streamId:X};return f._sendRequest(R,{responseCallback:A,errorCallback:J}),$}constructor(f,X){super(f.intMode);this.#f=f,this.#X=X,this.#$=new t,this.#A=void 0,this.#R=!1,this.#J=void 0}client(){return this.#f}_sqlOwner(){return this.#f}_execute(f){return this.#Y({type:"execute",streamId:this.#X,stmt:f}).then((X)=>{return X.result})}_batch(f){return this.#Y({type:"batch",streamId:this.#X,batch:f}).then((X)=>{return X.result})}_describe(f){return this.#f._ensureVersion(2,"describe()"),this.#Y({type:"describe",streamId:this.#X,sql:f.sql,sqlId:f.sqlId}).then((X)=>{return X.result})}_sequence(f){return this.#f._ensureVersion(2,"sequence()"),this.#Y({type:"sequence",streamId:this.#X,sql:f.sql,sqlId:f.sqlId}).then((X)=>{return})}getAutocommit(){return this.#f._ensureVersion(3,"getAutocommit()"),this.#Y({type:"get_autocommit",streamId:this.#X}).then((f)=>{return f.isAutocommit})}#Y(f){return new Promise((X,$)=>{this.#Z({type:"request",request:f,responseCallback:X,errorCallback:$})})}_openCursor(f){return this.#f._ensureVersion(3,"cursor"),new Promise((X,$)=>{this.#Z({type:"cursor",batch:f,cursorCallback:X,errorCallback:$})})}_sendCursorRequest(f,X){if(f!==this.#A)throw new y("Cursor not associated with the stream attempted to execute a request");return new Promise(($,A)=>{if(this.#J!==void 0)A(new x("Stream is closed",this.#J));else this.#f._sendRequest(X,{responseCallback:$,errorCallback:A})})}_cursorClosed(f){if(f!==this.#A)throw new y("Cursor was closed, but it was not associated with the stream");this.#A=void 0,this.#_()}#Z(f){if(this.#J!==void 0)f.errorCallback(new x("Stream is closed",this.#J));else if(this.#R)f.errorCallback(new x("Stream is closing",void 0));else this.#$.push(f),this.#_()}#_(){for(;;){let f=this.#$.first();if(f===void 0&&this.#A===void 0&&this.#R){this.#z(new O("Stream was gracefully closed"));break}else if(f?.type==="request"&&this.#A===void 0){let{request:X,responseCallback:$,errorCallback:A}=f;this.#$.shift(),this.#f._sendRequest(X,{responseCallback:$,errorCallback:A})}else if(f?.type==="cursor"&&this.#A===void 0){let{batch:X,cursorCallback:$}=f;this.#$.shift();let A=this.#f._cursorIdAlloc.alloc(),J=new V2(this.#f,this,A),R={type:"open_cursor",streamId:this.#X,cursorId:A,batch:X},Z=()=>{return},Y=(_)=>J._setClosed(_);this.#f._sendRequest(R,{responseCallback:Z,errorCallback:Y}),this.#A=J,$(J)}else break}}#z(f){if(this.#J!==void 0)return;if(this.#J=f,this.#A!==void 0)this.#A._setClosed(f);for(;;){let J=this.#$.shift();if(J!==void 0)J.errorCallback(f);else break}let X={type:"close_stream",streamId:this.#X},$=()=>this.#f._streamIdAlloc.free(this.#X),A=()=>{return};this.#f._sendRequest(X,{responseCallback:$,errorCallback:A})}close(){this.#z(new O("Stream was manually closed"))}closeGracefully(){this.#R=!0,this.#_()}get closed(){return this.#J!==void 0||this.#R}}function uf(f,X){if(X.sql!==void 0)f.string("sql",X.sql);if(X.sqlId!==void 0)f.number("sql_id",X.sqlId);f.arrayObjects("args",X.args,a1),f.arrayObjects("named_args",X.namedArgs,o6),f.boolean("want_rows",X.wantRows)}function o6(f,X){f.string("name",X.name),f.object("value",X.value,a1)}function If(f,X){f.arrayObjects("steps",X.steps,r6)}function r6(f,X){if(X.condition!==void 0)f.object("condition",X.condition,H2);f.object("stmt",X.stmt,uf)}function H2(f,X){if(f.stringRaw("type",X.type),X.type==="ok"||X.type==="error")f.number("step",X.step);else if(X.type==="not")f.object("cond",X.cond,H2);else if(X.type==="and"||X.type==="or")f.arrayObjects("conds",X.conds,H2);else if(X.type==="is_autocommit");else throw G(X,"Impossible type of BatchCond")}function a1(f,X){if(X===null)f.stringRaw("type","null");else if(typeof X==="bigint")f.stringRaw("type","integer"),f.stringRaw("value",""+X);else if(typeof X==="number")f.stringRaw("type","float"),f.number("value",X);else if(typeof X==="string")f.stringRaw("type","text"),f.string("value",X);else if(X instanceof Uint8Array)f.stringRaw("type","blob"),f.stringRaw("base64",zf.fromUint8Array(X));else if(X===void 0);else throw G(X,"Impossible type of Value")}function o1(f,X){if(f.stringRaw("type",X.type),X.type==="hello"){if(X.jwt!==void 0)f.string("jwt",X.jwt)}else if(X.type==="request")f.number("request_id",X.requestId),f.object("request",X.request,e6);else throw G(X,"Impossible type of ClientMsg")}function e6(f,X){if(f.stringRaw("type",X.type),X.type==="open_stream")f.number("stream_id",X.streamId);else if(X.type==="close_stream")f.number("stream_id",X.streamId);else if(X.type==="execute")f.number("stream_id",X.streamId),f.object("stmt",X.stmt,uf);else if(X.type==="batch")f.number("stream_id",X.streamId),f.object("batch",X.batch,If);else if(X.type==="open_cursor")f.number("stream_id",X.streamId),f.number("cursor_id",X.cursorId),f.object("batch",X.batch,If);else if(X.type==="close_cursor")f.number("cursor_id",X.cursorId);else if(X.type==="fetch_cursor")f.number("cursor_id",X.cursorId),f.number("max_count",X.maxCount);else if(X.type==="sequence"){if(f.number("stream_id",X.streamId),X.sql!==void 0)f.string("sql",X.sql);if(X.sqlId!==void 0)f.number("sql_id",X.sqlId)}else if(X.type==="describe"){if(f.number("stream_id",X.streamId),X.sql!==void 0)f.string("sql",X.sql);if(X.sqlId!==void 0)f.number("sql_id",X.sqlId)}else if(X.type==="store_sql")f.number("sql_id",X.sqlId),f.string("sql",X.sql);else if(X.type==="close_sql")f.number("sql_id",X.sqlId);else if(X.type==="get_autocommit")f.number("stream_id",X.streamId);else throw G(X,"Impossible type of Request")}function gf(f,X){if(X.sql!==void 0)f.string(1,X.sql);if(X.sqlId!==void 0)f.int32(2,X.sqlId);for(let $ of X.args)f.message(3,$,e1);for(let $ of X.namedArgs)f.message(4,$,f3);f.bool(5,X.wantRows)}function f3(f,X){f.string(1,X.name),f.message(2,X.value,e1)}function Bf(f,X){for(let $ of X.steps)f.message(1,$,X3)}function X3(f,X){if(X.condition!==void 0)f.message(1,X.condition,L2);f.message(2,X.stmt,gf)}function L2(f,X){if(X.type==="ok")f.uint32(1,X.step);else if(X.type==="error")f.uint32(2,X.step);else if(X.type==="not")f.message(3,X.cond,L2);else if(X.type==="and")f.message(4,X.conds,r1);else if(X.type==="or")f.message(5,X.conds,r1);else if(X.type==="is_autocommit")f.message(6,void 0,f0);else throw G(X,"Impossible type of BatchCond")}function r1(f,X){for(let $ of X)f.message(1,$,L2)}function e1(f,X){if(X===null)f.message(1,void 0,f0);else if(typeof X==="bigint")f.sint64(2,X);else if(typeof X==="number")f.double(3,X);else if(typeof X==="string")f.string(4,X);else if(X instanceof Uint8Array)f.bytes(5,X);else if(X===void 0);else throw G(X,"Impossible type of Value")}function f0(f,X){}function X0(f,X){if(X.type==="hello")f.message(1,X,$3);else if(X.type==="request")f.message(2,X,A3);else throw G(X,"Impossible type of ClientMsg")}function $3(f,X){if(X.jwt!==void 0)f.string(1,X.jwt)}function A3(f,X){f.int32(1,X.requestId);let $=X.request;if($.type==="open_stream")f.message(2,$,J3);else if($.type==="close_stream")f.message(3,$,R3);else if($.type==="execute")f.message(4,$,Z3);else if($.type==="batch")f.message(5,$,Y3);else if($.type==="open_cursor")f.message(6,$,_3);else if($.type==="close_cursor")f.message(7,$,z3);else if($.type==="fetch_cursor")f.message(8,$,N3);else if($.type==="sequence")f.message(9,$,K3);else if($.type==="describe")f.message(10,$,G3);else if($.type==="store_sql")f.message(11,$,O3);else if($.type==="close_sql")f.message(12,$,D3);else if($.type==="get_autocommit")f.message(13,$,W3);else throw G($,"Impossible type of Request")}function J3(f,X){f.int32(1,X.streamId)}function R3(f,X){f.int32(1,X.streamId)}function Z3(f,X){f.int32(1,X.streamId),f.message(2,X.stmt,gf)}function Y3(f,X){f.int32(1,X.streamId),f.message(2,X.batch,Bf)}function _3(f,X){f.int32(1,X.streamId),f.int32(2,X.cursorId),f.message(3,X.batch,Bf)}function z3(f,X){f.int32(1,X.cursorId)}function N3(f,X){f.int32(1,X.cursorId),f.uint32(2,X.maxCount)}function K3(f,X){if(f.int32(1,X.streamId),X.sql!==void 0)f.string(2,X.sql);if(X.sqlId!==void 0)f.int32(3,X.sqlId)}function G3(f,X){if(f.int32(1,X.streamId),X.sql!==void 0)f.string(2,X.sql);if(X.sqlId!==void 0)f.int32(3,X.sqlId)}function O3(f,X){f.int32(1,X.sqlId),f.string(2,X.sql)}function D3(f,X){f.int32(1,X.sqlId)}function W3(f,X){f.int32(1,X.streamId)}function l(f){let X=H(f.message),$=L(f.code);return{message:X,code:$}}function df(f){let X=j(f.cols,$0),$=Pf(f.rows).map((Z)=>j(Z,A0)),A=S(f.affected_row_count),J=L(f.last_insert_rowid),R=J!==void 0?BigInt(J):void 0;return{cols:X,rows:$,affectedRowCount:A,lastInsertRowid:R}}function $0(f){let X=L(f.name),$=L(f.decltype);return{name:X,decltype:$}}function $2(f){let X=new Map;Pf(f.step_results).forEach((A,J)=>{if(A!==null)X.set(J,df(Q(A)))});let $=new Map;return Pf(f.step_errors).forEach((A,J)=>{if(A!==null)$.set(J,l(Q(A)))}),{stepResults:X,stepErrors:$}}function A2(f){let X=H(f.type);if(X==="step_begin"){let $=S(f.step),A=j(f.cols,$0);return{type:"step_begin",step:$,cols:A}}else if(X==="step_end"){let $=S(f.affected_row_count),A=L(f.last_insert_rowid),J=A!==void 0?BigInt(A):void 0;return{type:"step_end",affectedRowCount:$,lastInsertRowid:J}}else if(X==="step_error"){let $=S(f.step),A=l(Q(f.error));return{type:"step_error",step:$,error:A}}else if(X==="row")return{type:"row",row:j(f.row,A0)};else if(X==="error")return{type:"error",error:l(Q(f.error))};else throw new z("Unexpected type of CursorEntry")}function J2(f){let X=j(f.params,x3),$=j(f.cols,Q3),A=n(f.is_explain),J=n(f.is_readonly);return{params:X,cols:$,isExplain:A,isReadonly:J}}function x3(f){return{name:L(f.name)}}function Q3(f){let X=H(f.name),$=L(f.decltype);return{name:X,decltype:$}}function A0(f){let X=H(f.type);if(X==="null")return null;else if(X==="integer"){let $=H(f.value);return BigInt($)}else if(X==="float")return S(f.value);else if(X==="text")return H(f.value);else if(X==="blob")return zf.toUint8Array(H(f.base64));else throw new z("Unexpected type of Value")}function J0(f){let X=H(f.type);if(X==="hello_ok")return{type:"hello_ok"};else if(X==="hello_error")return{type:"hello_error",error:l(Q(f.error))};else if(X==="response_ok"){let $=S(f.request_id),A=I3(Q(f.response));return{type:"response_ok",requestId:$,response:A}}else if(X==="response_error"){let $=S(f.request_id),A=l(Q(f.error));return{type:"response_error",requestId:$,error:A}}else throw new z("Unexpected type of ServerMsg")}function I3(f){let X=H(f.type);if(X==="open_stream")return{type:"open_stream"};else if(X==="close_stream")return{type:"close_stream"};else if(X==="execute")return{type:"execute",result:df(Q(f.result))};else if(X==="batch")return{type:"batch",result:$2(Q(f.result))};else if(X==="open_cursor")return{type:"open_cursor"};else if(X==="close_cursor")return{type:"close_cursor"};else if(X==="fetch_cursor"){let $=j(f.entries,A2),A=n(f.done);return{type:"fetch_cursor",entries:$,done:A}}else if(X==="sequence")return{type:"sequence"};else if(X==="describe")return{type:"describe",result:J2(Q(f.result))};else if(X==="store_sql")return{type:"store_sql"};else if(X==="close_sql")return{type:"close_sql"};else if(X==="get_autocommit")return{type:"get_autocommit",isAutocommit:n(f.is_autocommit)};else throw new z("Unexpected type of Response")}var F={default(){return{message:"",code:void 0}},1(f,X){X.message=f.string()},2(f,X){X.code=f.string()}},s={default(){return{cols:[],rows:[],affectedRowCount:0,lastInsertRowid:void 0}},1(f,X){X.cols.push(f.message(R0))},2(f,X){X.rows.push(f.message(Z0))},3(f,X){X.affectedRowCount=Number(f.uint64())},4(f,X){X.lastInsertRowid=f.sint64()}},R0={default(){return{name:void 0,decltype:void 0}},1(f,X){X.name=f.string()},2(f,X){X.decltype=f.string()}},Z0={default(){return[]},1(f,X){X.push(f.message(F3))}},Uf={default(){return{stepResults:new Map,stepErrors:new Map}},1(f,X){let[$,A]=f.message(B3);X.stepResults.set($,A)},2(f,X){let[$,A]=f.message(U3);X.stepErrors.set($,A)}},B3={default(){return[0,s.default()]},1(f,X){X[0]=f.uint32()},2(f,X){X[1]=f.message(s)}},U3={default(){return[0,F.default()]},1(f,X){X[0]=f.uint32()},2(f,X){X[1]=f.message(F)}},R2={default(){return{type:"none"}},1(f){return f.message(y3)},2(f){return f.message(V3)},3(f){return f.message(H3)},4(f){return{type:"row",row:f.message(Z0)}},5(f){return{type:"error",error:f.message(F)}}},y3={default(){return{type:"step_begin",step:0,cols:[]}},1(f,X){X.step=f.uint32()},2(f,X){X.cols.push(f.message(R0))}},V3={default(){return{type:"step_end",affectedRowCount:0,lastInsertRowid:void 0}},1(f,X){X.affectedRowCount=f.uint32()},2(f,X){X.lastInsertRowid=f.uint64()}},H3={default(){return{type:"step_error",step:0,error:F.default()}},1(f,X){X.step=f.uint32()},2(f,X){X.error=f.message(F)}},yf={default(){return{params:[],cols:[],isExplain:!1,isReadonly:!1}},1(f,X){X.params.push(f.message(L3))},2(f,X){X.cols.push(f.message(T3))},3(f,X){X.isExplain=f.bool()},4(f,X){X.isReadonly=f.bool()}},L3={default(){return{name:void 0}},1(f,X){X.name=f.string()}},T3={default(){return{name:"",decltype:void 0}},1(f,X){X.name=f.string()},2(f,X){X.decltype=f.string()}},F3={default(){return},1(f){return null},2(f){return f.sint64()},3(f){return f.double()},4(f){return f.string()},5(f){return f.bytes()}};var Y0={default(){return{type:"none"}},1(f){return{type:"hello_ok"}},2(f){return f.message(M3)},3(f){return f.message(j3)},4(f){return f.message(w3)}},M3={default(){return{type:"hello_error",error:F.default()}},1(f,X){X.error=f.message(F)}},w3={default(){return{type:"response_error",requestId:0,error:F.default()}},1(f,X){X.requestId=f.int32()},2(f,X){X.error=f.message(F)}},j3={default(){return{type:"response_ok",requestId:0,response:{type:"none"}}},1(f,X){X.requestId=f.int32()},2(f,X){X.response={type:"open_stream"}},3(f,X){X.response={type:"close_stream"}},4(f,X){X.response=f.message(h3)},5(f,X){X.response=f.message(E3)},6(f,X){X.response={type:"open_cursor"}},7(f,X){X.response={type:"close_cursor"}},8(f,X){X.response=f.message(P3)},9(f,X){X.response={type:"sequence"}},10(f,X){X.response=f.message(k3)},11(f,X){X.response={type:"store_sql"}},12(f,X){X.response={type:"close_sql"}},13(f,X){X.response=f.message(q3)}},h3={default(){return{type:"execute",result:s.default()}},1(f,X){X.result=f.message(s)}},E3={default(){return{type:"batch",result:Uf.default()}},1(f,X){X.result=f.message(Uf)}},P3={default(){return{type:"fetch_cursor",entries:[],done:!1}},1(f,X){X.entries.push(f.message(R2))},2(f,X){X.done=f.bool()}},k3={default(){return{type:"describe",result:yf.default()}},1(f,X){X.result=f.message(yf)}},q3={default(){return{type:"get_autocommit",isAutocommit:!1}},1(f,X){X.isAutocommit=f.bool()}};var _0=new Map([["hrana2",{version:2,encoding:"json"}],["hrana1",{version:1,encoding:"json"}]]),T2=new Map([["hrana3-protobuf",{version:3,encoding:"protobuf"}],["hrana3",{version:3,encoding:"json"}],["hrana2",{version:2,encoding:"json"}],["hrana1",{version:1,encoding:"json"}]]);class Z2 extends Gf{#f;#X;#$;#A;#R;#J;#Y;#Z;#_;_streamIdAlloc;_cursorIdAlloc;#z;constructor(f,X){super();this.#f=f,this.#X=[],this.#$=!1,this.#A=void 0,this.#R=!1,this.#J=void 0,this.#Y=!1,this.#Z=new Map,this.#_=new c,this._streamIdAlloc=new c,this._cursorIdAlloc=new c,this.#z=new c,this.#f.binaryType="arraybuffer",this.#f.addEventListener("open",()=>this.#D()),this.#f.addEventListener("close",($)=>this.#O($)),this.#f.addEventListener("error",($)=>this.#W($)),this.#f.addEventListener("message",($)=>this.#Q($)),this.#K({type:"hello",jwt:X})}#K(f){if(this.#A!==void 0)throw new y("Trying to send a message on a closed client");if(this.#$)this.#G(f);else{let X=()=>this.#G(f),$=()=>{return};this.#X.push({openCallback:X,errorCallback:$})}}#D(){let f=this.#f.protocol;if(f===void 0){this.#N(new O("The `WebSocket.protocol` property is undefined. This most likely means that the WebSocket implementation provided by the environment is broken. If you are using Miniflare 2, please update to Miniflare 3, which fixes this problem."));return}else if(f==="")this.#J={version:1,encoding:"json"};else if(this.#J=T2.get(f),this.#J===void 0){this.#N(new z(`Unrecognized WebSocket subprotocol: ${JSON.stringify(f)}`));return}for(let X of this.#X)X.openCallback();this.#X.length=0,this.#$=!0}#G(f){let X=this.#J.encoding;if(X==="json"){let $=kf(f,o1);this.#f.send($)}else if(X==="protobuf"){let $=pf(f,X0);this.#f.send($)}else throw G(X,"Impossible encoding")}getVersion(){return new Promise((f,X)=>{if(this.#Y=!0,this.#A!==void 0)X(this.#A);else if(!this.#$){let $=()=>f(this.#J.version);this.#X.push({openCallback:$,errorCallback:X})}else f(this.#J.version)})}_ensureVersion(f,X){if(this.#J===void 0||!this.#Y)throw new w(`${X} is supported only on protocol version ${f} and higher, but the version supported by the WebSocket server is not yet known. Use Client.getVersion() to wait until the version is available.`);else if(this.#J.version<f)throw new w(`${X} is supported on protocol version ${f} and higher, but the WebSocket server only supports version ${this.#J.version}`)}_sendRequest(f,X){if(this.#A!==void 0){X.errorCallback(new x("Client is closed",this.#A));return}let $=this.#_.alloc();this.#Z.set($,{...X,type:f.type}),this.#K({type:"request",requestId:$,request:f})}#W(f){let $=f.message??"WebSocket was closed due to an error";this.#N(new Of($))}#O(f){let X=`WebSocket was closed with code ${f.code}`;if(f.reason)X+=`: ${f.reason}`;this.#N(new Of(X))}#N(f){if(this.#A!==void 0)return;this.#A=f;for(let X of this.#X)X.errorCallback(f);this.#X.length=0;for(let[X,$]of this.#Z.entries())$.errorCallback(f),this.#_.free(X);this.#Z.clear(),this.#f.close()}#Q(f){if(this.#A!==void 0)return;try{let X,$=this.#J.encoding;if($==="json"){if(typeof f.data!=="string"){this.#f.close(3003,"Only text messages are accepted with JSON encoding"),this.#N(new z("Received non-text message from server with JSON encoding"));return}X=$f(JSON.parse(f.data),J0)}else if($==="protobuf"){if(!(f.data instanceof ArrayBuffer)){this.#f.close(3003,"Only binary messages are accepted with Protobuf encoding"),this.#N(new z("Received non-binary message from server with Protobuf encoding"));return}X=m(new Uint8Array(f.data),Y0)}else throw G($,"Impossible encoding");this.#x(X)}catch(X){this.#f.close(3007,"Could not handle message"),this.#N(X)}}#x(f){if(f.type==="none")throw new z("Received an unrecognized ServerMsg");else if(f.type==="hello_ok"||f.type==="hello_error"){if(this.#R)throw new z("Received a duplicated hello response");if(this.#R=!0,f.type==="hello_error")throw v(f.error);return}else if(!this.#R)throw new z("Received a non-hello message before a hello response");if(f.type==="response_ok"){let X=f.requestId,$=this.#Z.get(X);if(this.#Z.delete(X),$===void 0)throw new z("Received unexpected OK response");this.#_.free(X);try{if($.type!==f.response.type)throw console.dir({responseState:$,msg:f}),new z("Received unexpected type of response");$.responseCallback(f.response)}catch(A){throw $.errorCallback(A),A}}else if(f.type==="response_error"){let X=f.requestId,$=this.#Z.get(X);if(this.#Z.delete(X),$===void 0)throw new z("Received unexpected error response");this.#_.free(X),$.errorCallback(v(f.error))}else throw G(f,"Impossible ServerMsg type")}openStream(){return vf.open(this)}storeSql(f){this._ensureVersion(2,"storeSql()");let X=this.#z.alloc(),$=new Rf(this,X),A=()=>{return},J=(Z)=>$._setClosed(Z),R={type:"store_sql",sqlId:X,sql:f};return this._sendRequest(R,{responseCallback:A,errorCallback:J}),$}_closeSql(f){if(this.#A!==void 0)return;let X=()=>this.#z.free(f),$=(J)=>this.#N(J),A={type:"close_sql",sqlId:f};this._sendRequest(A,{responseCallback:X,errorCallback:$})}close(){this.#N(new O("Client was manually closed"))}get closed(){return this.#A!==void 0}}var nf=Request,F2=Headers,M2=fetch;var Zf;if(typeof queueMicrotask<"u")Zf=queueMicrotask;else{let f=Promise.resolve();Zf=(X)=>{f.then(X)}}class w2{#f;#X;#$;constructor(f){this.#f=new Uint8Array(new ArrayBuffer(f)),this.#X=0,this.#$=0}get length(){return this.#$-this.#X}data(){return this.#f.slice(this.#X,this.#$)}push(f){this.#A(f.byteLength),this.#f.set(f,this.#$),this.#$+=f.byteLength}#A(f){if(this.#$+f<=this.#f.byteLength)return;let X=this.#$-this.#X;if(X+f<=this.#f.byteLength&&2*this.#$>=this.#f.byteLength)this.#f.copyWithin(0,this.#X,this.#$);else{let $=this.#f.byteLength;do $*=2;while(X+f>$);let A=new Uint8Array(new ArrayBuffer($));A.set(this.#f.slice(this.#X,this.#$),0),this.#f=A}this.#$=X,this.#X=0}shift(f){this.#X+=f}}function z0(f){let X=L(f.baton),$=L(f.base_url),A=j(f.results,C3);return{baton:X,baseUrl:$,results:A}}function C3(f){let X=H(f.type);if(X==="ok")return{type:"ok",response:p3(Q(f.response))};else if(X==="error")return{type:"error",error:l(Q(f.error))};else throw new z("Unexpected type of StreamResult")}function p3(f){let X=H(f.type);if(X==="close")return{type:"close"};else if(X==="execute")return{type:"execute",result:df(Q(f.result))};else if(X==="batch")return{type:"batch",result:$2(Q(f.result))};else if(X==="sequence")return{type:"sequence"};else if(X==="describe")return{type:"describe",result:J2(Q(f.result))};else if(X==="store_sql")return{type:"store_sql"};else if(X==="close_sql")return{type:"close_sql"};else if(X==="get_autocommit")return{type:"get_autocommit",isAutocommit:n(f.is_autocommit)};else throw new z("Unexpected type of StreamResponse")}function N0(f){let X=L(f.baton),$=L(f.base_url);return{baton:X,baseUrl:$}}var K0={default(){return{baton:void 0,baseUrl:void 0,results:[]}},1(f,X){X.baton=f.string()},2(f,X){X.baseUrl=f.string()},3(f,X){X.results.push(f.message(b3))}},b3={default(){return{type:"none"}},1(f){return{type:"ok",response:f.message(S3)}},2(f){return{type:"error",error:f.message(F)}}},S3={default(){return{type:"none"}},1(f){return{type:"close"}},2(f){return f.message(v3)},3(f){return f.message(u3)},4(f){return{type:"sequence"}},5(f){return f.message(g3)},6(f){return{type:"store_sql"}},7(f){return{type:"close_sql"}},8(f){return f.message(i3)}},v3={default(){return{type:"execute",result:s.default()}},1(f,X){X.result=f.message(s)}},u3={default(){return{type:"batch",result:Uf.default()}},1(f,X){X.result=f.message(Uf)}},g3={default(){return{type:"describe",result:yf.default()}},1(f,X){X.result=f.message(yf)}},i3={default(){return{type:"get_autocommit",isAutocommit:!1}},1(f,X){X.isAutocommit=f.bool()}},G0={default(){return{baton:void 0,baseUrl:void 0}},1(f,X){X.baton=f.string()},2(f,X){X.baseUrl=f.string()}};class j2 extends Sf{#f;#X;#$;#A;#R;#J;constructor(f,X){super();this.#f=f,this.#X=X,this.#$=void 0,this.#A=new w2(16384),this.#R=void 0,this.#J=!1}async open(f){if(f.body===null)throw new z("No response body for cursor request");this.#$=f.body.getReader();let X=await this.#Y(N0,G0);if(X===void 0)throw new z("Empty response to cursor request");return X}next(){return this.#Y(A2,R2)}close(){this._setClosed(new O("Cursor was manually closed"))}_setClosed(f){if(this.#R!==void 0)return;if(this.#R=f,this.#f._cursorClosed(this),this.#$!==void 0)this.#$.cancel()}get closed(){return this.#R!==void 0}async#Y(f,X){for(;;){if(this.#J)return;else if(this.#R!==void 0)throw new x("Cursor is closed",this.#R);if(this.#X==="json"){let J=this.#Z();if(J!==void 0){let R=new TextDecoder().decode(J),Z=JSON.parse(R);return $f(Z,f)}}else if(this.#X==="protobuf"){let J=this.#_();if(J!==void 0)return m(J,X)}else throw G(this.#X,"Impossible encoding");if(this.#$===void 0)throw new y("Attempted to read from HTTP cursor before it was opened");let{value:$,done:A}=await this.#$.read();if(A&&this.#A.length===0)this.#J=!0;else if(A)throw new z("Unexpected end of cursor stream");else this.#A.push($)}}#Z(){let f=this.#A.data(),X=10,$=f.indexOf(10);if($<0)return;let A=f.slice(0,$);return this.#A.shift($+1),A}#_(){let f=this.#A.data(),X=0,$=0;for(;;){if($>=f.byteLength)return;let J=f[$];if(X|=(J&127)<<7*$,$+=1,!(J&128))break}if(f.byteLength<$+X)return;let A=f.slice($,$+X);return this.#A.shift($+X),A}}function O0(f,X){if(X.baton!==void 0)f.string("baton",X.baton);f.arrayObjects("requests",X.requests,d3)}function d3(f,X){if(f.stringRaw("type",X.type),X.type==="close");else if(X.type==="execute")f.object("stmt",X.stmt,uf);else if(X.type==="batch")f.object("batch",X.batch,If);else if(X.type==="sequence"){if(X.sql!==void 0)f.string("sql",X.sql);if(X.sqlId!==void 0)f.number("sql_id",X.sqlId)}else if(X.type==="describe"){if(X.sql!==void 0)f.string("sql",X.sql);if(X.sqlId!==void 0)f.number("sql_id",X.sqlId)}else if(X.type==="store_sql")f.number("sql_id",X.sqlId),f.string("sql",X.sql);else if(X.type==="close_sql")f.number("sql_id",X.sqlId);else if(X.type==="get_autocommit");else throw G(X,"Impossible type of StreamRequest")}function D0(f,X){if(X.baton!==void 0)f.string("baton",X.baton);f.object("batch",X.batch,If)}function W0(f,X){if(X.baton!==void 0)f.string(1,X.baton);for(let $ of X.requests)f.message(2,$,n3)}function n3(f,X){if(X.type==="close")f.message(1,X,m3);else if(X.type==="execute")f.message(2,X,c3);else if(X.type==="batch")f.message(3,X,t3);else if(X.type==="sequence")f.message(4,X,l3);else if(X.type==="describe")f.message(5,X,s3);else if(X.type==="store_sql")f.message(6,X,a3);else if(X.type==="close_sql")f.message(7,X,o3);else if(X.type==="get_autocommit")f.message(8,X,r3);else throw G(X,"Impossible type of StreamRequest")}function m3(f,X){}function c3(f,X){f.message(1,X.stmt,gf)}function t3(f,X){f.message(1,X.batch,Bf)}function l3(f,X){if(X.sql!==void 0)f.string(1,X.sql);if(X.sqlId!==void 0)f.int32(2,X.sqlId)}function s3(f,X){if(X.sql!==void 0)f.string(1,X.sql);if(X.sqlId!==void 0)f.int32(2,X.sqlId)}function a3(f,X){f.int32(1,X.sqlId),f.string(2,X.sql)}function o3(f,X){f.int32(1,X.sqlId)}function r3(f,X){}function x0(f,X){if(X.baton!==void 0)f.string(1,X.baton);f.message(2,X.batch,Bf)}class Y2 extends Qf{#f;#X;#$;#A;#R;#J;#Y;#Z;#_;#z;#K;#D;constructor(f,X,$,A){super(f.intMode);this.#f=f,this.#X=X.toString(),this.#$=$,this.#A=A,this.#R=void 0,this.#J=new t,this.#Y=!1,this.#_=!1,this.#z=!1,this.#K=void 0,this.#D=new c}client(){return this.#f}_sqlOwner(){return this}storeSql(f){let X=this.#D.alloc();return this.#G({type:"store_sql",sqlId:X,sql:f}).then(()=>{return},($)=>this._setClosed($)),new Rf(this,X)}_closeSql(f){if(this.#K!==void 0)return;this.#G({type:"close_sql",sqlId:f}).then(()=>this.#D.free(f),(X)=>this._setClosed(X))}_execute(f){return this.#G({type:"execute",stmt:f}).then((X)=>{return X.result})}_batch(f){return this.#G({type:"batch",batch:f}).then((X)=>{return X.result})}_describe(f){return this.#G({type:"describe",sql:f.sql,sqlId:f.sqlId}).then((X)=>{return X.result})}_sequence(f){return this.#G({type:"sequence",sql:f.sql,sqlId:f.sqlId}).then((X)=>{return})}getAutocommit(){return this.#f._ensureVersion(3,"getAutocommit()"),this.#G({type:"get_autocommit"}).then((f)=>{return f.isAutocommit})}#G(f){return new Promise((X,$)=>{this.#W({type:"pipeline",request:f,responseCallback:X,errorCallback:$})})}_openCursor(f){return new Promise((X,$)=>{this.#W({type:"cursor",batch:f,cursorCallback:X,errorCallback:$})})}_cursorClosed(f){if(f!==this.#Z)throw new y("Cursor was closed, but it was not associated with the stream");this.#Z=void 0,Zf(()=>this.#O())}close(){this._setClosed(new O("Stream was manually closed"))}closeGracefully(){this.#_=!0,Zf(()=>this.#O())}get closed(){return this.#K!==void 0||this.#_}_setClosed(f){if(this.#K!==void 0)return;if(this.#K=f,this.#Z!==void 0)this.#Z._setClosed(f);this.#f._streamClosed(this);for(;;){let X=this.#J.shift();if(X!==void 0)X.errorCallback(f);else break}if((this.#R!==void 0||this.#Y)&&!this.#z)this.#J.push({type:"pipeline",request:{type:"close"},responseCallback:()=>{return},errorCallback:()=>{return}}),this.#z=!0,Zf(()=>this.#O())}#W(f){if(this.#K!==void 0)throw new x("Stream is closed",this.#K);else if(this.#_)throw new x("Stream is closing",void 0);else this.#J.push(f),Zf(()=>this.#O())}#O(){if(this.#Y||this.#Z!==void 0)return;if(this.#_&&this.#J.length===0){this._setClosed(new O("Stream was gracefully closed"));return}let f=this.#f._endpoint;if(f===void 0){this.#f._endpointPromise.then(()=>this.#O(),($)=>this._setClosed($));return}let X=this.#J.shift();if(X===void 0)return;else if(X.type==="pipeline"){let $=[X];for(;;){let A=this.#J.first();if(A!==void 0&&A.type==="pipeline")$.push(A),this.#J.shift();else if(A===void 0&&this.#_&&!this.#z){$.push({type:"pipeline",request:{type:"close"},responseCallback:()=>{return},errorCallback:()=>{return}}),this.#z=!0;break}else break}this.#N(f,$)}else if(X.type==="cursor")this.#Q(f,X);else throw G(X,"Impossible type of QueueEntry")}#N(f,X){this.#x(()=>this.#B(X,f),($)=>f4($,f.encoding),($)=>$.baton,($)=>$.baseUrl,($)=>e3(X,$),($)=>X.forEach((A)=>A.errorCallback($)))}#Q(f,X){let $=new j2(this,f.encoding);this.#Z=$,this.#x(()=>this.#U(X,f),(A)=>$.open(A),(A)=>A.baton,(A)=>A.baseUrl,(A)=>X.cursorCallback($),(A)=>X.errorCallback(A))}#x(f,X,$,A,J,R){let Z;try{let Y=f(),_=this.#A;Z=_(Y)}catch(Y){Z=Promise.reject(Y)}this.#Y=!0,Z.then((Y)=>{if(!Y.ok)return X4(Y).then((_)=>{throw _});return X(Y)}).then((Y)=>{this.#R=$(Y),this.#X=A(Y)??this.#X,J(Y)}).catch((Y)=>{this._setClosed(Y),R(Y)}).finally(()=>{this.#Y=!1,this.#O()})}#B(f,X){return this.#I(new URL(X.pipelinePath,this.#X),{baton:this.#R,requests:f.map(($)=>$.request)},X.encoding,O0,W0)}#U(f,X){if(X.cursorPath===void 0)throw new w(`Cursors are supported only on protocol version 3 and higher, but the HTTP server only supports version ${X.version}.`);return this.#I(new URL(X.cursorPath,this.#X),{baton:this.#R,batch:f.batch},X.encoding,D0,x0)}#I(f,X,$,A,J){let R,Z;if($==="json")R=kf(X,A),Z="application/json";else if($==="protobuf")R=pf(X,J),Z="application/x-protobuf";else throw G($,"Impossible encoding");let Y=new F2;if(Y.set("content-type",Z),this.#$!==void 0)Y.set("authorization",`Bearer ${this.#$}`);return new nf(f.toString(),{method:"POST",headers:Y,body:R})}}function e3(f,X){if(X.results.length!==f.length)throw new z("Server returned unexpected number of pipeline results");for(let $=0;$<f.length;++$){let A=X.results[$],J=f[$];if(A.type==="ok"){if(A.response.type!==J.request.type)throw new z("Received unexpected type of response");J.responseCallback(A.response)}else if(A.type==="error")J.errorCallback(v(A.error));else if(A.type==="none")throw new z("Received unrecognized type of StreamResult");else throw G(A,"Received impossible type of StreamResult")}}async function f4(f,X){if(X==="json"){let $=await f.json();return $f($,z0)}if(X==="protobuf"){let $=await f.arrayBuffer();return m(new Uint8Array($),K0)}throw await f.body?.cancel(),G(X,"Impossible encoding")}async function X4(f){let X=f.headers.get("content-type")??"text/plain",$=`Server returned HTTP status ${f.status}`;if(X==="application/json"){let A=await f.json();if("message"in A)return v(A);return new Xf($,f.status)}if(X==="text/plain"){let A=(await f.text()).trim();if(A!=="")$+=`: ${A}`;return new Xf($,f.status)}return await f.body?.cancel(),new Xf($,f.status)}var $4=[{versionPath:"v3-protobuf",pipelinePath:"v3-protobuf/pipeline",cursorPath:"v3-protobuf/cursor",version:3,encoding:"protobuf"}],h2={versionPath:"v2",pipelinePath:"v2/pipeline",cursorPath:void 0,version:2,encoding:"json"};class _2 extends Gf{#f;#X;#$;#A;#R;_endpointPromise;_endpoint;constructor(f,X,$,A=2){super();if(this.#f=f,this.#X=X,this.#$=$??M2,this.#A=void 0,this.#R=new Set,A==3)this._endpointPromise=A4(this.#$,this.#f),this._endpointPromise.then((J)=>this._endpoint=J,(J)=>this.#J(J));else this._endpointPromise=Promise.resolve(h2),this._endpointPromise.then((J)=>this._endpoint=J,(J)=>this.#J(J))}async getVersion(){if(this._endpoint!==void 0)return this._endpoint.version;return(await this._endpointPromise).version}_ensureVersion(f,X){if(f<=h2.version)return;else if(this._endpoint===void 0)throw new w(`${X} is supported only on protocol version ${f} and higher, but the version supported by the HTTP server is not yet known. Use Client.getVersion() to wait until the version is available.`);else if(this._endpoint.version<f)throw new w(`${X} is supported only on protocol version ${f} and higher, but the HTTP server only supports version ${this._endpoint.version}.`)}openStream(){if(this.#A!==void 0)throw new x("Client is closed",this.#A);let f=new Y2(this,this.#f,this.#X,this.#$);return this.#R.add(f),f}_streamClosed(f){this.#R.delete(f)}close(){this.#J(new O("Client was manually closed"))}get closed(){return this.#A!==void 0}#J(f){if(this.#A!==void 0)return;this.#A=f;for(let X of Array.from(this.#R))X._setClosed(new x("Client was closed",f))}}async function A4(f,X){let $=f;for(let A of $4){let J=new URL(A.versionPath,X),R=new nf(J.toString(),{method:"GET"}),Z=await $(R);if(await Z.arrayBuffer(),Z.ok)return A}return h2}function E2(f,X,$=2){if(typeof jf.default>"u")throw new Ef("WebSockets are not supported in this environment");var A=void 0;if($==3)A=Array.from(T2.keys());else A=Array.from(_0.keys());let J=new jf.default(f,A);return new Z2(J,X)}function Q0(f,X,$,A=2){return new _2(f instanceof URL?f:new URL(f),X,$,A)}class mf{#f;#X;#$;constructor(f,X){this.#f=f,this.#X=X,this.#$=void 0}execute(f){return this.batch([f]).then((X)=>X[0])}async batch(f){let X=this._getStream();if(X.closed)throw new K("Cannot execute statements because the transaction is closed","TRANSACTION_CLOSED");try{let $=f.map(u),A;if(this.#$===void 0){this._getSqlCache().apply($);let R=X.batch(this.#X>=3),Z=R.step(),Y=Z.run(g(this.#f)),_=Z;A=$.map((N)=>{let V=R.step().condition(D.ok(_));if(this.#X>=3)V.condition(D.not(D.isAutocommit(R)));let C=V.query(N);return C.catch(()=>{return}),_=V,C}),this.#$=R.execute().then(()=>Y).then(()=>{return});try{await this.#$}catch(N){throw this.close(),N}}else{if(this.#X<3)await this.#$;this._getSqlCache().apply($);let R=X.batch(this.#X>=3),Z=void 0;A=$.map((Y)=>{let _=R.step();if(Z!==void 0)_.condition(D.ok(Z));if(this.#X>=3)_.condition(D.not(D.isAutocommit(R)));let N=_.query(Y);return N.catch(()=>{return}),Z=_,N}),await R.execute()}let J=[];for(let R of A){let Z=await R;if(Z===void 0)throw new K("Statement in a transaction was not executed, probably because the transaction has been rolled back","TRANSACTION_CLOSED");J.push(Hf(Z))}return J}catch($){throw W($)}}async executeMultiple(f){let X=this._getStream();if(X.closed)throw new K("Cannot execute statements because the transaction is closed","TRANSACTION_CLOSED");try{if(this.#$===void 0){this.#$=X.run(g(this.#f)).then(()=>{return});try{await this.#$}catch($){throw this.close(),$}}else await this.#$;await X.sequence(f)}catch($){throw W($)}}async rollback(){try{let f=this._getStream();if(f.closed)return;if(this.#$!==void 0);else return;let X=f.run("ROLLBACK").catch(($)=>{throw W($)});f.closeGracefully(),await X}catch(f){throw W(f)}finally{this.close()}}async commit(){try{let f=this._getStream();if(f.closed)throw new K("Cannot commit the transaction because it is already closed","TRANSACTION_CLOSED");if(this.#$!==void 0)await this.#$;else return;let X=f.run("COMMIT").catch(($)=>{throw W($)});f.closeGracefully(),await X}catch(f){throw W(f)}finally{this.close()}}}async function Vf(f,X,$,A,J=!1){if(J)$.step().run("PRAGMA foreign_keys=off");let R=$.step(),Z=R.run(g(f)),Y=R,_=A.map((a)=>{let B=$.step().condition(D.ok(Y));if(X>=3)B.condition(D.not(D.isAutocommit($)));let M=B.query(a);return Y=B,M}),N=$.step().condition(D.ok(Y));if(X>=3)N.condition(D.not(D.isAutocommit($)));let V=N.run("COMMIT");if($.step().condition(D.not(D.ok(N))).run("ROLLBACK").catch((a)=>{return}),J)$.step().run("PRAGMA foreign_keys=on");await $.execute();let h=[];await Z;for(let a of _){let B=await a;if(B===void 0)throw new K("Statement in a batch was not executed, probably because the transaction has been rolled back","TRANSACTION_CLOSED");h.push(Hf(B))}return await V,h}function u(f){if(typeof f==="string")return new xf(f);let X=new xf(f.sql);if(Array.isArray(f.args))X.bindIndexes(f.args);else for(let[$,A]of Object.entries(f.args))X.bindName($,A);return X}function Hf(f){let X=f.columnNames.map((Z)=>Z??""),$=f.columnDecltypes.map((Z)=>Z??""),A=f.rows,J=f.affectedRowCount,R=f.lastInsertRowid!==void 0?f.lastInsertRowid:void 0;return new Nf(X,$,A,J,R)}function W(f){if(f instanceof O){let X=I0(f);return new K(f.message,X,void 0,f)}return f}function I0(f){if(f instanceof hf&&f.code!==void 0)return f.code;else if(f instanceof z)return"HRANA_PROTO_ERROR";else if(f instanceof x)return f.cause instanceof O?I0(f.cause):"HRANA_CLOSED_ERROR";else if(f instanceof Of)return"HRANA_WEBSOCKET_ERROR";else if(f instanceof Xf)return"SERVER_ERROR";else if(f instanceof w)return"PROTOCOL_VERSION_ERROR";else if(f instanceof y)return"INTERNAL_ERROR";else return"UNKNOWN"}class Lf{#f;#X;capacity;constructor(f,X){this.#f=f,this.#X=new B0,this.capacity=X}apply(f){if(this.capacity<=0)return;let X=new Set;for(let $ of f){if(typeof $.sql!=="string")continue;let A=$.sql;if(A.length>=5000)continue;let J=this.#X.get(A);if(J===void 0){while(this.#X.size+1>this.capacity){let[R,Z]=this.#X.peekLru();if(X.has(Z))break;Z.close(),this.#X.delete(R)}if(this.#X.size+1<=this.capacity)J=this.#f.storeSql(A),this.#X.set(A,J)}if(J!==void 0)$.sql=J,X.add(J)}}}class B0{#f;constructor(){this.#f=new Map}get(f){let X=this.#f.get(f);if(X!==void 0)this.#f.delete(f),this.#f.set(f,X);return X}set(f,X){this.#f.set(f,X)}peekLru(){for(let f of this.#f.entries())return f;return}delete(f){this.#f.delete(f)}get size(){return this.#f.size}}var V0=I2(k2(),1);function H0(f){if(f.scheme!=="wss"&&f.scheme!=="ws")throw new K(`The WebSocket client supports only "libsql:", "wss:" and "ws:" URLs, got ${JSON.stringify(f.scheme+":")}. For more information, please read ${E}`,"URL_SCHEME_NOT_SUPPORTED");if(f.encryptionKey!==void 0)throw new K("Encryption key is not supported by the remote client.","ENCRYPTION_KEY_NOT_SUPPORTED");if(f.scheme==="ws"&&f.tls)throw new K('A "ws:" URL cannot opt into TLS by using ?tls=1',"URL_INVALID");else if(f.scheme==="wss"&&!f.tls)throw new K('A "wss:" URL cannot opt out of TLS by using ?tls=0',"URL_INVALID");let X=Ff(f.scheme,f.authority,f.path),$;try{$=E2(X,f.authToken)}catch(A){if(A instanceof Ef){let J=f.scheme==="wss"?"https":"http",R=Ff(J,f.authority,f.path);throw new K(`This environment does not support WebSockets, please switch to the HTTP client by using a "${J}:" URL (${JSON.stringify(R)}). For more information, please read ${E}`,"WEBSOCKETS_NOT_SUPPORTED")}throw W(A)}return new L0($,X,f.authToken,f.intMode,f.concurrency)}var Z4=60000,Y4=100;class L0{#f;#X;#$;#A;#R;closed;protocol;#J;#Y;constructor(f,X,$,A,J){this.#f=X,this.#X=$,this.#$=A,this.#A=this.#_(f),this.#R=void 0,this.closed=!1,this.protocol="ws",this.#Y=V0.default(J)}async limit(f){return this.#Y(f)}async execute(f,X){let $;if(typeof f==="string")$={sql:f,args:X||[]};else $=f;return this.limit(async()=>{let A=await this.#Z();try{let J=u($);A.conn.sqlCache.apply([J]);let R=A.stream.query(J);A.stream.closeGracefully();let Z=await R;return Hf(Z)}catch(J){throw W(J)}finally{this._closeStream(A)}})}async batch(f,X="deferred"){return this.limit(async()=>{let $=await this.#Z();try{let A=f.map(u),J=await $.conn.client.getVersion();$.conn.sqlCache.apply(A);let R=$.stream.batch(J>=3);return await Vf(X,J,R,A)}catch(A){throw W(A)}finally{this._closeStream($)}})}async migrate(f){return this.limit(async()=>{let X=await this.#Z();try{let $=f.map(u),A=await X.conn.client.getVersion(),J=X.stream.batch(A>=3);return await Vf("deferred",A,J,$,!0)}catch($){throw W($)}finally{this._closeStream(X)}})}async transaction(f="write"){return this.limit(async()=>{let X=await this.#Z();try{let $=await X.conn.client.getVersion();return new T0(this,X,f,$)}catch($){throw this._closeStream(X),W($)}})}async executeMultiple(f){return this.limit(async()=>{let X=await this.#Z();try{let $=X.stream.sequence(f);X.stream.closeGracefully(),await $}catch($){throw W($)}finally{this._closeStream(X)}})}sync(){throw new K("sync not supported in ws mode","SYNC_NOT_SUPPORTED")}async#Z(){if(this.closed)throw new K("The client is closed","CLIENT_CLOSED");if(new Date().valueOf()-this.#A.openTime.valueOf()>Z4&&this.#R===void 0){let A=this.#_();this.#R=A,A.client.getVersion().then((J)=>{if(this.#A!==A){if(this.#A.streamStates.size===0)this.#A.client.close()}this.#A=A,this.#R=void 0},(J)=>{this.#R=void 0})}if(this.#A.client.closed)try{if(this.#R!==void 0)this.#A=this.#R;else this.#A=this.#_()}catch(A){throw W(A)}let $=this.#A;try{if($.useSqlCache===void 0){if($.useSqlCache=await $.client.getVersion()>=2,$.useSqlCache)$.sqlCache.capacity=Y4}let A=$.client.openStream();A.intMode=this.#$;let J={conn:$,stream:A};return $.streamStates.add(J),J}catch(A){throw W(A)}}#_(f){try{return f??=E2(this.#f,this.#X),{client:f,useSqlCache:void 0,sqlCache:new Lf(f,0),openTime:new Date,streamStates:new Set}}catch(X){throw W(X)}}_closeStream(f){f.stream.close();let X=f.conn;if(X.streamStates.delete(f),X.streamStates.size===0&&X!==this.#A)X.client.close()}close(){this.#A.client.close(),this.closed=!0}}class T0 extends mf{#f;#X;constructor(f,X,$,A){super($,A);this.#f=f,this.#X=X}_getStream(){return this.#X.stream}_getSqlCache(){return this.#X.conn.sqlCache}close(){this.#f._closeStream(this.#X)}get closed(){return this.#X.stream.closed}}var F0=I2(k2(),1);function M0(f){if(f.scheme!=="https"&&f.scheme!=="http")throw new K(`The HTTP client supports only "libsql:", "https:" and "http:" URLs, got ${JSON.stringify(f.scheme+":")}. For more information, please read ${E}`,"URL_SCHEME_NOT_SUPPORTED");if(f.encryptionKey!==void 0)throw new K("Encryption key is not supported by the remote client.","ENCRYPTION_KEY_NOT_SUPPORTED");if(f.scheme==="http"&&f.tls)throw new K('A "http:" URL cannot opt into TLS by using ?tls=1',"URL_INVALID");else if(f.scheme==="https"&&!f.tls)throw new K('A "https:" URL cannot opt out of TLS by using ?tls=0',"URL_INVALID");let X=Ff(f.scheme,f.authority,f.path);return new j0(X,f.authToken,f.intMode,f.fetch,f.concurrency)}var w0=30;class j0{#f;protocol;#X;#$;constructor(f,X,$,A,J){this.#f=Q0(f,X,A),this.#f.intMode=$,this.protocol="http",this.#X=X,this.#$=F0.default(J)}async limit(f){return this.#$(f)}async execute(f,X){let $;if(typeof f==="string")$={sql:f,args:X||[]};else $=f;return this.limit(async()=>{try{let A=u($),J,R=this.#f.openStream();try{J=R.query(A)}finally{R.closeGracefully()}let Z=await J;return Hf(Z)}catch(A){throw W(A)}})}async batch(f,X="deferred"){return this.limit(async()=>{try{let $=f.map(u),A=await this.#f.getVersion(),J,R=this.#f.openStream();try{new Lf(R,w0).apply($);let _=R.batch(!1);J=Vf(X,A,_,$)}finally{R.closeGracefully()}return await J}catch($){throw W($)}})}async migrate(f){return this.limit(async()=>{try{let X=f.map(u),$=await this.#f.getVersion(),A,J=this.#f.openStream();try{let Z=J.batch(!1);A=Vf("deferred",$,Z,X,!0)}finally{J.closeGracefully()}return await A}catch(X){throw W(X)}})}async transaction(f="write"){return this.limit(async()=>{try{let X=await this.#f.getVersion();return new h0(this.#f.openStream(),f,X)}catch(X){throw W(X)}})}async executeMultiple(f){return this.limit(async()=>{try{let X,$=this.#f.openStream();try{X=$.sequence(f)}finally{$.closeGracefully()}await X}catch(X){throw W(X)}})}sync(){throw new K("sync not supported in http mode","SYNC_NOT_SUPPORTED")}close(){this.#f.close()}get closed(){return this.#f.closed}}class h0 extends mf{#f;#X;constructor(f,X,$){super(X,$);this.#f=f,this.#X=new Lf(f,w0)}_getStream(){return this.#f}_getSqlCache(){return this.#X}close(){this.#f.close()}get closed(){return this.#f.closed}}function E0(f){return _4(wf(f,!0))}function _4(f){if(f.scheme==="wss"||f.scheme==="ws")return H0(f);else if(f.scheme==="https"||f.scheme==="http")return M0(f);else return b1(f)}class z4{client;dbPath;constructor(){let f=q2.join(process.cwd(),".sylphx-flow");if(!z2.existsSync(f))z2.mkdirSync(f,{recursive:!0});this.dbPath=q2.join(f,"memory.db"),this.client=E0({url:`file:${this.dbPath}`}),this.initializeTables()}async initializeTables(){await this.client.execute(`
      CREATE TABLE IF NOT EXISTS memory (
        key TEXT NOT NULL,
        namespace TEXT NOT NULL DEFAULT 'default',
        value TEXT NOT NULL,
        timestamp INTEGER NOT NULL,
        created_at TEXT NOT NULL,
        updated_at TEXT NOT NULL,
        PRIMARY KEY (key, namespace)
      )
    `),await this.client.execute(`
      CREATE INDEX IF NOT EXISTS idx_memory_namespace ON memory(namespace);
    `),await this.client.execute(`
      CREATE INDEX IF NOT EXISTS idx_memory_timestamp ON memory(timestamp);
    `),await this.client.execute(`
      CREATE INDEX IF NOT EXISTS idx_memory_key ON memory(key);
    `)}serializeValue(f){return JSON.stringify(f)}deserializeValue(f){try{return JSON.parse(f)}catch{return f}}async set(f,X,$="default"){let A=new Date,J=A.getTime(),R=A.toISOString(),Z=R,Y=this.serializeValue(X);if(await this.get(f,$))await this.client.execute({sql:`
        UPDATE memory 
        SET value = ?, timestamp = ?, updated_at = ?
        WHERE key = ? AND namespace = ?
      `,args:[Y,J,Z,f,$]});else await this.client.execute({sql:`
        INSERT INTO memory (key, namespace, value, timestamp, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?, ?)
      `,args:[f,$,Y,J,R,Z]})}async get(f,X="default"){let A=await this.client.execute({sql:`
      SELECT key, namespace, value, timestamp, created_at, updated_at
      FROM memory
      WHERE key = ? AND namespace = ?
    `,args:[f,X]});if(A.rows.length===0)return null;let J=A.rows[0];return{key:J.key,namespace:J.namespace,value:this.deserializeValue(J.value),timestamp:J.timestamp,created_at:J.created_at,updated_at:J.updated_at}}async getAll(){return(await this.client.execute(`
      SELECT key, namespace, value, timestamp, created_at, updated_at
      FROM memory
      ORDER BY timestamp DESC
    `)).rows.map(($)=>({key:$.key,namespace:$.namespace,value:this.deserializeValue($.value),timestamp:$.timestamp,created_at:$.created_at,updated_at:$.updated_at}))}async search(f,X){let $=f.replace(/\*/g,"%"),A=`
      SELECT key, namespace, value, timestamp, created_at, updated_at
      FROM memory
      WHERE key LIKE ? OR value LIKE ?
    `,J=[$,$];if(X&&X!=="all")A+=" AND namespace = ?",J.push(X);return A+=" ORDER BY timestamp DESC",(await this.client.execute({sql:A,args:J})).rows.map((Z)=>({key:Z.key,namespace:Z.namespace,value:this.deserializeValue(Z.value),timestamp:Z.timestamp,created_at:Z.created_at,updated_at:Z.updated_at}))}async delete(f,X="default"){return(await this.client.execute({sql:`
      DELETE FROM memory
      WHERE key = ? AND namespace = ?
    `,args:[f,X]})).rowsAffected>0}async clear(f){if(f&&f!=="all")await this.client.execute({sql:"DELETE FROM memory WHERE namespace = ?",args:[f]});else await this.client.execute("DELETE FROM memory")}async getStats(){let X=(await this.client.execute("SELECT COUNT(*) as count FROM memory")).rows[0].count,$=await this.client.execute(`
      SELECT namespace, COUNT(*) as count
      FROM memory
      GROUP BY namespace
      ORDER BY namespace
    `),A=$.rows.map((N)=>N.namespace),J={};$.rows.forEach((N)=>{J[N.namespace]=N.count});let Z=(await this.client.execute(`
      SELECT 
        MIN(created_at) as oldest,
        MAX(created_at) as newest
      FROM memory
    `)).rows[0],Y=Z.oldest,_=Z.newest;return{totalEntries:X,namespaces:A,namespaceCounts:J,oldestEntry:Y,newestEntry:_}}async load(){let f=await this.getAll(),X={};return f.forEach(($)=>{if(!X[$.namespace])X[$.namespace]={};X[$.namespace][$.key]=$.value}),{namespaces:X}}async close(){}getDatabasePath(){return this.dbPath}}
export{z4 as k};
