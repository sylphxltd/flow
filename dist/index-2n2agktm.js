import{A as U6}from"./paths-f40w3ca7.js";import{C as r2}from"./index-vpcd2g3q.js";import{H as Q4}from"./index-4ed5rdsr.js";import{W as C0,X as d1,Y as JZ,Z as L1}from"./index-b8xrx8ea.js";var p8=d1((z1)=>{var bZ=z1&&z1.__createBinding||(Object.create?function(X,$,Z,Y){if(Y===void 0)Y=Z;var G=Object.getOwnPropertyDescriptor($,Z);if(!G||("get"in G?!$.__esModule:G.writable||G.configurable))G={enumerable:!0,get:function(){return $[Z]}};Object.defineProperty(X,Y,G)}:function(X,$,Z,Y){if(Y===void 0)Y=Z;X[Y]=$[Z]}),dZ=z1&&z1.__setModuleDefault||(Object.create?function(X,$){Object.defineProperty(X,"default",{enumerable:!0,value:$})}:function(X,$){X.default=$}),y8=z1&&z1.__importStar||function(X){if(X&&X.__esModule)return X;var $={};if(X!=null){for(var Z in X)if(Z!=="default"&&Object.prototype.hasOwnProperty.call(X,Z))bZ($,X,Z)}return dZ($,X),$};Object.defineProperty(z1,"__esModule",{value:!0});z1.load=z1.currentTarget=void 0;var mZ=y8(L1("path")),uZ=y8(L1("fs"));function cZ(){let X=null;switch(process.platform){case"android":switch(process.arch){case"arm":return"android-arm-eabi";case"arm64":return"android-arm64"}X="Android";break;case"win32":switch(process.arch){case"x64":return"win32-x64-msvc";case"arm64":return"win32-arm64-msvc";case"ia32":return"win32-ia32-msvc"}X="Windows";break;case"darwin":switch(process.arch){case"x64":return"darwin-x64";case"arm64":return"darwin-arm64"}X="macOS";break;case"linux":switch(process.arch){case"x64":case"arm64":return nZ()?`linux-${process.arch}-gnu`:`linux-${process.arch}-musl`;case"arm":return"linux-arm-gnueabihf"}X="Linux";break;case"freebsd":if(process.arch==="x64")return"freebsd-x64";X="FreeBSD";break}if(X)throw Error(`Neon: unsupported ${X} architecture: ${process.arch}`);throw Error(`Neon: unsupported system: ${process.platform}`)}z1.currentTarget=cZ;function nZ(){let X=process.report?.getReport();if(typeof X!=="object"||!X||!("header"in X))return!1;let $=X.header;return typeof $==="object"&&!!$&&"glibcVersionRuntime"in $}function oZ(X){let $=mZ.join(X,"index.node");return uZ.existsSync($)?L1($):null}z1.load=oZ});var d8=d1((J5,b8)=>{var g8=()=>process.platform==="linux",q6=null,iZ=()=>{if(!q6)q6=g8()&&process.report?process.report.getReport():{};return q6};b8.exports={isLinux:g8,getReport:iZ}});var c8=d1((_5,u8)=>{var m8=L1("fs"),sZ=(X)=>m8.readFileSync(X,"utf-8"),tZ=(X)=>new Promise(($,Z)=>{m8.readFile(X,"utf-8",(Y,G)=>{if(Y)Z(Y);else $(G)})});u8.exports={LDD_PATH:"/usr/bin/ldd",readFileSync:sZ,readFile:tZ}});var WX=d1((W5,_X)=>{var o8=L1("child_process"),{isLinux:K2,getReport:i8}=d8(),{LDD_PATH:k0,readFile:s8,readFileSync:t8}=c8(),N1,w1,m1="",r8=()=>{if(!m1)return new Promise((X)=>{o8.exec("getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true",($,Z)=>{m1=$?" ":Z,X(m1)})});return m1},l8=()=>{if(!m1)try{m1=o8.execSync("getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true",{encoding:"utf8"})}catch(X){m1=" "}return m1},C1="glibc",a8=/GLIBC\s(\d+\.\d+)/,$2="musl",rZ=C1.toUpperCase(),lZ=$2.toLowerCase(),aZ=(X)=>X.includes("libc.musl-")||X.includes("ld-musl-"),e8=()=>{let X=i8();if(X.header&&X.header.glibcVersionRuntime)return C1;if(Array.isArray(X.sharedObjects)){if(X.sharedObjects.some(aZ))return $2}return null},XX=(X)=>{let[$,Z]=X.split(/[\r\n]+/);if($&&$.includes(C1))return C1;if(Z&&Z.includes($2))return $2;return null},$X=(X)=>{if(X.includes(lZ))return $2;if(X.includes(rZ))return C1;return null},eZ=async()=>{if(N1!==void 0)return N1;N1=null;try{let X=await s8(k0);N1=$X(X)}catch(X){}return N1},XY=()=>{if(N1!==void 0)return N1;N1=null;try{let X=t8(k0);N1=$X(X)}catch(X){}return N1},ZX=async()=>{let X=null;if(K2()){if(X=await eZ(),!X)X=e8();if(!X){let $=await r8();X=XX($)}}return X},YX=()=>{let X=null;if(K2()){if(X=XY(),!X)X=e8();if(!X){let $=l8();X=XX($)}}return X},$Y=async()=>K2()&&await ZX()!==C1,ZY=()=>K2()&&YX()!==C1,YY=async()=>{if(w1!==void 0)return w1;w1=null;try{let $=(await s8(k0)).match(a8);if($)w1=$[1]}catch(X){}return w1},GY=()=>{if(w1!==void 0)return w1;w1=null;try{let $=t8(k0).match(a8);if($)w1=$[1]}catch(X){}return w1},GX=()=>{let X=i8();if(X.header&&X.header.glibcVersionRuntime)return X.header.glibcVersionRuntime;return null},n8=(X)=>X.trim().split(/\s+/)[1],JX=(X)=>{let[$,Z,Y]=X.split(/[\r\n]+/);if($&&$.includes(C1))return n8($);if(Z&&Y&&Z.includes($2))return n8(Y);return null},JY=async()=>{let X=null;if(K2()){if(X=await YY(),!X)X=GX();if(!X){let $=await r8();X=JX($)}}return X},_Y=()=>{let X=null;if(K2()){if(X=GY(),!X)X=GX();if(!X){let $=l8();X=JX($)}}return X};_X.exports={GLIBC:C1,MUSL:$2,family:ZX,familySync:YX,isNonGlibcLinux:$Y,isNonGlibcLinuxSync:ZY,version:JY,versionSync:_Y}});var zX=d1((H5,HX)=>{var WY={ALLOW:0,DENY:1};HX.exports=WY});var OX=d1((z5,AX)=>{var S6={value:"SqliteError",writable:!0,enumerable:!1,configurable:!0};function Z2(X,$,Z){if(new.target!==Z2)return new Z2(X,$);if(typeof $!=="string")throw TypeError("Expected second argument to be a string");Error.call(this,X),S6.value=""+X,Object.defineProperty(this,"message",S6),Error.captureStackTrace(this,Z2),this.code=$,this.rawCode=Z}Object.setPrototypeOf(Z2,Error);Object.setPrototypeOf(Z2.prototype,Error.prototype);Object.defineProperty(Z2.prototype,"name",S6);AX.exports=Z2});var EX=d1((A5,L0)=>{var __dirname="/Users/kyle/rules/node_modules/libsql",{load:HY,currentTarget:zY}=p8(),{familySync:UX,GLIBC:AY,MUSL:OY}=WX();function UY(){if(process.env.LIBSQL_JS_DEV)return HY(__dirname);let X=zY();if(UX()==AY)switch(X){case"linux-x64-musl":X="linux-x64-gnu";break;case"linux-arm64-musl":X="linux-arm64-gnu";break}if(X==="linux-arm-gnueabihf"&&UX()==OY)X="linux-arm-musleabihf";return L1(`@libsql/${X}`)}var{databaseOpen:DY,databaseOpenWithSync:FY,databaseInTransaction:RY,databaseInterrupt:VY,databaseClose:KY,databaseSyncSync:IY,databaseSyncUntilSync:EY,databaseExecSync:MY,databasePrepareSync:NY,databaseDefaultSafeIntegers:wY,databaseAuthorizer:xY,databaseLoadExtension:PY,databaseMaxWriteReplicationIndex:BY,statementRaw:TY,statementIsReader:QY,statementGet:DX,statementRun:FX,statementInterrupt:jY,statementRowsSync:RX,statementColumns:kY,statementSafeIntegers:LY,rowsNext:CY}=UY(),vY=zX(),VX=OX();function I2(X){if(X.libsqlError)return new VX(X.message,X.code,X.rawCode);return X}class KX{constructor(X,$){let Z=$?.encryptionCipher??"aes256cbc";if($&&$.syncUrl){var Y="";if($.syncAuth)console.warn("Warning: The `syncAuth` option is deprecated, please use `authToken` option instead."),Y=$.syncAuth;else if($.authToken)Y=$.authToken;let J=$?.encryptionKey??"",_=$?.syncPeriod??0,W=$?.readYourWrites??!0,z=$?.offline??!1,H=$?.remoteEncryptionKey??"";this.db=FY(X,$.syncUrl,Y,Z,J,_,W,z,H)}else{let J=$?.authToken??"",_=$?.encryptionKey??"",W=$?.timeout??0,z=$?.remoteEncryptionKey??"";this.db=DY(X,J,Z,_,W,z)}this.memory=X===":memory:",this.readonly=!1,this.name="",this.open=!0;let G=this.db;Object.defineProperties(this,{inTransaction:{get(){return RY(G)}}})}sync(){return IY.call(this.db)}syncUntil(X){return EY.call(this.db,X)}prepare(X){try{let $=NY.call(this.db,X);return new IX($)}catch($){throw I2($)}}transaction(X){if(typeof X!=="function")throw TypeError("Expected first argument to be a function");let $=this,Z=(G)=>{return(...J)=>{$.exec("BEGIN "+G);try{let _=X(...J);return $.exec("COMMIT"),_}catch(_){throw $.exec("ROLLBACK"),_}}},Y={default:{value:Z("")},deferred:{value:Z("DEFERRED")},immediate:{value:Z("IMMEDIATE")},exclusive:{value:Z("EXCLUSIVE")},database:{value:this,enumerable:!0}};return Object.defineProperties(Y.default.value,Y),Object.defineProperties(Y.deferred.value,Y),Object.defineProperties(Y.immediate.value,Y),Object.defineProperties(Y.exclusive.value,Y),Y.default.value}pragma(X,$){if($==null)$={};if(typeof X!=="string")throw TypeError("Expected first argument to be a string");if(typeof $!=="object")throw TypeError("Expected second argument to be an options object");let Z=$.simple,Y=this.prepare(`PRAGMA ${X}`,this,!0);return Z?Y.pluck().get():Y.all()}backup(X,$){throw Error("not implemented")}serialize(X){throw Error("not implemented")}function(X,$,Z){if($==null)$={};if(typeof $==="function")Z=$,$={};if(typeof X!=="string")throw TypeError("Expected first argument to be a string");if(typeof Z!=="function")throw TypeError("Expected last argument to be a function");if(typeof $!=="object")throw TypeError("Expected second argument to be an options object");if(!X)throw TypeError("User-defined function name cannot be an empty string");throw Error("not implemented")}aggregate(X,$){if(typeof X!=="string")throw TypeError("Expected first argument to be a string");if(typeof $!=="object"||$===null)throw TypeError("Expected second argument to be an options object");if(!X)throw TypeError("User-defined function name cannot be an empty string");throw Error("not implemented")}table(X,$){if(typeof X!=="string")throw TypeError("Expected first argument to be a string");if(!X)throw TypeError("Virtual table module name cannot be an empty string");throw Error("not implemented")}authorizer(X){xY.call(this.db,X)}loadExtension(...X){PY.call(this.db,...X)}maxWriteReplicationIndex(){return BY.call(this.db)}exec(X){try{MY.call(this.db,X)}catch($){throw I2($)}}interrupt(){VY.call(this.db)}close(){KY.call(this.db),this.open=!1}defaultSafeIntegers(X){return wY.call(this.db,X??!0),this}unsafeMode(...X){throw Error("not implemented")}}class IX{constructor(X){this.stmt=X,this.pluckMode=!1}raw(X){return TY.call(this.stmt,X??!0),this}pluck(X){return this.pluckMode=X??!0,this}get reader(){return QY.call(this.stmt)}run(...X){try{if(X.length==1&&typeof X[0]==="object")return FX.call(this.stmt,X[0]);else return FX.call(this.stmt,X.flat())}catch($){throw I2($)}}get(...X){try{if(X.length==1&&typeof X[0]==="object")return DX.call(this.stmt,X[0]);else return DX.call(this.stmt,X.flat())}catch($){throw I2($)}}iterate(...X){var $=void 0;if(X.length==1&&typeof X[0]==="object")$=RX.call(this.stmt,X[0]);else $=RX.call(this.stmt,X.flat());return{nextRows:Array(100),nextRowIndex:100,next(){try{if(this.nextRowIndex===100)CY.call($,this.nextRows),this.nextRowIndex=0;let Y=this.nextRows[this.nextRowIndex];if(this.nextRows[this.nextRowIndex]=void 0,!Y)return{done:!0};return this.nextRowIndex++,{value:Y,done:!1}}catch(Y){throw I2(Y)}},[Symbol.iterator](){return this}}}all(...X){try{let $=[];for(let Z of this.iterate(...X))if(this.pluckMode)$.push(Z[Object.keys(Z)[0]]);else $.push(Z);return $}catch($){throw I2($)}}interrupt(){jY.call(this.stmt)}columns(){return kY.call(this.stmt)}safeIntegers(X){return LY.call(this.stmt,X??!0),this}}L0.exports=KX;L0.exports.Authorization=vY;L0.exports.SqliteError=VX});var l6=d1((RW,J$)=>{function e7(X){var $=0,Z=[];function Y(){if($--,$<X)G()}function G(){var z=Z.shift();if(W.queue=Z.length,z)_(z.fn).then(z.resolve).catch(z.reject)}function J(z){return new Promise(function(H,D){Z.push({fn:z,resolve:H,reject:D}),W.queue=Z.length})}function _(z){$++;try{return Promise.resolve(z()).then(function(H){return Y(),H},function(H){throw Y(),H})}catch(H){return Y(),Promise.reject(H)}}var W=function(z){if($>=X)return J(z);else return _(z)};return W}function XG(X,$){var Z=!1,Y=this;return Promise.all(X.map(function(){var G=arguments;return Y(function(){if(!Z)return $.apply(void 0,G).catch(function(J){throw Z=!0,J})})}))}function G$(X){return X.queue=0,X.map=XG,X}J$.exports=function(X){if(X)return G$(e7(X));else return G$(function($){return $()})}});import z6 from"node:fs";import A6 from"node:path";class J6{config;cachedIndex=null;indexingPromise=null;status={isIndexing:!1,progress:0,totalItems:0,indexedItems:0,startTime:0};constructor(X){this.config=X}getStatus(){return{...this.status}}isReady(){return this.cachedIndex!==null&&!this.status.isIndexing}startBackgroundIndexing(){if(this.status.isIndexing||this.cachedIndex)return;console.error(`[INFO] Starting background ${this.config.name} indexing...`),this.loadIndex().catch((X)=>{console.error(`[ERROR] Background ${this.config.name} indexing failed:`,X)})}async loadIndex(){if(this.cachedIndex)return this.cachedIndex;if(this.indexingPromise)return this.indexingPromise;return this.status.isIndexing=!0,this.status.progress=0,this.status.startTime=Date.now(),this.status.error=void 0,this.indexingPromise=this.buildIndex().then((X)=>{return this.cachedIndex=X,this.status.isIndexing=!1,this.status.progress=100,this.status.totalItems=X.totalDocuments,this.status.indexedItems=X.totalDocuments,console.error(`[INFO] ${this.config.name} indexing complete: ${X.totalDocuments} documents`),X}).catch((X)=>{throw this.status.isIndexing=!1,this.status.error=X instanceof Error?X.message:String(X),console.error(`[ERROR] ${this.config.name} indexing failed:`,X),X}),this.indexingPromise}clearCache(){this.cachedIndex=null,this.indexingPromise=null,this.status={isIndexing:!1,progress:0,totalItems:0,indexedItems:0,startTime:0}}async getStats(){let X=await this.loadIndex();if(!X)return null;return{totalDocuments:X.totalDocuments,uniqueTerms:X.idf.size,generatedAt:X.metadata.generatedAt,version:X.metadata.version}}}class j1{static step1aRules=[{pattern:/sses$/i,replacement:"ss"},{pattern:/ies$/i,replacement:"i"},{pattern:/ss$/i,replacement:"ss"},{pattern:/s$/i,replacement:""}];static step1bRules=[{pattern:/eed$/i,replacement:"ee"},{pattern:/ed$/i,replacement:""},{pattern:/ing$/i,replacement:""}];static step1cRules=[{pattern:/y$/i,replacement:"i"}];static step2Rules=[{pattern:/ational$/i,replacement:"ate"},{pattern:/tional$/i,replacement:"tion"},{pattern:/enci$/i,replacement:"ence"},{pattern:/anci$/i,replacement:"ance"},{pattern:/izer$/i,replacement:"ize"},{pattern:/abli$/i,replacement:"able"},{pattern:/alli$/i,replacement:"al"},{pattern:/entli$/i,replacement:"ent"},{pattern:/eli$/i,replacement:"e"},{pattern:/ousli$/i,replacement:"ous"},{pattern:/ization$/i,replacement:"ize"},{pattern:/ation$/i,replacement:"ate"},{pattern:/ator$/i,replacement:"ate"},{pattern:/alism$/i,replacement:"al"},{pattern:/iveness$/i,replacement:"ive"},{pattern:/fulness$/i,replacement:"ful"},{pattern:/ousness$/i,replacement:"ous"},{pattern:/aliti$/i,replacement:"al"},{pattern:/iviti$/i,replacement:"ive"},{pattern:/biliti$/i,replacement:"ble"}];static step3Rules=[{pattern:/icate$/i,replacement:"ic"},{pattern:/ative$/i,replacement:""},{pattern:/alize$/i,replacement:"al"},{pattern:/iciti$/i,replacement:"ic"},{pattern:/ical$/i,replacement:"ic"},{pattern:/ful$/i,replacement:""},{pattern:/ness$/i,replacement:""}];static step4Rules=[{pattern:/al$/i,replacement:""},{pattern:/ance$/i,replacement:""},{pattern:/ence$/i,replacement:""},{pattern:/er$/i,replacement:""},{pattern:/ic$/i,replacement:""},{pattern:/able$/i,replacement:""},{pattern:/ible$/i,replacement:""},{pattern:/ant$/i,replacement:""},{pattern:/ement$/i,replacement:""},{pattern:/ment$/i,replacement:""},{pattern:/ent$/i,replacement:""},{pattern:/ion$/i,replacement:""},{pattern:/ou$/i,replacement:""},{pattern:/ism$/i,replacement:""},{pattern:/ate$/i,replacement:""},{pattern:/iti$/i,replacement:""},{pattern:/ous$/i,replacement:""},{pattern:/ive$/i,replacement:""},{pattern:/ize$/i,replacement:""}];static step5Rules=[{pattern:/e$/i,replacement:""},{pattern:/ll$/i,replacement:"l"}];static stem(X){if(X.length<3)return X.toLowerCase();let $=X.toLowerCase();for(let Z of j1.step1aRules)if(Z.pattern.test($)){$=$.replace(Z.pattern,Z.replacement);break}for(let Z of j1.step1bRules)if(Z.pattern.test($)){$=$.replace(Z.pattern,Z.replacement);break}for(let Z of j1.step1cRules)if(Z.pattern.test($)&&$.length>2){$=$.replace(Z.pattern,Z.replacement);break}for(let Z of j1.step2Rules)if(Z.pattern.test($)){$=$.replace(Z.pattern,Z.replacement);break}for(let Z of j1.step3Rules)if(Z.pattern.test($)){$=$.replace(Z.pattern,Z.replacement);break}for(let Z of j1.step4Rules)if(Z.pattern.test($)&&$.length>3){$=$.replace(Z.pattern,Z.replacement);break}for(let Z of j1.step5Rules)if(Z.pattern.test($)&&$.length>2){$=$.replace(Z.pattern,Z.replacement);break}return $}}function _6(X){return X.replace(/```[\s\S]*?```/g," ").replace(/`[^`]+`/g," ").replace(/#{1,6}\s/g,"").replace(/[*_~]/g,"").replace(/\[([^\]]+)\]\([^)]+\)/g,"$1").toLowerCase().split(/[^a-z0-9_-]+/).filter((Y)=>Y.length>1)}function W6(X){let $=_6(X),Z=new Map;for(let Y of $){let G=j1.stem(Y);Z.set(G,(Z.get(G)||0)+1)}return Z}var AZ=new Set(["a","an","and","are","as","at","be","by","for","from","has","he","in","is","it","its","of","on","that","the","to","was","will","with","this","but","they","have","had","what","when","where","who","which","why","how"]);function w4(X){return X.filter(($)=>!AZ.has($.toLowerCase()))}function x4(X){let $=Array.from(X.values()).reduce((Y,G)=>Y+G,0),Z=new Map;for(let[Y,G]of X.entries())Z.set(Y,G/$);return Z}function OZ(X,$){let Z=new Map;for(let G of X){let J=new Set(G.keys());for(let _ of J)Z.set(_,(Z.get(_)||0)+1)}let Y=new Map;for(let[G,J]of Z.entries())Y.set(G,Math.log($/J));return Y}function P4(X,$){let Z=new Map;for(let[Y,G]of X.entries()){let J=$.get(Y)||0;Z.set(Y,G*J)}return Z}function B4(X){let $=0;for(let Z of X.values())$+=Z*Z;return Math.sqrt($)}function T4(X){let $=X.map((G)=>({uri:G.uri,terms:W6(G.content)})),Z=OZ($.map((G)=>G.terms),X.length);return{documents:$.map((G)=>{let J=x4(G.terms),_=P4(J,Z),W=B4(_);return{uri:G.uri,terms:_,rawTerms:G.terms,magnitude:W}}),idf:Z,totalDocuments:X.length,metadata:{generatedAt:new Date().toISOString(),version:"1.0.0"}}}function UZ(X,$){let Z=0;for(let[G,J]of X.entries()){let _=$.terms.get(G)||0;Z+=J*_}let Y=B4(X);if(Y===0||$.magnitude===0)return 0;return Z/(Y*$.magnitude)}function DZ(X,$){let Z=W6(X),Y=x4(Z);return P4(Y,$)}function H6(X,$,Z={}){let{limit:Y=10,minScore:G=0,boostFactors:J={}}=Z,{exactMatch:_=1.5,phraseMatch:W=2}=J,z=DZ(X,$.idf),H=w4(_6(X));return $.documents.map((V)=>{let I=UZ(z,V),M=[];for(let K of H)if(V.rawTerms.has(K))I*=_,M.push(K);if(M.length===H.length&&H.length>1)I*=W;return{uri:V.uri,score:I,matchedTerms:M}}).filter((V)=>V.score>=G).sort((V,I)=>I.score-V.score).slice(0,Y)}class j4 extends J6{embeddingProvider;vectorStorage;constructor(X){super({name:"knowledge",autoStart:!0});this.embeddingProvider=X}scanKnowledgeFiles(X){let $=[],Z=(Y,G)=>{let J=z6.readdirSync(Y,{withFileTypes:!0});for(let _ of J){let W=A6.join(Y,_.name);if(_.isDirectory())Z(W,G);else if(_.isFile()&&_.name.endsWith(".md")){let H=A6.relative(G,W).replace(/\.md$/,"").replace(/\\/g,"/"),D=z6.readFileSync(W,"utf8");$.push({uri:`knowledge://${H}`,content:D})}}};return Z(X,X),$}async buildIndex(){let X=U6();if(!z6.existsSync(X))throw Error(`Knowledge directory not found: ${X}`);let $=this.scanKnowledgeFiles(X);console.error(`[INFO] Found ${$.length} knowledge files`);let Z=T4($);if(this.embeddingProvider&&$.length>0){console.error("[INFO] Building vector index for knowledge...");try{let Y=A6.join(U6(),"..",".sylphx-flow","knowledge-vectors.hnsw");this.vectorStorage=new Q4(Y,this.embeddingProvider.dimensions||1536),await this.vectorStorage.initialize();let G=10;for(let J=0;J<$.length;J+=G){let _=$.slice(J,J+G),W=await this.embeddingProvider.generateEmbeddings(_.map((z)=>z.content));for(let z=0;z<_.length;z++){let H=_[z],D=W[z];await this.vectorStorage.addDocument({id:H.uri,embedding:D,metadata:{type:"knowledge",content:H.content.slice(0,500),category:"knowledge",language:"markdown"}})}console.error(`[INFO] Processed ${Math.min(J+G,$.length)}/${$.length} knowledge files`)}await this.vectorStorage.save(),console.error("[INFO] Vector index built successfully")}catch(Y){console.error("[ERROR] Failed to build vector index:",Y),this.vectorStorage=void 0}}return Z}}var O6=null;function D6(X){if(!O6)O6=new j4(X);return O6}var O=Symbol.for("drizzle:entityKind");function U(X,$){if(!X||typeof X!=="object")return!1;if(X instanceof $)return!0;if(!Object.prototype.hasOwnProperty.call($,O))throw Error(`Class "${$.name??"<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`);let Z=Object.getPrototypeOf(X).constructor;if(Z)while(Z){if(O in Z&&Z[O]===$[O])return!0;Z=Object.getPrototypeOf(Z)}return!1}class j{constructor(X,$){this.table=X,this.config=$,this.name=$.name,this.keyAsName=$.keyAsName,this.notNull=$.notNull,this.default=$.default,this.defaultFn=$.defaultFn,this.onUpdateFn=$.onUpdateFn,this.hasDefault=$.hasDefault,this.primary=$.primaryKey,this.isUnique=$.isUnique,this.uniqueName=$.uniqueName,this.uniqueType=$.uniqueType,this.dataType=$.dataType,this.columnType=$.columnType,this.generated=$.generated,this.generatedIdentity=$.generatedIdentity}static[O]="Column";name;keyAsName;primary;notNull;default;defaultFn;onUpdateFn;hasDefault;isUnique;uniqueName;uniqueType;dataType;columnType;enumValues=void 0;generated=void 0;generatedIdentity=void 0;config;mapFromDriverValue(X){return X}mapToDriverValue(X){return X}shouldDisableInsert(){return this.config.generated!==void 0&&this.config.generated.type!=="byDefault"}}class F6{static[O]="ColumnBuilder";config;constructor(X,$,Z){this.config={name:X,keyAsName:X==="",notNull:!1,default:void 0,hasDefault:!1,primaryKey:!1,isUnique:!1,uniqueName:void 0,uniqueType:void 0,dataType:$,columnType:Z,generated:void 0}}$type(){return this}notNull(){return this.config.notNull=!0,this}default(X){return this.config.default=X,this.config.hasDefault=!0,this}$defaultFn(X){return this.config.defaultFn=X,this.config.hasDefault=!0,this}$default=this.$defaultFn;$onUpdateFn(X){return this.config.onUpdateFn=X,this.config.hasDefault=!0,this}$onUpdate=this.$onUpdateFn;primaryKey(){return this.config.primaryKey=!0,this.config.notNull=!0,this}setName(X){if(this.config.name!=="")return;this.config.name=X}}var $1=Symbol.for("drizzle:Name");function k4(X,...$){return X(...$)}function L4(X,$){return`${X[$1]}_${$.join("_")}_unique`}class f2 extends j{constructor(X,$){if(!$.uniqueName)$.uniqueName=L4(X,[$.name]);super(X,$);this.table=X}static[O]="PgColumn"}class FZ extends f2{static[O]="ExtraConfigColumn";getSQLType(){return this.getSQLType()}indexConfig={order:this.config.order??"asc",nulls:this.config.nulls??"last",opClass:this.config.opClass};defaultConfig={order:"asc",nulls:"last",opClass:void 0};asc(){return this.indexConfig.order="asc",this}desc(){return this.indexConfig.order="desc",this}nullsFirst(){return this.indexConfig.nulls="first",this}nullsLast(){return this.indexConfig.nulls="last",this}op(X){return this.indexConfig.opClass=X,this}}class RZ extends f2{static[O]="PgEnumObjectColumn";enum;enumValues=this.config.enum.enumValues;constructor(X,$){super(X,$);this.enum=$.enum}getSQLType(){return this.enum.enumName}}var C4=Symbol.for("drizzle:isPgEnum");function v4(X){return!!X&&typeof X==="function"&&C4 in X&&X[C4]===!0}class VZ extends f2{static[O]="PgEnumColumn";enum=this.config.enum;enumValues=this.config.enum.enumValues;constructor(X,$){super(X,$);this.enum=$.enum}getSQLType(){return this.enum.enumName}}class g{static[O]="Subquery";constructor(X,$,Z,Y=!1,G=[]){this._={brand:"Subquery",sql:X,selectedFields:$,alias:Z,isWith:Y,usedTables:G}}}class y2 extends g{static[O]="WithSubquery"}var h4="0.44.7";var R6,V6,q4={startActiveSpan(X,$){if(!R6)return $();if(!V6)V6=R6.trace.getTracer("drizzle-orm",h4);return k4((Z,Y)=>Y.startActiveSpan(X,(G)=>{try{return $(G)}catch(J){throw G.setStatus({code:Z.SpanStatusCode.ERROR,message:J instanceof Error?J.message:"Unknown error"}),J}finally{G.end()}}),R6,V6)}};var h=Symbol.for("drizzle:ViewBaseConfig");var N0=Symbol.for("drizzle:Schema"),w0=Symbol.for("drizzle:Columns"),S4=Symbol.for("drizzle:ExtraConfigColumns"),K6=Symbol.for("drizzle:OriginalName"),I6=Symbol.for("drizzle:BaseName"),p2=Symbol.for("drizzle:IsAlias"),f4=Symbol.for("drizzle:ExtraConfigBuilder"),KZ=Symbol.for("drizzle:IsDrizzleTable");class F{static[O]="Table";static Symbol={Name:$1,Schema:N0,OriginalName:K6,Columns:w0,ExtraConfigColumns:S4,BaseName:I6,IsAlias:p2,ExtraConfigBuilder:f4};[$1];[K6];[N0];[w0];[S4];[I6];[p2]=!1;[KZ]=!0;[f4]=void 0;constructor(X,$,Z){this[$1]=this[K6]=X,this[N0]=$,this[I6]=Z}}function f1(X){return X[$1]}function l1(X){return`${X[N0]??"public"}.${X[$1]}`}function E6(X){return X!==null&&X!==void 0&&typeof X.getSQL==="function"}function IZ(X){let $={sql:"",params:[]};for(let Z of X)if($.sql+=Z.sql,$.params.push(...Z.params),Z.typings?.length){if(!$.typings)$.typings=[];$.typings.push(...Z.typings)}return $}class c{static[O]="StringChunk";value;constructor(X){this.value=Array.isArray(X)?X:[X]}getSQL(){return new R([this])}}class R{constructor(X){this.queryChunks=X;for(let $ of X)if(U($,F)){let Z=$[F.Symbol.Schema];this.usedTables.push(Z===void 0?$[F.Symbol.Name]:Z+"."+$[F.Symbol.Name])}}static[O]="SQL";decoder=p4;shouldInlineParams=!1;usedTables=[];append(X){return this.queryChunks.push(...X.queryChunks),this}toQuery(X){return q4.startActiveSpan("drizzle.buildSQL",($)=>{let Z=this.buildQueryFromSourceParams(this.queryChunks,X);return $?.setAttributes({"drizzle.query.text":Z.sql,"drizzle.query.params":JSON.stringify(Z.params)}),Z})}buildQueryFromSourceParams(X,$){let Z=Object.assign({},$,{inlineParams:$.inlineParams||this.shouldInlineParams,paramStartIndex:$.paramStartIndex||{value:0}}),{casing:Y,escapeName:G,escapeParam:J,prepareTyping:_,inlineParams:W,paramStartIndex:z}=Z;return IZ(X.map((H)=>{if(U(H,c))return{sql:H.value.join(""),params:[]};if(U(H,x0))return{sql:G(H.value),params:[]};if(H===void 0)return{sql:"",params:[]};if(Array.isArray(H)){let D=[new c("(")];for(let[V,I]of H.entries())if(D.push(I),V<H.length-1)D.push(new c(", "));return D.push(new c(")")),this.buildQueryFromSourceParams(D,Z)}if(U(H,R))return this.buildQueryFromSourceParams(H.queryChunks,{...Z,inlineParams:W||H.shouldInlineParams});if(U(H,F)){let D=H[F.Symbol.Schema],V=H[F.Symbol.Name];return{sql:D===void 0||H[p2]?G(V):G(D)+"."+G(V),params:[]}}if(U(H,j)){let D=Y.getColumnCasing(H);if($.invokeSource==="indexes")return{sql:G(D),params:[]};let V=H.table[F.Symbol.Schema];return{sql:H.table[p2]||V===void 0?G(H.table[F.Symbol.Name])+"."+G(D):G(V)+"."+G(H.table[F.Symbol.Name])+"."+G(D),params:[]}}if(U(H,_1)){let D=H[h].schema,V=H[h].name;return{sql:D===void 0||H[h].isAlias?G(V):G(D)+"."+G(V),params:[]}}if(U(H,Z1)){if(U(H.value,y1))return{sql:J(z.value++,H),params:[H],typings:["none"]};let D=H.value===null?null:H.encoder.mapToDriverValue(H.value);if(U(D,R))return this.buildQueryFromSourceParams([D],Z);if(W)return{sql:this.mapInlineParam(D,Z),params:[]};let V=["none"];if(_)V=[_(H.encoder)];return{sql:J(z.value++,D),params:[D],typings:V}}if(U(H,y1))return{sql:J(z.value++,H),params:[H],typings:["none"]};if(U(H,R.Aliased)&&H.fieldAlias!==void 0)return{sql:G(H.fieldAlias),params:[]};if(U(H,g)){if(H._.isWith)return{sql:G(H._.alias),params:[]};return this.buildQueryFromSourceParams([new c("("),H._.sql,new c(") "),new x0(H._.alias)],Z)}if(v4(H)){if(H.schema)return{sql:G(H.schema)+"."+G(H.enumName),params:[]};return{sql:G(H.enumName),params:[]}}if(E6(H)){if(H.shouldOmitSQLParens?.())return this.buildQueryFromSourceParams([H.getSQL()],Z);return this.buildQueryFromSourceParams([new c("("),H.getSQL(),new c(")")],Z)}if(W)return{sql:this.mapInlineParam(H,Z),params:[]};return{sql:J(z.value++,H),params:[H],typings:["none"]}}))}mapInlineParam(X,{escapeString:$}){if(X===null)return"null";if(typeof X==="number"||typeof X==="boolean")return X.toString();if(typeof X==="string")return $(X);if(typeof X==="object"){let Z=X.toString();if(Z==="[object Object]")return $(JSON.stringify(X));return $(Z)}throw Error("Unexpected param value: "+X)}getSQL(){return this}as(X){if(X===void 0)return this;return new R.Aliased(this,X)}mapWith(X){return this.decoder=typeof X==="function"?{mapFromDriverValue:X}:X,this}inlineParams(){return this.shouldInlineParams=!0,this}if(X){return X?this:void 0}}class x0{constructor(X){this.value=X}static[O]="Name";brand;getSQL(){return new R([this])}}function y4(X){return typeof X==="object"&&X!==null&&"mapToDriverValue"in X&&typeof X.mapToDriverValue==="function"}var p4={mapFromDriverValue:(X)=>X},g4={mapToDriverValue:(X)=>X},YJ={...p4,...g4};class Z1{constructor(X,$=g4){this.value=X,this.encoder=$}static[O]="Param";brand;getSQL(){return new R([this])}}function A(X,...$){let Z=[];if($.length>0||X.length>0&&X[0]!=="")Z.push(new c(X[0]));for(let[Y,G]of $.entries())Z.push(G,new c(X[Y+1]));return new R(Z)}((X)=>{function $(){return new R([])}X.empty=$;function Z(z){return new R(z)}X.fromList=Z;function Y(z){return new R([new c(z)])}X.raw=Y;function G(z,H){let D=[];for(let[V,I]of z.entries()){if(V>0&&H!==void 0)D.push(H);D.push(I)}return new R(D)}X.join=G;function J(z){return new x0(z)}X.identifier=J;function _(z){return new y1(z)}X.placeholder=_;function W(z,H){return new Z1(z,H)}X.param=W})(A||(A={}));((X)=>{class ${constructor(Z,Y){this.sql=Z,this.fieldAlias=Y}static[O]="SQL.Aliased";isSelectionField=!1;getSQL(){return this.sql}clone(){return new $(this.sql,this.fieldAlias)}}X.Aliased=$})(R||(R={}));class y1{constructor(X){this.name=X}static[O]="Placeholder";getSQL(){return new R([this])}}function g2(X,$){return X.map((Z)=>{if(U(Z,y1)){if(!(Z.name in $))throw Error(`No value for placeholder "${Z.name}" was provided`);return $[Z.name]}if(U(Z,Z1)&&U(Z.value,y1)){if(!(Z.value.name in $))throw Error(`No value for placeholder "${Z.value.name}" was provided`);return Z.encoder.mapToDriverValue($[Z.value.name])}return Z})}var EZ=Symbol.for("drizzle:IsDrizzleView");class _1{static[O]="View";[h];[EZ]=!0;constructor({name:X,schema:$,selectedFields:Z,query:Y}){this[h]={name:X,originalName:X,schema:$,selectedFields:Z,query:Y,isExisting:!Y,isAlias:!1}}getSQL(){return new R([this])}}j.prototype.getSQL=function(){return new R([this])};F.prototype.getSQL=function(){return new R([this])};g.prototype.getSQL=function(){return new R([this])};class O2{constructor(X){this.table=X}static[O]="ColumnAliasProxyHandler";get(X,$){if($==="table")return this.table;return X[$]}}class b2{constructor(X,$){this.alias=X,this.replaceOriginalName=$}static[O]="TableAliasProxyHandler";get(X,$){if($===F.Symbol.IsAlias)return!0;if($===F.Symbol.Name)return this.alias;if(this.replaceOriginalName&&$===F.Symbol.OriginalName)return this.alias;if($===h)return{...X[h],name:this.alias,isAlias:!0};if($===F.Symbol.Columns){let Y=X[F.Symbol.Columns];if(!Y)return Y;let G={};return Object.keys(Y).map((J)=>{G[J]=new Proxy(Y[J],new O2(new Proxy(X,this)))}),G}let Z=X[$];if(U(Z,j))return new Proxy(Z,new O2(new Proxy(X,this)));return Z}}function P0(X,$){return new Proxy(X,new b2($,!1))}function I1(X,$){return new Proxy(X,new O2(new Proxy(X.table,new b2($,!1))))}function M6(X,$){return new R.Aliased(d2(X.sql,$),X.fieldAlias)}function d2(X,$){return A.join(X.queryChunks.map((Z)=>{if(U(Z,j))return I1(Z,$);if(U(Z,R))return d2(Z,$);if(U(Z,R.Aliased))return M6(Z,$);return Z}))}class U2 extends Error{static[O]="DrizzleError";constructor({message:X,cause:$}){super(X);this.name="DrizzleError",this.cause=$}}class k1 extends Error{constructor(X,$,Z){super(`Failed query: ${X}
params: ${$}`);if(this.query=X,this.params=$,this.cause=Z,Error.captureStackTrace(this,k1),Z)this.cause=Z}}class N6 extends U2{static[O]="TransactionRollbackError";constructor(){super({message:"Rollback"})}}class b4{static[O]="ConsoleLogWriter";write(X){console.log(X)}}class w6{static[O]="DefaultLogger";writer;constructor(X){this.writer=X?.writer??new b4}logQuery(X,$){let Z=$.map((G)=>{try{return JSON.stringify(G)}catch{return String(G)}}),Y=Z.length?` -- params: [${Z.join(", ")}]`:"";this.writer.write(`Query: ${X}${Y}`)}}class x6{static[O]="NoopLogger";logQuery(){}}class a{static[O]="QueryPromise";[Symbol.toStringTag]="QueryPromise";catch(X){return this.then(void 0,X)}finally(X){return this.then(($)=>{return X?.(),$},($)=>{throw X?.(),$})}then(X,$){return this.execute().then(X,$)}}function P6(X,$,Z){let Y={},G=X.reduce((J,{path:_,field:W},z)=>{let H;if(U(W,j))H=W;else if(U(W,R))H=W.decoder;else H=W.sql.decoder;let D=J;for(let[V,I]of _.entries())if(V<_.length-1){if(!(I in D))D[I]={};D=D[I]}else{let M=$[z],K=D[I]=M===null?null:H.mapFromDriverValue(M);if(Z&&U(W,j)&&_.length===2){let w=_[0];if(!(w in Y))Y[w]=K===null?f1(W.table):!1;else if(typeof Y[w]==="string"&&Y[w]!==f1(W.table))Y[w]=!1}}return J},{});if(Z&&Object.keys(Y).length>0){for(let[J,_]of Object.entries(Y))if(typeof _==="string"&&!Z[_])G[J]=null}return G}function W1(X,$){return Object.entries(X).reduce((Z,[Y,G])=>{if(typeof Y!=="string")return Z;let J=$?[...$,Y]:[Y];if(U(G,j)||U(G,R)||U(G,R.Aliased))Z.push({path:J,field:G});else if(U(G,F))Z.push(...W1(G[F.Symbol.Columns],J));else Z.push(...W1(G,J));return Z},[])}function m2(X,$){let Z=Object.keys(X),Y=Object.keys($);if(Z.length!==Y.length)return!1;for(let[G,J]of Z.entries())if(J!==Y[G])return!1;return!0}function B0(X,$){let Z=Object.entries($).filter(([,Y])=>Y!==void 0).map(([Y,G])=>{if(U(G,R)||U(G,j))return[Y,G];else return[Y,new Z1(G,X[F.Symbol.Columns][Y])]});if(Z.length===0)throw Error("No values to set");return Object.fromEntries(Z)}function d4(X,$){for(let Z of $)for(let Y of Object.getOwnPropertyNames(Z.prototype)){if(Y==="constructor")continue;Object.defineProperty(X.prototype,Y,Object.getOwnPropertyDescriptor(Z.prototype,Y)||Object.create(null))}}function m4(X){return X[F.Symbol.Columns]}function u2(X){return U(X,g)?X._.alias:U(X,_1)?X[h].name:U(X,R)?void 0:X[F.Symbol.IsAlias]?X[F.Symbol.Name]:X[F.Symbol.BaseName]}function E1(X,$){return{name:typeof X==="string"&&X.length>0?X:"",config:typeof X==="object"?X:$}}function u4(X){if(typeof X!=="object"||X===null)return!1;if(X.constructor.name!=="Object")return!1;if("logger"in X){let $=typeof X.logger;if($!=="boolean"&&($!=="object"||typeof X.logger.logQuery!=="function")&&$!=="undefined")return!1;return!0}if("schema"in X){let $=typeof X.schema;if($!=="object"&&$!=="undefined")return!1;return!0}if("casing"in X){let $=typeof X.casing;if($!=="string"&&$!=="undefined")return!1;return!0}if("mode"in X){if(X.mode!=="default"||X.mode!=="planetscale"||X.mode!==void 0)return!1;return!0}if("connection"in X){let $=typeof X.connection;if($!=="string"&&$!=="object"&&$!=="undefined")return!1;return!0}if("client"in X){let $=typeof X.client;if($!=="object"&&$!=="function"&&$!=="undefined")return!1;return!0}if(Object.keys(X).length===0)return!0;return!1}var B6=typeof TextDecoder>"u"?null:new TextDecoder;var c4=Symbol.for("drizzle:PgInlineForeignKeys"),n4=Symbol.for("drizzle:EnableRLS");class T6 extends F{static[O]="PgTable";static Symbol=Object.assign({},F.Symbol,{InlineForeignKeys:c4,EnableRLS:n4});[c4]=[];[n4]=!1;[F.Symbol.ExtraConfigBuilder]=void 0;[F.Symbol.ExtraConfigColumns]={}}class Q6{static[O]="PgPrimaryKeyBuilder";columns;name;constructor(X,$){this.columns=X,this.name=$}build(X){return new o4(X,this.columns,this.name)}}class o4{constructor(X,$,Z){this.table=X,this.columns=$,this.name=Z}static[O]="PgPrimaryKey";columns;name;getName(){return this.name??`${this.table[T6.Symbol.Name]}_${this.columns.map((X)=>X.name).join("_")}_pk`}}function e(X,$){if(y4($)&&!E6(X)&&!U(X,Z1)&&!U(X,y1)&&!U(X,j)&&!U(X,F)&&!U(X,_1))return new Z1(X,$);return X}var T=(X,$)=>{return A`${X} = ${e($,X)}`},i4=(X,$)=>{return A`${X} <> ${e($,X)}`};function H1(...X){let $=X.filter((Z)=>Z!==void 0);if($.length===0)return;if($.length===1)return new R($);return new R([new c("("),A.join($,new c(" and ")),new c(")")])}function c2(...X){let $=X.filter((Z)=>Z!==void 0);if($.length===0)return;if($.length===1)return new R($);return new R([new c("("),A.join($,new c(" or ")),new c(")")])}function s4(X){return A`not ${X}`}var t4=(X,$)=>{return A`${X} > ${e($,X)}`},r4=(X,$)=>{return A`${X} >= ${e($,X)}`},l4=(X,$)=>{return A`${X} < ${e($,X)}`},a4=(X,$)=>{return A`${X} <= ${e($,X)}`};function e4(X,$){if(Array.isArray($)){if($.length===0)return A`false`;return A`${X} in ${$.map((Z)=>e(Z,X))}`}return A`${X} in ${e($,X)}`}function X8(X,$){if(Array.isArray($)){if($.length===0)return A`true`;return A`${X} not in ${$.map((Z)=>e(Z,X))}`}return A`${X} not in ${e($,X)}`}function $8(X){return A`${X} is null`}function Z8(X){return A`${X} is not null`}function Y8(X){return A`exists ${X}`}function G8(X){return A`not exists ${X}`}function J8(X,$,Z){return A`${X} between ${e($,X)} and ${e(Z,X)}`}function _8(X,$,Z){return A`${X} not between ${e($,X)} and ${e(Z,X)}`}function a1(X,$){return A`${X} like ${$}`}function W8(X,$){return A`${X} not like ${$}`}function H8(X,$){return A`${X} ilike ${$}`}function z8(X,$){return A`${X} not ilike ${$}`}function A8(X){return A`${X} asc`}function e1(X){return A`${X} desc`}class j6{constructor(X,$,Z){this.sourceTable=X,this.referencedTable=$,this.relationName=Z,this.referencedTableName=$[F.Symbol.Name]}static[O]="Relation";referencedTableName;fieldName}class O8{constructor(X,$){this.table=X,this.config=$}static[O]="Relations"}class p1 extends j6{constructor(X,$,Z,Y){super(X,$,Z?.relationName);this.config=Z,this.isNullable=Y}static[O]="One";withFieldName(X){let $=new p1(this.sourceTable,this.referencedTable,this.config,this.isNullable);return $.fieldName=X,$}}class n2 extends j6{constructor(X,$,Z){super(X,$,Z?.relationName);this.config=Z}static[O]="Many";withFieldName(X){let $=new n2(this.sourceTable,this.referencedTable,this.config);return $.fieldName=X,$}}function U8(){return{and:H1,between:J8,eq:T,exists:Y8,gt:t4,gte:r4,ilike:H8,inArray:e4,isNull:$8,isNotNull:Z8,like:a1,lt:l4,lte:a4,ne:i4,not:s4,notBetween:_8,notExists:G8,notLike:W8,notIlike:z8,notInArray:X8,or:c2,sql:A}}function D8(){return{sql:A,asc:A8,desc:e1}}function F8(X,$){if(Object.keys(X).length===1&&"default"in X&&!U(X.default,F))X=X.default;let Z={},Y={},G={};for(let[J,_]of Object.entries(X))if(U(_,F)){let W=l1(_),z=Y[W];Z[W]=J,G[J]={tsName:J,dbName:_[F.Symbol.Name],schema:_[F.Symbol.Schema],columns:_[F.Symbol.Columns],relations:z?.relations??{},primaryKey:z?.primaryKey??[]};for(let D of Object.values(_[F.Symbol.Columns]))if(D.primary)G[J].primaryKey.push(D);let H=_[F.Symbol.ExtraConfigBuilder]?.(_[F.Symbol.ExtraConfigColumns]);if(H){for(let D of Object.values(H))if(U(D,Q6))G[J].primaryKey.push(...D.columns)}}else if(U(_,O8)){let W=l1(_.table),z=Z[W],H=_.config($(_.table)),D;for(let[V,I]of Object.entries(H))if(z){let M=G[z];if(M.relations[V]=I,D)M.primaryKey.push(...D)}else{if(!(W in Y))Y[W]={relations:{},primaryKey:D};Y[W].relations[V]=I}}return{tables:G,tableNamesMap:Z}}function MZ(X){return function(Z,Y){return new p1(X,Z,Y,Y?.fields.reduce((G,J)=>G&&J.notNull,!0)??!1)}}function NZ(X){return function(Z,Y){return new n2(X,Z,Y)}}function R8(X,$,Z){if(U(Z,p1)&&Z.config)return{fields:Z.config.fields,references:Z.config.references};let Y=$[l1(Z.referencedTable)];if(!Y)throw Error(`Table "${Z.referencedTable[F.Symbol.Name]}" not found in schema`);let G=X[Y];if(!G)throw Error(`Table "${Y}" not found in schema`);let J=Z.sourceTable,_=$[l1(J)];if(!_)throw Error(`Table "${J[F.Symbol.Name]}" not found in schema`);let W=[];for(let z of Object.values(G.relations))if(Z.relationName&&Z!==z&&z.relationName===Z.relationName||!Z.relationName&&z.referencedTable===Z.sourceTable)W.push(z);if(W.length>1)throw Z.relationName?Error(`There are multiple relations with name "${Z.relationName}" in table "${Y}"`):Error(`There are multiple relations between "${Y}" and "${Z.sourceTable[F.Symbol.Name]}". Please specify relation name`);if(W[0]&&U(W[0],p1)&&W[0].config)return{fields:W[0].config.references,references:W[0].config.fields};throw Error(`There is not enough information to infer relation "${_}.${Z.fieldName}"`)}function V8(X){return{one:MZ(X),many:NZ(X)}}function T0(X,$,Z,Y,G=(J)=>J){let J={};for(let[_,W]of Y.entries())if(W.isJson){let z=$.relations[W.tsKey],H=Z[_],D=typeof H==="string"?JSON.parse(H):H;J[W.tsKey]=U(z,p1)?D&&T0(X,X[W.relationTableTsKey],D,W.selection,G):D.map((V)=>T0(X,X[W.relationTableTsKey],V,W.selection,G))}else{let z=G(Z[_]),H=W.field,D;if(U(H,j))D=H;else if(U(H,R))D=H.decoder;else D=H.sql.decoder;J[W.tsKey]=z===null?null:D.mapFromDriverValue(z)}return J}function g1(X){return A`count(${X||A.raw("*")})`.mapWith(Number)}import*as R4 from"node:path";class s extends Error{operation;cause;context;constructor(X,$,Z,Y){super(X);this.operation=$;this.cause=Z;this.context=Y;if(this.name="DatabaseError",Error.captureStackTrace)Error.captureStackTrace(this,s)}toJSON(){return{name:this.name,message:this.message,operation:this.operation,context:this.context,cause:this.cause?.message,stack:this.stack}}}class wZ extends s{field;value;constructor(X,$,Z,Y){super(X,"validation",Y,{field:$,value:Z});this.field=$;this.value=Z;this.name="ValidationError"}}class k6 extends s{connectionDetails;constructor(X,$,Z){super(X,"connection",Z,$);this.connectionDetails=$;this.name="ConnectionError"}}async function v(X,$,Z){try{return await $()}catch(Y){if(Y instanceof s)throw Y;throw new s(`Database operation failed: ${X}`,X,Y,Z)}}import*as Z6 from"node:fs";import*as K0 from"node:path";class N extends Error{code;rawCode;constructor(X,$,Z,Y){if($!==void 0)X=`${$}: ${X}`;super(X,{cause:Y});this.code=$,this.rawCode=Z,this.name="LibsqlError"}}function K8(X){let $=xZ.exec(X);if($===null)throw new N(`The URL '${X}' is not in a valid format`,"URL_INVALID");let Z=$.groups,Y=Z.scheme,G=Z.authority!==void 0?PZ(Z.authority):void 0,J=X2(Z.path),_=Z.query!==void 0?TZ(Z.query):void 0,W=Z.fragment!==void 0?X2(Z.fragment):void 0;return{scheme:Y,authority:G,path:J,query:_,fragment:W}}var xZ=(()=>{return new RegExp("^(?<scheme>[A-Za-z][A-Za-z.+-]*):(//(?<authority>[^/?#]*))?(?<path>[^?#]*)(\\?(?<query>[^#]*))?(#(?<fragment>.*))?$","su")})();function PZ(X){let $=BZ.exec(X);if($===null)throw new N("The authority part of the URL is not in a valid format","URL_INVALID");let Z=$.groups,Y=X2(Z.host_br??Z.host),G=Z.port?parseInt(Z.port,10):void 0,J=Z.username!==void 0?{username:X2(Z.username),password:Z.password!==void 0?X2(Z.password):void 0}:void 0;return{host:Y,port:G,userinfo:J}}var BZ=(()=>{return new RegExp("^((?<username>[^:]*)(:(?<password>.*))?@)?((?<host>[^:\\[\\]]*)|(\\[(?<host_br>[^\\[\\]]*)\\]))(:(?<port>[0-9]*))?$","su")})();function TZ(X){let $=X.split("&"),Z=[];for(let Y of $){if(Y==="")continue;let G,J,_=Y.indexOf("=");if(_<0)G=Y,J="";else G=Y.substring(0,_),J=Y.substring(_+1);Z.push({key:X2(G.replaceAll("+"," ")),value:X2(J.replaceAll("+"," "))})}return{pairs:Z}}function X2(X){try{return decodeURIComponent(X)}catch($){if($ instanceof URIError)throw new N(`URL component has invalid percent encoding: ${$}`,"URL_INVALID",void 0,$);throw $}}function o2(X,$,Z){if($===void 0)throw new N(`URL with scheme ${JSON.stringify(X+":")} requires authority (the "//" part)`,"URL_INVALID");let Y=`${X}:`,G=QZ($.host),J=jZ($.port),W=`//${kZ($.userinfo)}${G}${J}`,z=Z.split("/").map(encodeURIComponent).join("/");if(z!==""&&!z.startsWith("/"))z="/"+z;return new URL(`${Y}${W}${z}`)}function QZ(X){return X.includes(":")?`[${encodeURI(X)}]`:encodeURI(X)}function jZ(X){return X!==void 0?`:${X}`:""}function kZ(X){if(X===void 0)return"";let $=encodeURIComponent(X.username),Z=X.password!==void 0?`:${encodeURIComponent(X.password)}`:"";return`${$}${Z}@`}var F2=typeof Buffer==="function",I8=typeof TextDecoder==="function"?new TextDecoder:void 0,E8=typeof TextEncoder==="function"?new TextEncoder:void 0;var i2=Array.prototype.slice.call("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="),Q0=((X)=>{let $={};return X.forEach((Z,Y)=>$[Z]=Y),$})(i2),LZ=/^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/,t=String.fromCharCode.bind(String),M8=typeof Uint8Array.from==="function"?Uint8Array.from.bind(Uint8Array):(X)=>new Uint8Array(Array.prototype.slice.call(X,0)),x8=(X)=>X.replace(/=/g,"").replace(/[+\/]/g,($)=>$=="+"?"-":"_"),P8=(X)=>X.replace(/[^A-Za-z0-9\+\/]/g,""),B8=(X)=>{let $,Z,Y,G,J="",_=X.length%3;for(let W=0;W<X.length;){if((Z=X.charCodeAt(W++))>255||(Y=X.charCodeAt(W++))>255||(G=X.charCodeAt(W++))>255)throw TypeError("invalid character found");$=Z<<16|Y<<8|G,J+=i2[$>>18&63]+i2[$>>12&63]+i2[$>>6&63]+i2[$&63]}return _?J.slice(0,_-3)+"===".substring(_):J},v6=typeof btoa==="function"?(X)=>btoa(X):F2?(X)=>Buffer.from(X,"binary").toString("base64"):B8,L6=F2?(X)=>Buffer.from(X).toString("base64"):(X)=>{let Z=[];for(let Y=0,G=X.length;Y<G;Y+=4096)Z.push(t.apply(null,X.subarray(Y,Y+4096)));return v6(Z.join(""))},j0=(X,$=!1)=>$?x8(L6(X)):L6(X),CZ=(X)=>{if(X.length<2){var $=X.charCodeAt(0);return $<128?X:$<2048?t(192|$>>>6)+t(128|$&63):t(224|$>>>12&15)+t(128|$>>>6&63)+t(128|$&63)}else{var $=65536+(X.charCodeAt(0)-55296)*1024+(X.charCodeAt(1)-56320);return t(240|$>>>18&7)+t(128|$>>>12&63)+t(128|$>>>6&63)+t(128|$&63)}},vZ=/[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g,T8=(X)=>X.replace(vZ,CZ),N8=F2?(X)=>Buffer.from(X,"utf8").toString("base64"):E8?(X)=>L6(E8.encode(X)):(X)=>v6(T8(X)),D2=(X,$=!1)=>$?x8(N8(X)):N8(X),w8=(X)=>D2(X,!0),hZ=/[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g,qZ=(X)=>{switch(X.length){case 4:var $=(7&X.charCodeAt(0))<<18|(63&X.charCodeAt(1))<<12|(63&X.charCodeAt(2))<<6|63&X.charCodeAt(3),Z=$-65536;return t((Z>>>10)+55296)+t((Z&1023)+56320);case 3:return t((15&X.charCodeAt(0))<<12|(63&X.charCodeAt(1))<<6|63&X.charCodeAt(2));default:return t((31&X.charCodeAt(0))<<6|63&X.charCodeAt(1))}},Q8=(X)=>X.replace(hZ,qZ),j8=(X)=>{if(X=X.replace(/\s+/g,""),!LZ.test(X))throw TypeError("malformed base64.");X+="==".slice(2-(X.length&3));let $,Z,Y,G=[];for(let J=0;J<X.length;)if($=Q0[X.charAt(J++)]<<18|Q0[X.charAt(J++)]<<12|(Z=Q0[X.charAt(J++)])<<6|(Y=Q0[X.charAt(J++)]),Z===64)G.push(t($>>16&255));else if(Y===64)G.push(t($>>16&255,$>>8&255));else G.push(t($>>16&255,$>>8&255,$&255));return G.join("")},h6=typeof atob==="function"?(X)=>atob(P8(X)):F2?(X)=>Buffer.from(X,"base64").toString("binary"):j8,k8=F2?(X)=>M8(Buffer.from(X,"base64")):(X)=>M8(h6(X).split("").map(($)=>$.charCodeAt(0))),L8=(X)=>k8(C8(X)),SZ=F2?(X)=>Buffer.from(X,"base64").toString("utf8"):I8?(X)=>I8.decode(k8(X)):(X)=>Q8(h6(X)),C8=(X)=>P8(X.replace(/[-_]/g,($)=>$=="-"?"+":"/")),C6=(X)=>SZ(C8(X)),fZ=(X)=>{if(typeof X!=="string")return!1;let $=X.replace(/\s+/g,"").replace(/={0,2}$/,"");return!/[^\s0-9a-zA-Z\+/]/.test($)||!/[^\s0-9a-zA-Z\-_]/.test($)},v8=(X)=>{return{value:X,enumerable:!1,writable:!0,configurable:!0}},h8=function(){let X=($,Z)=>Object.defineProperty(String.prototype,$,v8(Z));X("fromBase64",function(){return C6(this)}),X("toBase64",function($){return D2(this,$)}),X("toBase64URI",function(){return D2(this,!0)}),X("toBase64URL",function(){return D2(this,!0)}),X("toUint8Array",function(){return L8(this)})},q8=function(){let X=($,Z)=>Object.defineProperty(Uint8Array.prototype,$,v8(Z));X("toBase64",function($){return j0(this,$)}),X("toBase64URI",function(){return j0(this,!0)}),X("toBase64URL",function(){return j0(this,!0)})},yZ=()=>{h8(),q8()},R2={version:"3.7.8",VERSION:"3.7.8",atob:h6,atobPolyfill:j8,btoa:v6,btoaPolyfill:B8,fromBase64:C6,toBase64:D2,encode:D2,encodeURI:w8,encodeURL:w8,utob:T8,btou:Q8,decode:C6,isValid:fZ,fromUint8Array:j0,toUint8Array:L8,extendString:h8,extendUint8Array:q8,extendBuiltins:yZ};var M1="https://github.com/libsql/libsql-client-ts#supported-urls";function b1(X){if(X==="write")return"BEGIN IMMEDIATE";else if(X==="read")return"BEGIN TRANSACTION READONLY";else if(X==="deferred")return"BEGIN DEFERRED";else throw RangeError('Unknown transaction mode, supported values are "write", "read" and "deferred"')}class V2{columns;columnTypes;rows;rowsAffected;lastInsertRowid;constructor(X,$,Z,Y,G){this.columns=X,this.columnTypes=$,this.rows=Z,this.rowsAffected=Y,this.lastInsertRowid=G}toJSON(){return{columns:this.columns,columnTypes:this.columnTypes,rows:this.rows.map(pZ),rowsAffected:this.rowsAffected,lastInsertRowid:this.lastInsertRowid!==void 0?""+this.lastInsertRowid:null}}}function pZ(X){return Array.prototype.map.call(X,gZ)}function gZ(X){if(typeof X==="bigint")return""+X;else if(X instanceof ArrayBuffer)return R2.fromUint8Array(new Uint8Array(X));else return X}var S8=":memory:";function f8(X){return X.scheme==="file"&&(X.path===":memory:"||X.path.startsWith(":memory:?"))}function s2(X,$){if(typeof X!=="object")throw TypeError(`Expected client configuration as object, got ${typeof X}`);let{url:Z,authToken:Y,tls:G,intMode:J,concurrency:_}=X;_=Math.max(0,_||20),J??="number";let W=[];if(Z===S8)Z="file::memory:";let z=K8(Z),H=z.scheme.toLowerCase(),D=H==="file"&&z.path===S8&&z.authority===void 0,V;if(D)V={cache:{values:["shared","private"],update:(w,P)=>W.push(`${w}=${P}`)}};else V={tls:{values:["0","1"],update:(w,P)=>G=P==="1"},authToken:{update:(w,P)=>Y=P}};for(let{key:w,value:P}of z.query?.pairs??[]){if(!Object.hasOwn(V,w))throw new N(`Unsupported URL query parameter ${JSON.stringify(w)}`,"URL_PARAM_NOT_SUPPORTED");let u=V[w];if(u.values!==void 0&&!u.values.includes(P))throw new N(`Unknown value for the "${w}" query argument: ${JSON.stringify(P)}. Supported values are: [${u.values.map((i)=>'"'+i+'"').join(", ")}]`,"URL_INVALID");if(u.update!==void 0)u?.update(w,P)}let I=W.length===0?"":`?${W.join("&")}`,M=z.path+I,K;if(H==="libsql")if(G===!1){if(z.authority?.port===void 0)throw new N('A "libsql:" URL with ?tls=0 must specify an explicit port',"URL_INVALID");K=$?"http":"ws"}else K=$?"https":"wss";else K=H;if(K==="http"||K==="ws")G??=!1;else G??=!0;if(K!=="http"&&K!=="ws"&&K!=="https"&&K!=="wss"&&K!=="file")throw new N(`The client supports only "libsql:", "wss:", "ws:", "https:", "http:" and "file:" URLs, got ${JSON.stringify(z.scheme+":")}. For more information, please read ${M1}`,"URL_SCHEME_NOT_SUPPORTED");if(J!=="number"&&J!=="bigint"&&J!=="string")throw TypeError(`Invalid value for intMode, expected "number", "bigint" or "string", got ${JSON.stringify(J)}`);if(z.fragment!==void 0)throw new N(`URL fragments are not supported: ${JSON.stringify("#"+z.fragment)}`,"URL_INVALID");if(D)return{scheme:"file",tls:!1,path:M,intMode:J,concurrency:_,syncUrl:X.syncUrl,syncInterval:X.syncInterval,readYourWrites:X.readYourWrites,offline:X.offline,fetch:X.fetch,authToken:void 0,encryptionKey:void 0,authority:void 0};return{scheme:K,tls:G,authority:z.authority,path:M,authToken:Y,intMode:J,concurrency:_,encryptionKey:X.encryptionKey,syncUrl:X.syncUrl,syncInterval:X.syncInterval,readYourWrites:X.readYourWrites,offline:X.offline,fetch:X.fetch}}var t2=C0(EX(),1);import{Buffer as NX}from"node:buffer";function wX(X){if(X.scheme!=="file")throw new N(`URL scheme ${JSON.stringify(X.scheme+":")} is not supported by the local sqlite3 client. For more information, please read ${M1}`,"URL_SCHEME_NOT_SUPPORTED");let $=X.authority;if($!==void 0){let _=$.host.toLowerCase();if(_!==""&&_!=="localhost")throw new N(`Invalid host in file URL: ${JSON.stringify($.host)}. A "file:" URL with an absolute path should start with one slash ("file:/absolute/path.db") or with three slashes ("file:///absolute/path.db"). For more information, please read ${M1}`,"URL_INVALID");if($.port!==void 0)throw new N("File URL cannot have a port","URL_INVALID");if($.userinfo!==void 0)throw new N("File URL cannot have username and password","URL_INVALID")}let Z=f8(X);if(Z&&X.syncUrl)throw new N(`Embedded replica must use file for local db but URI with in-memory mode were provided instead: ${X.path}`,"URL_INVALID");let Y=X.path;if(Z)Y=`${X.scheme}:${X.path}`;let G={authToken:X.authToken,encryptionKey:X.encryptionKey,syncUrl:X.syncUrl,syncPeriod:X.syncInterval,readYourWrites:X.readYourWrites,offline:X.offline},J=new t2.default(Y,G);return n(J,"SELECT 1 AS checkThatTheDatabaseCanBeOpened",X.intMode),new xX(Y,G,J,X.intMode)}class xX{#X;#$;#Z;#Y;closed;protocol;constructor(X,$,Z,Y){this.#X=X,this.#$=$,this.#Z=Z,this.#Y=Y,this.closed=!1,this.protocol="file"}async execute(X,$){let Z;if(typeof X==="string")Z={sql:X,args:$||[]};else Z=X;return this.#G(),n(this.#J(),Z,this.#Y)}async batch(X,$="deferred"){this.#G();let Z=this.#J();try{n(Z,b1($),this.#Y);let Y=X.map((G)=>{if(!Z.inTransaction)throw new N("The transaction has been rolled back","TRANSACTION_CLOSED");let J=Array.isArray(G)?{sql:G[0],args:G[1]||[]}:G;return n(Z,J,this.#Y)});return n(Z,"COMMIT",this.#Y),Y}finally{if(Z.inTransaction)n(Z,"ROLLBACK",this.#Y)}}async migrate(X){this.#G();let $=this.#J();try{n($,"PRAGMA foreign_keys=off",this.#Y),n($,b1("deferred"),this.#Y);let Z=X.map((Y)=>{if(!$.inTransaction)throw new N("The transaction has been rolled back","TRANSACTION_CLOSED");return n($,Y,this.#Y)});return n($,"COMMIT",this.#Y),Z}finally{if($.inTransaction)n($,"ROLLBACK",this.#Y);n($,"PRAGMA foreign_keys=on",this.#Y)}}async transaction(X="write"){let $=this.#J();return n($,b1(X),this.#Y),this.#Z=null,new PX($,this.#Y)}async executeMultiple(X){this.#G();let $=this.#J();try{return BX($,X)}finally{if($.inTransaction)n($,"ROLLBACK",this.#Y)}}async sync(){this.#G();let X=await this.#J().sync();return{frames_synced:X.frames_synced,frame_no:X.frame_no}}async reconnect(){try{if(!this.closed&&this.#Z!==null)this.#Z.close()}finally{this.#Z=new t2.default(this.#X,this.#$),this.closed=!1}}close(){if(this.closed=!0,this.#Z!==null)this.#Z.close(),this.#Z=null}#G(){if(this.closed)throw new N("The client is closed","CLIENT_CLOSED")}#J(){if(this.#Z===null)this.#Z=new t2.default(this.#X,this.#$);return this.#Z}}class PX{#X;#$;constructor(X,$){this.#X=X,this.#$=$}async execute(X,$){let Z;if(typeof X==="string")Z={sql:X,args:$||[]};else Z=X;return this.#Z(),n(this.#X,Z,this.#$)}async batch(X){return X.map(($)=>{this.#Z();let Z=Array.isArray($)?{sql:$[0],args:$[1]||[]}:$;return n(this.#X,Z,this.#$)})}async executeMultiple(X){return this.#Z(),BX(this.#X,X)}async rollback(){if(!this.#X.open)return;this.#Z(),n(this.#X,"ROLLBACK",this.#$)}async commit(){this.#Z(),n(this.#X,"COMMIT",this.#$)}close(){if(this.#X.inTransaction)n(this.#X,"ROLLBACK",this.#$)}get closed(){return!this.#X.inTransaction}#Z(){if(this.closed)throw new N("The transaction is closed","TRANSACTION_CLOSED")}}function n(X,$,Z){let Y,G;if(typeof $==="string")Y=$,G=[];else if(Y=$.sql,Array.isArray($.args))G=$.args.map((J)=>MX(J,Z));else{G={};for(let J in $.args){let _=J[0]==="@"||J[0]==="$"||J[0]===":"?J.substring(1):J;G[_]=MX($.args[J],Z)}}try{let J=X.prepare(Y);J.safeIntegers(!0);let _=!0;try{J.raw(!0)}catch{_=!1}if(_){let W=Array.from(J.columns().map((I)=>I.name)),z=Array.from(J.columns().map((I)=>I.type??"")),H=J.all(G).map((I)=>{return hY(I,W,Z)}),D=0,V=void 0;return new V2(W,z,H,0,void 0)}else{let W=J.run(G),z=W.changes,H=BigInt(W.lastInsertRowid);return new V2([],[],[],z,H)}}catch(J){throw TX(J)}}function hY(X,$,Z){let Y={};Object.defineProperty(Y,"length",{value:X.length});for(let G=0;G<X.length;++G){let J=qY(X[G],Z);Object.defineProperty(Y,G,{value:J});let _=$[G];if(!Object.hasOwn(Y,_))Object.defineProperty(Y,_,{value:J,enumerable:!0,configurable:!0,writable:!0})}return Y}function qY(X,$){if(typeof X==="bigint")if($==="number"){if(X<SY||X>fY)throw RangeError("Received integer which cannot be safely represented as a JavaScript number");return Number(X)}else if($==="bigint")return X;else if($==="string")return""+X;else throw Error("Invalid value for IntMode");else if(X instanceof NX)return X.buffer;return X}var SY=-9007199254740991n,fY=9007199254740991n;function MX(X,$){if(typeof X==="number"){if(!Number.isFinite(X))throw RangeError("Only finite numbers (not Infinity or NaN) can be passed as arguments");return X}else if(typeof X==="bigint"){if(X<yY||X>pY)throw RangeError("bigint is too large to be represented as a 64-bit integer and passed as argument");return X}else if(typeof X==="boolean")switch($){case"bigint":return X?1n:0n;case"string":return X?"1":"0";default:return X?1:0}else if(X instanceof ArrayBuffer)return NX.from(X);else if(X instanceof Date)return X.valueOf();else if(X===void 0)throw TypeError("undefined cannot be passed as argument to the database");else return X}var yY=-9223372036854775808n,pY=9223372036854775807n;function BX(X,$){try{X.exec($)}catch(Z){throw TX(Z)}}function TX(X){if(X instanceof t2.default.SqliteError)return new N(X.message,X.code,X.rawCode,X);return X}class E2{constructor(){this.intMode="number"}intMode}class k extends Error{constructor(X){super(X);this.name="ClientError"}}class E extends k{constructor(X){super(X);this.name="ProtoError"}}class l2 extends k{code;proto;constructor(X,$){super(X);this.name="ResponseError",this.code=$.code,this.proto=$,this.stack=void 0}}class y extends k{constructor(X,$){if($!==void 0){super(`${X}: ${$}`);this.cause=$}else super(X);this.name="ClosedError"}}class a2 extends k{constructor(X){super(X);this.name="WebSocketUnsupportedError"}}class M2 extends k{constructor(X){super(X);this.name="WebSocketError"}}class Y2 extends k{status;constructor(X,$){super(X);this.status=$,this.name="HttpServerError"}}class D1 extends k{constructor(X){super(X);this.name="ProtocolVersionError"}}class l extends k{constructor(X){super(X);this.name="InternalError"}}class x1 extends k{constructor(X){super(X);this.name="MisuseError"}}function X1(X){if(typeof X==="string")return X;throw N2(X,"string")}function Y1(X){if(X===null||X===void 0)return;else if(typeof X==="string")return X;throw N2(X,"string or null")}function v1(X){if(typeof X==="number")return X;throw N2(X,"number")}function u1(X){if(typeof X==="boolean")return X;throw N2(X,"boolean")}function e2(X){if(Array.isArray(X))return X;throw N2(X,"array")}function b(X){if(X!==null&&typeof X==="object"&&!Array.isArray(X))return X;throw N2(X,"object")}function F1(X,$){return e2(X).map((Z)=>$(b(Z)))}function N2(X,$){if(X===void 0)return new E(`Expected ${$}, but the property was missing`);let Z=typeof X;if(X===null)Z="null";else if(Array.isArray(X))Z="array";return new E(`Expected ${$}, received ${Z}`)}function G2(X,$){return $(b(X))}class QX{#X;#$;constructor(X){this.#X=X,this.#$=!1}begin(){this.#X.push("{"),this.#$=!0}end(){this.#X.push("}"),this.#$=!1}#Z(X){if(this.#$)this.#X.push('"'),this.#$=!1;else this.#X.push(',"');this.#X.push(X),this.#X.push('":')}string(X,$){this.#Z(X),this.#X.push(JSON.stringify($))}stringRaw(X,$){this.#Z(X),this.#X.push('"'),this.#X.push($),this.#X.push('"')}number(X,$){this.#Z(X),this.#X.push(""+$)}boolean(X,$){this.#Z(X),this.#X.push($?"true":"false")}object(X,$,Z){this.#Z(X),this.begin(),Z(this,$),this.end()}arrayObjects(X,$,Z){this.#Z(X),this.#X.push("[");for(let Y=0;Y<$.length;++Y){if(Y!==0)this.#X.push(",");this.begin(),Z(this,$[Y]),this.end()}this.#X.push("]")}}function X0(X,$){let Z=[],Y=new QX(Z);return Y.begin(),$(Y,X),Y.end(),Z.join("")}var J2=0,$0=1,Z0=2;var jX=5;class kX{#X;#$;#Z;constructor(X){this.#X=X,this.#$=new DataView(X.buffer,X.byteOffset,X.byteLength),this.#Z=0}varint(){let X=0;for(let $=0;;$+=7){let Z=this.#X[this.#Z++];if(X|=(Z&127)<<$,!(Z&128))break}return X}varintBig(){let X=0n;for(let $=0n;;$+=7n){let Z=this.#X[this.#Z++];if(X|=BigInt(Z&127)<<$,!(Z&128))break}return X}bytes(X){let $=new Uint8Array(this.#X.buffer,this.#X.byteOffset+this.#Z,X);return this.#Z+=X,$}double(){let X=this.#$.getFloat64(this.#Z,!0);return this.#Z+=8,X}skipVarint(){for(;;)if(!(this.#X[this.#Z++]&128))break}skip(X){this.#Z+=X}eof(){return this.#Z>=this.#X.byteLength}}class LX{#X;#$;constructor(X){this.#X=X,this.#$=-1}setup(X){this.#$=X}#Z(X){if(this.#$!==X)throw new E(`Expected wire type ${X}, got ${this.#$}`);this.#$=-1}bytes(){this.#Z(Z0);let X=this.#X.varint();return this.#X.bytes(X)}string(){return new TextDecoder().decode(this.bytes())}message(X){return c1(this.bytes(),X)}int32(){return this.#Z(J2),this.#X.varint()}uint32(){return this.int32()}bool(){return this.int32()!==0}uint64(){return this.#Z(J2),this.#X.varintBig()}sint64(){let X=this.uint64();return X>>1n^-(X&1n)}double(){return this.#Z($0),this.#X.double()}maybeSkip(){if(this.#$<0)return;else if(this.#$===J2)this.#X.skipVarint();else if(this.#$===$0)this.#X.skip(8);else if(this.#$===Z0){let X=this.#X.varint();this.#X.skip(X)}else if(this.#$===jX)this.#X.skip(4);else throw new E(`Unexpected wire type ${this.#$}`);this.#$=-1}}function c1(X,$){let Z=new kX(X),Y=new LX(Z),G=$.default();while(!Z.eof()){let J=Z.varint(),_=J>>3,W=J&7;Y.setup(W);let z=$[_];if(z!==void 0){let H=z(Y,G);if(H!==void 0)G=H}Y.maybeSkip()}return G}class f6{#X;#$;#Z;#Y;constructor(){this.#X=new ArrayBuffer(256),this.#$=new Uint8Array(this.#X),this.#Z=new DataView(this.#X),this.#Y=0}#G(X){if(this.#Y+X<=this.#X.byteLength)return;let $=this.#X.byteLength;while($<this.#Y+X)$*=2;let Z=new ArrayBuffer($),Y=new Uint8Array(Z),G=new DataView(Z);Y.set(new Uint8Array(this.#X,0,this.#Y)),this.#X=Z,this.#$=Y,this.#Z=G}#J(X){this.#G(5),X=0|X;do{let $=X&127;X>>>=7,$|=X?128:0,this.#$[this.#Y++]=$}while(X)}#W(X){this.#G(10),X=X&0xffffffffffffffffn;do{let $=Number(X&0x7fn);X>>=7n,$|=X?128:0,this.#$[this.#Y++]=$}while(X)}#_(X,$){this.#J(X<<3|$)}bytes(X,$){this.#_(X,Z0),this.#J($.byteLength),this.#G($.byteLength),this.#$.set($,this.#Y),this.#Y+=$.byteLength}string(X,$){this.bytes(X,new TextEncoder().encode($))}message(X,$,Z){let Y=new f6;Z(Y,$),this.bytes(X,Y.data())}int32(X,$){this.#_(X,J2),this.#J($)}uint32(X,$){this.int32(X,$)}bool(X,$){this.int32(X,$?1:0)}sint64(X,$){this.#_(X,J2),this.#W($<<1n^$>>63n)}double(X,$){this.#_(X,$0),this.#G(8),this.#Z.setFloat64(this.#Y,$,!0),this.#Y+=8}data(){return new Uint8Array(this.#X,0,this.#Y)}}function Y0(X,$){let Z=new f6;return $(Z,X),Z.data()}class n1{#X;#$;constructor(){this.#X=new Set,this.#$=new Set}alloc(){for(let $ of this.#$){if(this.#$.delete($),this.#X.add($),!this.#X.has(this.#X.size-1))this.#$.add(this.#X.size-1);return $}let X=this.#X.size;return this.#X.add(X),X}free(X){if(!this.#X.delete(X))throw new l("Freeing an id that is not allocated");if(this.#$.delete(this.#X.size),X<this.#X.size)this.#$.add(X)}}function Q(X,$){throw new l($)}function w2(X){if(X===null)return null;else if(typeof X==="string")return X;else if(typeof X==="number"){if(!Number.isFinite(X))throw RangeError("Only finite numbers (not Infinity or NaN) can be passed as arguments");return X}else if(typeof X==="bigint"){if(X<bY||X>dY)throw RangeError("This bigint value is too large to be represented as a 64-bit integer and passed as argument");return X}else if(typeof X==="boolean")return X?1n:0n;else if(X instanceof ArrayBuffer)return new Uint8Array(X);else if(X instanceof Uint8Array)return X;else if(X instanceof Date)return+X.valueOf();else if(typeof X==="object")return""+X.toString();else throw TypeError("Unsupported type of value")}var bY=-9223372036854775808n,dY=9223372036854775807n;function y6(X,$){if(X===null)return null;else if(typeof X==="number")return X;else if(typeof X==="string")return X;else if(typeof X==="bigint")if($==="number"){let Z=Number(X);if(!Number.isSafeInteger(Z))throw RangeError("Received integer which is too large to be safely represented as a JavaScript number");return Z}else if($==="bigint")return X;else if($==="string")return""+X;else throw new x1("Invalid value for IntMode");else if(X instanceof Uint8Array)return X.slice().buffer;else if(X===void 0)throw new E("Received unrecognized type of Value");else throw Q(X,"Impossible type of Value")}function _2(X){return{affectedRowCount:X.affectedRowCount,lastInsertRowid:X.lastInsertRowid,columnNames:X.cols.map(($)=>$.name),columnDecltypes:X.cols.map(($)=>$.decltype)}}function h0(X,$){let Z=_2(X),Y=X.rows.map((G)=>CX(Z.columnNames,G,$));return{...Z,rows:Y}}function q0(X,$){let Z=_2(X),Y;if(X.rows.length>0)Y=CX(Z.columnNames,X.rows[0],$);return{...Z,row:Y}}function S0(X,$){let Z=_2(X),Y;if(X.rows.length>0&&Z.columnNames.length>0)Y=y6(X.rows[0][0],$);return{...Z,value:Y}}function CX(X,$,Z){let Y={};Object.defineProperty(Y,"length",{value:$.length});for(let G=0;G<$.length;++G){let J=y6($[G],Z);Object.defineProperty(Y,G,{value:J});let _=X[G];if(_!==void 0&&!Object.hasOwn(Y,_))Object.defineProperty(Y,_,{value:J,enumerable:!0,configurable:!0,writable:!0})}return Y}function h1(X){return new l2(X.message,X)}class W2{#X;#$;#Z;constructor(X,$){this.#X=X,this.#$=$,this.#Z=void 0}_getSqlId(X){if(this.#X!==X)throw new x1("Attempted to use SQL text opened with other object");else if(this.#Z!==void 0)throw new y("SQL text is closed",this.#Z);return this.#$}close(){this._setClosed(new k("SQL text was manually closed"))}_setClosed(X){if(this.#Z===void 0)this.#Z=X,this.#X._closeSql(this.#$)}get closed(){return this.#Z!==void 0}}function G0(X,$){if($ instanceof W2)return{sqlId:$._getSqlId(X)};else return{sql:""+$}}class o1{#X;#$;constructor(){this.#X=[],this.#$=[]}get length(){return this.#X.length+this.#$.length}push(X){this.#X.push(X)}shift(){if(this.#$.length===0&&this.#X.length>0)this.#$=this.#X.reverse(),this.#X=[];return this.#$.pop()}first(){return this.#$.length!==0?this.#$[this.#$.length-1]:this.#X[0]}}class J0{sql;_args;_namedArgs;constructor(X){this.sql=X,this._args=[],this._namedArgs=new Map}bindIndexes(X){this._args.length=0;for(let $ of X)this._args.push(w2($));return this}bindIndex(X,$){if(X!==(X|0)||X<=0)throw RangeError("Index of a positional argument must be positive integer");while(this._args.length<X)this._args.push(null);return this._args[X-1]=w2($),this}bindName(X,$){return this._namedArgs.set(X,w2($)),this}unbindAll(){return this._args.length=0,this._namedArgs.clear(),this}}function f0(X,$,Z){let Y,G=[],J=[];if($ instanceof J0){Y=$.sql,G=$._args;for(let[z,H]of $._namedArgs.entries())J.push({name:z,value:H})}else if(Array.isArray($))if(Y=$[0],Array.isArray($[1]))G=$[1].map((z)=>w2(z));else J=Object.entries($[1]).map(([z,H])=>{return{name:z,value:w2(H)}});else Y=$;let{sql:_,sqlId:W}=G0(X,Y);return{sql:_,sqlId:W,args:G,namedArgs:J,wantRows:Z}}class y0{_stream;#X;_steps;#$;constructor(X,$){this._stream=X,this.#X=$,this._steps=[],this.#$=!1}step(){return new p6(this)}execute(){if(this.#$)throw new x1("This batch has already been executed");this.#$=!0;let X={steps:this._steps.map(($)=>$.proto)};if(this.#X)return uY(this._stream,this._steps,X);else return mY(this._stream,this._steps,X)}}function mY(X,$,Z){return X._batch(Z).then((Y)=>{for(let G=0;G<$.length;++G){let J=Y.stepResults.get(G),_=Y.stepErrors.get(G);$[G].callback(J,_)}})}async function uY(X,$,Z){let Y=await X._openCursor(Z);try{let G=0,J=void 0,_=[];for(;;){let W=await Y.next();if(W===void 0)break;if(W.type==="step_begin"){if(W.step<G||W.step>=$.length)throw new E("Server produced StepBeginEntry for unexpected step");else if(J!==void 0)throw new E("Server produced StepBeginEntry before terminating previous step");for(let z=G;z<W.step;++z)$[z].callback(void 0,void 0);G=W.step+1,J=W,_=[]}else if(W.type==="step_end"){if(J===void 0)throw new E("Server produced StepEndEntry but no step is active");let z={cols:J.cols,rows:_,affectedRowCount:W.affectedRowCount,lastInsertRowid:W.lastInsertRowid};$[J.step].callback(z,void 0),J=void 0,_=[]}else if(W.type==="step_error"){if(J===void 0){if(W.step>=$.length)throw new E("Server produced StepErrorEntry for unexpected step");for(let z=G;z<W.step;++z)$[z].callback(void 0,void 0)}else{if(W.step!==J.step)throw new E("Server produced StepErrorEntry for unexpected step");J=void 0,_=[]}$[W.step].callback(void 0,W.error),G=W.step+1}else if(W.type==="row"){if(J===void 0)throw new E("Server produced RowEntry but no step is active");_.push(W.row)}else if(W.type==="error")throw h1(W.error);else if(W.type==="none")throw new E("Server produced unrecognized CursorEntry");else throw Q(W,"Impossible CursorEntry")}if(J!==void 0)throw new E("Server closed Cursor before terminating active step");for(let W=G;W<$.length;++W)$[W].callback(void 0,void 0)}finally{Y.close()}}class p6{_batch;#X;_index;constructor(X){this._batch=X,this.#X=[],this._index=void 0}condition(X){return this.#X.push(X._proto),this}query(X){return this.#$(X,!0,h0)}queryRow(X){return this.#$(X,!0,q0)}queryValue(X){return this.#$(X,!0,S0)}run(X){return this.#$(X,!1,_2)}#$(X,$,Z){if(this._index!==void 0)throw new x1("This BatchStep has already been added to the batch");let Y=f0(this._batch._stream._sqlOwner(),X,$),G;if(this.#X.length===0)G=void 0;else if(this.#X.length===1)G=this.#X[0];else G={type:"and",conds:this.#X.slice()};let J={stmt:Y,condition:G};return new Promise((_,W)=>{let z=(H,D)=>{if(H!==void 0&&D!==void 0)W(new E("Server returned both result and error"));else if(D!==void 0)W(h1(D));else if(H!==void 0)_(Z(H,this._batch._stream.intMode));else _(void 0)};this._index=this._batch._steps.length,this._batch._steps.push({proto:J,callback:z})})}}class q{_batch;_proto;constructor(X,$){this._batch=X,this._proto=$}static ok(X){return new q(X._batch,{type:"ok",step:vX(X)})}static error(X){return new q(X._batch,{type:"error",step:vX(X)})}static not(X){return new q(X._batch,{type:"not",cond:X._proto})}static and(X,$){for(let Z of $)hX(X,Z);return new q(X,{type:"and",conds:$.map((Z)=>Z._proto)})}static or(X,$){for(let Z of $)hX(X,Z);return new q(X,{type:"or",conds:$.map((Z)=>Z._proto)})}static isAutocommit(X){return X._stream.client()._ensureVersion(3,"BatchCond.isAutocommit()"),new q(X,{type:"is_autocommit"})}}function vX(X){if(X._index===void 0)throw new x1("Cannot add a condition referencing a step that has not been added to the batch");return X._index}function hX(X,$){if($._batch!==X)throw new x1("Cannot mix BatchCond objects for different Batch objects")}function qX(X){return{paramNames:X.params.map(($)=>$.name),columns:X.cols,isExplain:X.isExplain,isReadonly:X.isReadonly}}class x2{constructor(X){this.intMode=X}query(X){return this.#X(X,!0,h0)}queryRow(X){return this.#X(X,!0,q0)}queryValue(X){return this.#X(X,!0,S0)}run(X){return this.#X(X,!1,_2)}#X(X,$,Z){let Y=f0(this._sqlOwner(),X,$);return this._execute(Y).then((G)=>Z(G,this.intMode))}batch(X=!1){return new y0(this,X)}describe(X){let $=G0(this._sqlOwner(),X);return this._describe($).then(qX)}sequence(X){let $=G0(this._sqlOwner(),X);return this._sequence($)}intMode}class _0{}var cY=1000,nY=10;class g6 extends _0{#X;#$;#Z;#Y;#G;#J;#W;constructor(X,$,Z){super();this.#X=X,this.#$=$,this.#Z=Z,this.#Y=new o1,this.#G=new o1,this.#J=void 0,this.#W=!1}async next(){for(;;){if(this.#J!==void 0)throw new y("Cursor is closed",this.#J);while(!this.#W&&this.#G.length<nY)this.#G.push(this.#_());let X=this.#Y.shift();if(this.#W||X!==void 0)return X;await this.#G.shift().then(($)=>{if($===void 0)return;for(let Z of $.entries)this.#Y.push(Z);this.#W||=$.done})}}#_(){return this.#$._sendCursorRequest(this,{type:"fetch_cursor",cursorId:this.#Z,maxCount:cY}).then((X)=>X,(X)=>{this._setClosed(X);return})}_setClosed(X){if(this.#J!==void 0)return;this.#J=X,this.#$._sendCursorRequest(this,{type:"close_cursor",cursorId:this.#Z}).catch(()=>{return}),this.#$._cursorClosed(this)}close(){this._setClosed(new k("Cursor was manually closed"))}get closed(){return this.#J!==void 0}}class W0 extends x2{#X;#$;#Z;#Y;#G;#J;static open(X){let $=X._streamIdAlloc.alloc(),Z=new W0(X,$),Y=()=>{return},G=(_)=>Z.#z(_),J={type:"open_stream",streamId:$};return X._sendRequest(J,{responseCallback:Y,errorCallback:G}),Z}constructor(X,$){super(X.intMode);this.#X=X,this.#$=$,this.#Z=new o1,this.#Y=void 0,this.#G=!1,this.#J=void 0}client(){return this.#X}_sqlOwner(){return this.#X}_execute(X){return this.#W({type:"execute",streamId:this.#$,stmt:X}).then(($)=>{return $.result})}_batch(X){return this.#W({type:"batch",streamId:this.#$,batch:X}).then(($)=>{return $.result})}_describe(X){return this.#X._ensureVersion(2,"describe()"),this.#W({type:"describe",streamId:this.#$,sql:X.sql,sqlId:X.sqlId}).then(($)=>{return $.result})}_sequence(X){return this.#X._ensureVersion(2,"sequence()"),this.#W({type:"sequence",streamId:this.#$,sql:X.sql,sqlId:X.sqlId}).then(($)=>{return})}getAutocommit(){return this.#X._ensureVersion(3,"getAutocommit()"),this.#W({type:"get_autocommit",streamId:this.#$}).then((X)=>{return X.isAutocommit})}#W(X){return new Promise(($,Z)=>{this.#_({type:"request",request:X,responseCallback:$,errorCallback:Z})})}_openCursor(X){return this.#X._ensureVersion(3,"cursor"),new Promise(($,Z)=>{this.#_({type:"cursor",batch:X,cursorCallback:$,errorCallback:Z})})}_sendCursorRequest(X,$){if(X!==this.#Y)throw new l("Cursor not associated with the stream attempted to execute a request");return new Promise((Z,Y)=>{if(this.#J!==void 0)Y(new y("Stream is closed",this.#J));else this.#X._sendRequest($,{responseCallback:Z,errorCallback:Y})})}_cursorClosed(X){if(X!==this.#Y)throw new l("Cursor was closed, but it was not associated with the stream");this.#Y=void 0,this.#H()}#_(X){if(this.#J!==void 0)X.errorCallback(new y("Stream is closed",this.#J));else if(this.#G)X.errorCallback(new y("Stream is closing",void 0));else this.#Z.push(X),this.#H()}#H(){for(;;){let X=this.#Z.first();if(X===void 0&&this.#Y===void 0&&this.#G){this.#z(new k("Stream was gracefully closed"));break}else if(X?.type==="request"&&this.#Y===void 0){let{request:$,responseCallback:Z,errorCallback:Y}=X;this.#Z.shift(),this.#X._sendRequest($,{responseCallback:Z,errorCallback:Y})}else if(X?.type==="cursor"&&this.#Y===void 0){let{batch:$,cursorCallback:Z}=X;this.#Z.shift();let Y=this.#X._cursorIdAlloc.alloc(),G=new g6(this.#X,this,Y),J={type:"open_cursor",streamId:this.#$,cursorId:Y,batch:$},_=()=>{return},W=(z)=>G._setClosed(z);this.#X._sendRequest(J,{responseCallback:_,errorCallback:W}),this.#Y=G,Z(G)}else break}}#z(X){if(this.#J!==void 0)return;if(this.#J=X,this.#Y!==void 0)this.#Y._setClosed(X);for(;;){let G=this.#Z.shift();if(G!==void 0)G.errorCallback(X);else break}let $={type:"close_stream",streamId:this.#$},Z=()=>this.#X._streamIdAlloc.free(this.#$),Y=()=>{return};this.#X._sendRequest($,{responseCallback:Z,errorCallback:Y})}close(){this.#z(new k("Stream was manually closed"))}closeGracefully(){this.#G=!0,this.#H()}get closed(){return this.#J!==void 0||this.#G}}function H0(X,$){if($.sql!==void 0)X.string("sql",$.sql);if($.sqlId!==void 0)X.number("sql_id",$.sqlId);X.arrayObjects("args",$.args,SX),X.arrayObjects("named_args",$.namedArgs,oY),X.boolean("want_rows",$.wantRows)}function oY(X,$){X.string("name",$.name),X.object("value",$.value,SX)}function P2(X,$){X.arrayObjects("steps",$.steps,iY)}function iY(X,$){if($.condition!==void 0)X.object("condition",$.condition,b6);X.object("stmt",$.stmt,H0)}function b6(X,$){if(X.stringRaw("type",$.type),$.type==="ok"||$.type==="error")X.number("step",$.step);else if($.type==="not")X.object("cond",$.cond,b6);else if($.type==="and"||$.type==="or")X.arrayObjects("conds",$.conds,b6);else if($.type==="is_autocommit");else throw Q($,"Impossible type of BatchCond")}function SX(X,$){if($===null)X.stringRaw("type","null");else if(typeof $==="bigint")X.stringRaw("type","integer"),X.stringRaw("value",""+$);else if(typeof $==="number")X.stringRaw("type","float"),X.number("value",$);else if(typeof $==="string")X.stringRaw("type","text"),X.string("value",$);else if($ instanceof Uint8Array)X.stringRaw("type","blob"),X.stringRaw("base64",R2.fromUint8Array($));else if($===void 0);else throw Q($,"Impossible type of Value")}function fX(X,$){if(X.stringRaw("type",$.type),$.type==="hello"){if($.jwt!==void 0)X.string("jwt",$.jwt)}else if($.type==="request")X.number("request_id",$.requestId),X.object("request",$.request,sY);else throw Q($,"Impossible type of ClientMsg")}function sY(X,$){if(X.stringRaw("type",$.type),$.type==="open_stream")X.number("stream_id",$.streamId);else if($.type==="close_stream")X.number("stream_id",$.streamId);else if($.type==="execute")X.number("stream_id",$.streamId),X.object("stmt",$.stmt,H0);else if($.type==="batch")X.number("stream_id",$.streamId),X.object("batch",$.batch,P2);else if($.type==="open_cursor")X.number("stream_id",$.streamId),X.number("cursor_id",$.cursorId),X.object("batch",$.batch,P2);else if($.type==="close_cursor")X.number("cursor_id",$.cursorId);else if($.type==="fetch_cursor")X.number("cursor_id",$.cursorId),X.number("max_count",$.maxCount);else if($.type==="sequence"){if(X.number("stream_id",$.streamId),$.sql!==void 0)X.string("sql",$.sql);if($.sqlId!==void 0)X.number("sql_id",$.sqlId)}else if($.type==="describe"){if(X.number("stream_id",$.streamId),$.sql!==void 0)X.string("sql",$.sql);if($.sqlId!==void 0)X.number("sql_id",$.sqlId)}else if($.type==="store_sql")X.number("sql_id",$.sqlId),X.string("sql",$.sql);else if($.type==="close_sql")X.number("sql_id",$.sqlId);else if($.type==="get_autocommit")X.number("stream_id",$.streamId);else throw Q($,"Impossible type of Request")}function z0(X,$){if($.sql!==void 0)X.string(1,$.sql);if($.sqlId!==void 0)X.int32(2,$.sqlId);for(let Z of $.args)X.message(3,Z,pX);for(let Z of $.namedArgs)X.message(4,Z,tY);X.bool(5,$.wantRows)}function tY(X,$){X.string(1,$.name),X.message(2,$.value,pX)}function B2(X,$){for(let Z of $.steps)X.message(1,Z,rY)}function rY(X,$){if($.condition!==void 0)X.message(1,$.condition,d6);X.message(2,$.stmt,z0)}function d6(X,$){if($.type==="ok")X.uint32(1,$.step);else if($.type==="error")X.uint32(2,$.step);else if($.type==="not")X.message(3,$.cond,d6);else if($.type==="and")X.message(4,$.conds,yX);else if($.type==="or")X.message(5,$.conds,yX);else if($.type==="is_autocommit")X.message(6,void 0,gX);else throw Q($,"Impossible type of BatchCond")}function yX(X,$){for(let Z of $)X.message(1,Z,d6)}function pX(X,$){if($===null)X.message(1,void 0,gX);else if(typeof $==="bigint")X.sint64(2,$);else if(typeof $==="number")X.double(3,$);else if(typeof $==="string")X.string(4,$);else if($ instanceof Uint8Array)X.bytes(5,$);else if($===void 0);else throw Q($,"Impossible type of Value")}function gX(X,$){}function bX(X,$){if($.type==="hello")X.message(1,$,lY);else if($.type==="request")X.message(2,$,aY);else throw Q($,"Impossible type of ClientMsg")}function lY(X,$){if($.jwt!==void 0)X.string(1,$.jwt)}function aY(X,$){X.int32(1,$.requestId);let Z=$.request;if(Z.type==="open_stream")X.message(2,Z,eY);else if(Z.type==="close_stream")X.message(3,Z,X7);else if(Z.type==="execute")X.message(4,Z,$7);else if(Z.type==="batch")X.message(5,Z,Z7);else if(Z.type==="open_cursor")X.message(6,Z,Y7);else if(Z.type==="close_cursor")X.message(7,Z,G7);else if(Z.type==="fetch_cursor")X.message(8,Z,J7);else if(Z.type==="sequence")X.message(9,Z,_7);else if(Z.type==="describe")X.message(10,Z,W7);else if(Z.type==="store_sql")X.message(11,Z,H7);else if(Z.type==="close_sql")X.message(12,Z,z7);else if(Z.type==="get_autocommit")X.message(13,Z,A7);else throw Q(Z,"Impossible type of Request")}function eY(X,$){X.int32(1,$.streamId)}function X7(X,$){X.int32(1,$.streamId)}function $7(X,$){X.int32(1,$.streamId),X.message(2,$.stmt,z0)}function Z7(X,$){X.int32(1,$.streamId),X.message(2,$.batch,B2)}function Y7(X,$){X.int32(1,$.streamId),X.int32(2,$.cursorId),X.message(3,$.batch,B2)}function G7(X,$){X.int32(1,$.cursorId)}function J7(X,$){X.int32(1,$.cursorId),X.uint32(2,$.maxCount)}function _7(X,$){if(X.int32(1,$.streamId),$.sql!==void 0)X.string(2,$.sql);if($.sqlId!==void 0)X.int32(3,$.sqlId)}function W7(X,$){if(X.int32(1,$.streamId),$.sql!==void 0)X.string(2,$.sql);if($.sqlId!==void 0)X.int32(3,$.sqlId)}function H7(X,$){X.int32(1,$.sqlId),X.string(2,$.sql)}function z7(X,$){X.int32(1,$.sqlId)}function A7(X,$){X.int32(1,$.streamId)}function i1(X){let $=X1(X.message),Z=Y1(X.code);return{message:$,code:Z}}function A0(X){let $=F1(X.cols,dX),Z=e2(X.rows).map((_)=>F1(_,mX)),Y=v1(X.affected_row_count),G=Y1(X.last_insert_rowid),J=G!==void 0?BigInt(G):void 0;return{cols:$,rows:Z,affectedRowCount:Y,lastInsertRowid:J}}function dX(X){let $=Y1(X.name),Z=Y1(X.decltype);return{name:$,decltype:Z}}function p0(X){let $=new Map;e2(X.step_results).forEach((Y,G)=>{if(Y!==null)$.set(G,A0(b(Y)))});let Z=new Map;return e2(X.step_errors).forEach((Y,G)=>{if(Y!==null)Z.set(G,i1(b(Y)))}),{stepResults:$,stepErrors:Z}}function g0(X){let $=X1(X.type);if($==="step_begin"){let Z=v1(X.step),Y=F1(X.cols,dX);return{type:"step_begin",step:Z,cols:Y}}else if($==="step_end"){let Z=v1(X.affected_row_count),Y=Y1(X.last_insert_rowid),G=Y!==void 0?BigInt(Y):void 0;return{type:"step_end",affectedRowCount:Z,lastInsertRowid:G}}else if($==="step_error"){let Z=v1(X.step),Y=i1(b(X.error));return{type:"step_error",step:Z,error:Y}}else if($==="row")return{type:"row",row:F1(X.row,mX)};else if($==="error")return{type:"error",error:i1(b(X.error))};else throw new E("Unexpected type of CursorEntry")}function b0(X){let $=F1(X.params,O7),Z=F1(X.cols,U7),Y=u1(X.is_explain),G=u1(X.is_readonly);return{params:$,cols:Z,isExplain:Y,isReadonly:G}}function O7(X){return{name:Y1(X.name)}}function U7(X){let $=X1(X.name),Z=Y1(X.decltype);return{name:$,decltype:Z}}function mX(X){let $=X1(X.type);if($==="null")return null;else if($==="integer"){let Z=X1(X.value);return BigInt(Z)}else if($==="float")return v1(X.value);else if($==="text")return X1(X.value);else if($==="blob")return R2.toUint8Array(X1(X.base64));else throw new E("Unexpected type of Value")}function uX(X){let $=X1(X.type);if($==="hello_ok")return{type:"hello_ok"};else if($==="hello_error")return{type:"hello_error",error:i1(b(X.error))};else if($==="response_ok"){let Z=v1(X.request_id),Y=D7(b(X.response));return{type:"response_ok",requestId:Z,response:Y}}else if($==="response_error"){let Z=v1(X.request_id),Y=i1(b(X.error));return{type:"response_error",requestId:Z,error:Y}}else throw new E("Unexpected type of ServerMsg")}function D7(X){let $=X1(X.type);if($==="open_stream")return{type:"open_stream"};else if($==="close_stream")return{type:"close_stream"};else if($==="execute")return{type:"execute",result:A0(b(X.result))};else if($==="batch")return{type:"batch",result:p0(b(X.result))};else if($==="open_cursor")return{type:"open_cursor"};else if($==="close_cursor")return{type:"close_cursor"};else if($==="fetch_cursor"){let Z=F1(X.entries,g0),Y=u1(X.done);return{type:"fetch_cursor",entries:Z,done:Y}}else if($==="sequence")return{type:"sequence"};else if($==="describe")return{type:"describe",result:b0(b(X.result))};else if($==="store_sql")return{type:"store_sql"};else if($==="close_sql")return{type:"close_sql"};else if($==="get_autocommit")return{type:"get_autocommit",isAutocommit:u1(X.is_autocommit)};else throw new E("Unexpected type of Response")}var A1={default(){return{message:"",code:void 0}},1(X,$){$.message=X.string()},2(X,$){$.code=X.string()}},s1={default(){return{cols:[],rows:[],affectedRowCount:0,lastInsertRowid:void 0}},1(X,$){$.cols.push(X.message(cX))},2(X,$){$.rows.push(X.message(nX))},3(X,$){$.affectedRowCount=Number(X.uint64())},4(X,$){$.lastInsertRowid=X.sint64()}},cX={default(){return{name:void 0,decltype:void 0}},1(X,$){$.name=X.string()},2(X,$){$.decltype=X.string()}},nX={default(){return[]},1(X,$){$.push(X.message(N7))}},T2={default(){return{stepResults:new Map,stepErrors:new Map}},1(X,$){let[Z,Y]=X.message(F7);$.stepResults.set(Z,Y)},2(X,$){let[Z,Y]=X.message(R7);$.stepErrors.set(Z,Y)}},F7={default(){return[0,s1.default()]},1(X,$){$[0]=X.uint32()},2(X,$){$[1]=X.message(s1)}},R7={default(){return[0,A1.default()]},1(X,$){$[0]=X.uint32()},2(X,$){$[1]=X.message(A1)}},d0={default(){return{type:"none"}},1(X){return X.message(V7)},2(X){return X.message(K7)},3(X){return X.message(I7)},4(X){return{type:"row",row:X.message(nX)}},5(X){return{type:"error",error:X.message(A1)}}},V7={default(){return{type:"step_begin",step:0,cols:[]}},1(X,$){$.step=X.uint32()},2(X,$){$.cols.push(X.message(cX))}},K7={default(){return{type:"step_end",affectedRowCount:0,lastInsertRowid:void 0}},1(X,$){$.affectedRowCount=X.uint32()},2(X,$){$.lastInsertRowid=X.uint64()}},I7={default(){return{type:"step_error",step:0,error:A1.default()}},1(X,$){$.step=X.uint32()},2(X,$){$.error=X.message(A1)}},Q2={default(){return{params:[],cols:[],isExplain:!1,isReadonly:!1}},1(X,$){$.params.push(X.message(E7))},2(X,$){$.cols.push(X.message(M7))},3(X,$){$.isExplain=X.bool()},4(X,$){$.isReadonly=X.bool()}},E7={default(){return{name:void 0}},1(X,$){$.name=X.string()}},M7={default(){return{name:"",decltype:void 0}},1(X,$){$.name=X.string()},2(X,$){$.decltype=X.string()}},N7={default(){return},1(X){return null},2(X){return X.sint64()},3(X){return X.double()},4(X){return X.string()},5(X){return X.bytes()}};var oX={default(){return{type:"none"}},1(X){return{type:"hello_ok"}},2(X){return X.message(w7)},3(X){return X.message(P7)},4(X){return X.message(x7)}},w7={default(){return{type:"hello_error",error:A1.default()}},1(X,$){$.error=X.message(A1)}},x7={default(){return{type:"response_error",requestId:0,error:A1.default()}},1(X,$){$.requestId=X.int32()},2(X,$){$.error=X.message(A1)}},P7={default(){return{type:"response_ok",requestId:0,response:{type:"none"}}},1(X,$){$.requestId=X.int32()},2(X,$){$.response={type:"open_stream"}},3(X,$){$.response={type:"close_stream"}},4(X,$){$.response=X.message(B7)},5(X,$){$.response=X.message(T7)},6(X,$){$.response={type:"open_cursor"}},7(X,$){$.response={type:"close_cursor"}},8(X,$){$.response=X.message(Q7)},9(X,$){$.response={type:"sequence"}},10(X,$){$.response=X.message(j7)},11(X,$){$.response={type:"store_sql"}},12(X,$){$.response={type:"close_sql"}},13(X,$){$.response=X.message(k7)}},B7={default(){return{type:"execute",result:s1.default()}},1(X,$){$.result=X.message(s1)}},T7={default(){return{type:"batch",result:T2.default()}},1(X,$){$.result=X.message(T2)}},Q7={default(){return{type:"fetch_cursor",entries:[],done:!1}},1(X,$){$.entries.push(X.message(d0))},2(X,$){$.done=X.bool()}},j7={default(){return{type:"describe",result:Q2.default()}},1(X,$){$.result=X.message(Q2)}},k7={default(){return{type:"get_autocommit",isAutocommit:!1}},1(X,$){$.isAutocommit=X.bool()}};var iX=new Map([["hrana2",{version:2,encoding:"json"}],["hrana1",{version:1,encoding:"json"}]]),m6=new Map([["hrana3-protobuf",{version:3,encoding:"protobuf"}],["hrana3",{version:3,encoding:"json"}],["hrana2",{version:2,encoding:"json"}],["hrana1",{version:1,encoding:"json"}]]);class m0 extends E2{#X;#$;#Z;#Y;#G;#J;#W;#_;#H;_streamIdAlloc;_cursorIdAlloc;#z;constructor(X,$){super();this.#X=X,this.#$=[],this.#Z=!1,this.#Y=void 0,this.#G=!1,this.#J=void 0,this.#W=!1,this.#_=new Map,this.#H=new n1,this._streamIdAlloc=new n1,this._cursorIdAlloc=new n1,this.#z=new n1,this.#X.binaryType="arraybuffer",this.#X.addEventListener("open",()=>this.#F()),this.#X.addEventListener("close",(Z)=>this.#D(Z)),this.#X.addEventListener("error",(Z)=>this.#R(Z)),this.#X.addEventListener("message",(Z)=>this.#K(Z)),this.#O({type:"hello",jwt:$})}#O(X){if(this.#Y!==void 0)throw new l("Trying to send a message on a closed client");if(this.#Z)this.#U(X);else{let $=()=>this.#U(X),Z=()=>{return};this.#$.push({openCallback:$,errorCallback:Z})}}#F(){let X=this.#X.protocol;if(X===void 0){this.#A(new k("The `WebSocket.protocol` property is undefined. This most likely means that the WebSocket implementation provided by the environment is broken. If you are using Miniflare 2, please update to Miniflare 3, which fixes this problem."));return}else if(X==="")this.#J={version:1,encoding:"json"};else if(this.#J=m6.get(X),this.#J===void 0){this.#A(new E(`Unrecognized WebSocket subprotocol: ${JSON.stringify(X)}`));return}for(let $ of this.#$)$.openCallback();this.#$.length=0,this.#Z=!0}#U(X){let $=this.#J.encoding;if($==="json"){let Z=X0(X,fX);this.#X.send(Z)}else if($==="protobuf"){let Z=Y0(X,bX);this.#X.send(Z)}else throw Q($,"Impossible encoding")}getVersion(){return new Promise((X,$)=>{if(this.#W=!0,this.#Y!==void 0)$(this.#Y);else if(!this.#Z){let Z=()=>X(this.#J.version);this.#$.push({openCallback:Z,errorCallback:$})}else X(this.#J.version)})}_ensureVersion(X,$){if(this.#J===void 0||!this.#W)throw new D1(`${$} is supported only on protocol version ${X} and higher, but the version supported by the WebSocket server is not yet known. Use Client.getVersion() to wait until the version is available.`);else if(this.#J.version<X)throw new D1(`${$} is supported on protocol version ${X} and higher, but the WebSocket server only supports version ${this.#J.version}`)}_sendRequest(X,$){if(this.#Y!==void 0){$.errorCallback(new y("Client is closed",this.#Y));return}let Z=this.#H.alloc();this.#_.set(Z,{...$,type:X.type}),this.#O({type:"request",requestId:Z,request:X})}#R(X){let Z=X.message??"WebSocket was closed due to an error";this.#A(new M2(Z))}#D(X){let $=`WebSocket was closed with code ${X.code}`;if(X.reason)$+=`: ${X.reason}`;this.#A(new M2($))}#A(X){if(this.#Y!==void 0)return;this.#Y=X;for(let $ of this.#$)$.errorCallback(X);this.#$.length=0;for(let[$,Z]of this.#_.entries())Z.errorCallback(X),this.#H.free($);this.#_.clear(),this.#X.close()}#K(X){if(this.#Y!==void 0)return;try{let $,Z=this.#J.encoding;if(Z==="json"){if(typeof X.data!=="string"){this.#X.close(3003,"Only text messages are accepted with JSON encoding"),this.#A(new E("Received non-text message from server with JSON encoding"));return}$=G2(JSON.parse(X.data),uX)}else if(Z==="protobuf"){if(!(X.data instanceof ArrayBuffer)){this.#X.close(3003,"Only binary messages are accepted with Protobuf encoding"),this.#A(new E("Received non-binary message from server with Protobuf encoding"));return}$=c1(new Uint8Array(X.data),oX)}else throw Q(Z,"Impossible encoding");this.#V($)}catch($){this.#X.close(3007,"Could not handle message"),this.#A($)}}#V(X){if(X.type==="none")throw new E("Received an unrecognized ServerMsg");else if(X.type==="hello_ok"||X.type==="hello_error"){if(this.#G)throw new E("Received a duplicated hello response");if(this.#G=!0,X.type==="hello_error")throw h1(X.error);return}else if(!this.#G)throw new E("Received a non-hello message before a hello response");if(X.type==="response_ok"){let $=X.requestId,Z=this.#_.get($);if(this.#_.delete($),Z===void 0)throw new E("Received unexpected OK response");this.#H.free($);try{if(Z.type!==X.response.type)throw console.dir({responseState:Z,msg:X}),new E("Received unexpected type of response");Z.responseCallback(X.response)}catch(Y){throw Z.errorCallback(Y),Y}}else if(X.type==="response_error"){let $=X.requestId,Z=this.#_.get($);if(this.#_.delete($),Z===void 0)throw new E("Received unexpected error response");this.#H.free($),Z.errorCallback(h1(X.error))}else throw Q(X,"Impossible ServerMsg type")}openStream(){return W0.open(this)}storeSql(X){this._ensureVersion(2,"storeSql()");let $=this.#z.alloc(),Z=new W2(this,$),Y=()=>{return},G=(_)=>Z._setClosed(_),J={type:"store_sql",sqlId:$,sql:X};return this._sendRequest(J,{responseCallback:Y,errorCallback:G}),Z}_closeSql(X){if(this.#Y!==void 0)return;let $=()=>this.#z.free(X),Z=(G)=>this.#A(G),Y={type:"close_sql",sqlId:X};this._sendRequest(Y,{responseCallback:$,errorCallback:Z})}close(){this.#A(new k("Client was manually closed"))}get closed(){return this.#Y!==void 0}}var O0=Request,u6=Headers,c6=fetch;var H2;if(typeof queueMicrotask<"u")H2=queueMicrotask;else{let X=Promise.resolve();H2=($)=>{X.then($)}}class n6{#X;#$;#Z;constructor(X){this.#X=new Uint8Array(new ArrayBuffer(X)),this.#$=0,this.#Z=0}get length(){return this.#Z-this.#$}data(){return this.#X.slice(this.#$,this.#Z)}push(X){this.#Y(X.byteLength),this.#X.set(X,this.#Z),this.#Z+=X.byteLength}#Y(X){if(this.#Z+X<=this.#X.byteLength)return;let $=this.#Z-this.#$;if($+X<=this.#X.byteLength&&2*this.#Z>=this.#X.byteLength)this.#X.copyWithin(0,this.#$,this.#Z);else{let Z=this.#X.byteLength;do Z*=2;while($+X>Z);let Y=new Uint8Array(new ArrayBuffer(Z));Y.set(this.#X.slice(this.#$,this.#Z),0),this.#X=Y}this.#Z=$,this.#$=0}shift(X){this.#$+=X}}function sX(X){let $=Y1(X.baton),Z=Y1(X.base_url),Y=F1(X.results,L7);return{baton:$,baseUrl:Z,results:Y}}function L7(X){let $=X1(X.type);if($==="ok")return{type:"ok",response:C7(b(X.response))};else if($==="error")return{type:"error",error:i1(b(X.error))};else throw new E("Unexpected type of StreamResult")}function C7(X){let $=X1(X.type);if($==="close")return{type:"close"};else if($==="execute")return{type:"execute",result:A0(b(X.result))};else if($==="batch")return{type:"batch",result:p0(b(X.result))};else if($==="sequence")return{type:"sequence"};else if($==="describe")return{type:"describe",result:b0(b(X.result))};else if($==="store_sql")return{type:"store_sql"};else if($==="close_sql")return{type:"close_sql"};else if($==="get_autocommit")return{type:"get_autocommit",isAutocommit:u1(X.is_autocommit)};else throw new E("Unexpected type of StreamResponse")}function tX(X){let $=Y1(X.baton),Z=Y1(X.base_url);return{baton:$,baseUrl:Z}}var rX={default(){return{baton:void 0,baseUrl:void 0,results:[]}},1(X,$){$.baton=X.string()},2(X,$){$.baseUrl=X.string()},3(X,$){$.results.push(X.message(v7))}},v7={default(){return{type:"none"}},1(X){return{type:"ok",response:X.message(h7)}},2(X){return{type:"error",error:X.message(A1)}}},h7={default(){return{type:"none"}},1(X){return{type:"close"}},2(X){return X.message(q7)},3(X){return X.message(S7)},4(X){return{type:"sequence"}},5(X){return X.message(f7)},6(X){return{type:"store_sql"}},7(X){return{type:"close_sql"}},8(X){return X.message(y7)}},q7={default(){return{type:"execute",result:s1.default()}},1(X,$){$.result=X.message(s1)}},S7={default(){return{type:"batch",result:T2.default()}},1(X,$){$.result=X.message(T2)}},f7={default(){return{type:"describe",result:Q2.default()}},1(X,$){$.result=X.message(Q2)}},y7={default(){return{type:"get_autocommit",isAutocommit:!1}},1(X,$){$.isAutocommit=X.bool()}},lX={default(){return{baton:void 0,baseUrl:void 0}},1(X,$){$.baton=X.string()},2(X,$){$.baseUrl=X.string()}};class o6 extends _0{#X;#$;#Z;#Y;#G;#J;constructor(X,$){super();this.#X=X,this.#$=$,this.#Z=void 0,this.#Y=new n6(16384),this.#G=void 0,this.#J=!1}async open(X){if(X.body===null)throw new E("No response body for cursor request");this.#Z=X.body.getReader();let $=await this.#W(tX,lX);if($===void 0)throw new E("Empty response to cursor request");return $}next(){return this.#W(g0,d0)}close(){this._setClosed(new k("Cursor was manually closed"))}_setClosed(X){if(this.#G!==void 0)return;if(this.#G=X,this.#X._cursorClosed(this),this.#Z!==void 0)this.#Z.cancel()}get closed(){return this.#G!==void 0}async#W(X,$){for(;;){if(this.#J)return;else if(this.#G!==void 0)throw new y("Cursor is closed",this.#G);if(this.#$==="json"){let G=this.#_();if(G!==void 0){let J=new TextDecoder().decode(G),_=JSON.parse(J);return G2(_,X)}}else if(this.#$==="protobuf"){let G=this.#H();if(G!==void 0)return c1(G,$)}else throw Q(this.#$,"Impossible encoding");if(this.#Z===void 0)throw new l("Attempted to read from HTTP cursor before it was opened");let{value:Z,done:Y}=await this.#Z.read();if(Y&&this.#Y.length===0)this.#J=!0;else if(Y)throw new E("Unexpected end of cursor stream");else this.#Y.push(Z)}}#_(){let X=this.#Y.data(),$=10,Z=X.indexOf(10);if(Z<0)return;let Y=X.slice(0,Z);return this.#Y.shift(Z+1),Y}#H(){let X=this.#Y.data(),$=0,Z=0;for(;;){if(Z>=X.byteLength)return;let G=X[Z];if($|=(G&127)<<7*Z,Z+=1,!(G&128))break}if(X.byteLength<Z+$)return;let Y=X.slice(Z,Z+$);return this.#Y.shift(Z+$),Y}}function aX(X,$){if($.baton!==void 0)X.string("baton",$.baton);X.arrayObjects("requests",$.requests,p7)}function p7(X,$){if(X.stringRaw("type",$.type),$.type==="close");else if($.type==="execute")X.object("stmt",$.stmt,H0);else if($.type==="batch")X.object("batch",$.batch,P2);else if($.type==="sequence"){if($.sql!==void 0)X.string("sql",$.sql);if($.sqlId!==void 0)X.number("sql_id",$.sqlId)}else if($.type==="describe"){if($.sql!==void 0)X.string("sql",$.sql);if($.sqlId!==void 0)X.number("sql_id",$.sqlId)}else if($.type==="store_sql")X.number("sql_id",$.sqlId),X.string("sql",$.sql);else if($.type==="close_sql")X.number("sql_id",$.sqlId);else if($.type==="get_autocommit");else throw Q($,"Impossible type of StreamRequest")}function eX(X,$){if($.baton!==void 0)X.string("baton",$.baton);X.object("batch",$.batch,P2)}function X$(X,$){if($.baton!==void 0)X.string(1,$.baton);for(let Z of $.requests)X.message(2,Z,g7)}function g7(X,$){if($.type==="close")X.message(1,$,b7);else if($.type==="execute")X.message(2,$,d7);else if($.type==="batch")X.message(3,$,m7);else if($.type==="sequence")X.message(4,$,u7);else if($.type==="describe")X.message(5,$,c7);else if($.type==="store_sql")X.message(6,$,n7);else if($.type==="close_sql")X.message(7,$,o7);else if($.type==="get_autocommit")X.message(8,$,i7);else throw Q($,"Impossible type of StreamRequest")}function b7(X,$){}function d7(X,$){X.message(1,$.stmt,z0)}function m7(X,$){X.message(1,$.batch,B2)}function u7(X,$){if($.sql!==void 0)X.string(1,$.sql);if($.sqlId!==void 0)X.int32(2,$.sqlId)}function c7(X,$){if($.sql!==void 0)X.string(1,$.sql);if($.sqlId!==void 0)X.int32(2,$.sqlId)}function n7(X,$){X.int32(1,$.sqlId),X.string(2,$.sql)}function o7(X,$){X.int32(1,$.sqlId)}function i7(X,$){}function $$(X,$){if($.baton!==void 0)X.string(1,$.baton);X.message(2,$.batch,B2)}class u0 extends x2{#X;#$;#Z;#Y;#G;#J;#W;#_;#H;#z;#O;#F;constructor(X,$,Z,Y){super(X.intMode);this.#X=X,this.#$=$.toString(),this.#Z=Z,this.#Y=Y,this.#G=void 0,this.#J=new o1,this.#W=!1,this.#H=!1,this.#z=!1,this.#O=void 0,this.#F=new n1}client(){return this.#X}_sqlOwner(){return this}storeSql(X){let $=this.#F.alloc();return this.#U({type:"store_sql",sqlId:$,sql:X}).then(()=>{return},(Z)=>this._setClosed(Z)),new W2(this,$)}_closeSql(X){if(this.#O!==void 0)return;this.#U({type:"close_sql",sqlId:X}).then(()=>this.#F.free(X),($)=>this._setClosed($))}_execute(X){return this.#U({type:"execute",stmt:X}).then(($)=>{return $.result})}_batch(X){return this.#U({type:"batch",batch:X}).then(($)=>{return $.result})}_describe(X){return this.#U({type:"describe",sql:X.sql,sqlId:X.sqlId}).then(($)=>{return $.result})}_sequence(X){return this.#U({type:"sequence",sql:X.sql,sqlId:X.sqlId}).then(($)=>{return})}getAutocommit(){return this.#X._ensureVersion(3,"getAutocommit()"),this.#U({type:"get_autocommit"}).then((X)=>{return X.isAutocommit})}#U(X){return new Promise(($,Z)=>{this.#R({type:"pipeline",request:X,responseCallback:$,errorCallback:Z})})}_openCursor(X){return new Promise(($,Z)=>{this.#R({type:"cursor",batch:X,cursorCallback:$,errorCallback:Z})})}_cursorClosed(X){if(X!==this.#_)throw new l("Cursor was closed, but it was not associated with the stream");this.#_=void 0,H2(()=>this.#D())}close(){this._setClosed(new k("Stream was manually closed"))}closeGracefully(){this.#H=!0,H2(()=>this.#D())}get closed(){return this.#O!==void 0||this.#H}_setClosed(X){if(this.#O!==void 0)return;if(this.#O=X,this.#_!==void 0)this.#_._setClosed(X);this.#X._streamClosed(this);for(;;){let $=this.#J.shift();if($!==void 0)$.errorCallback(X);else break}if((this.#G!==void 0||this.#W)&&!this.#z)this.#J.push({type:"pipeline",request:{type:"close"},responseCallback:()=>{return},errorCallback:()=>{return}}),this.#z=!0,H2(()=>this.#D())}#R(X){if(this.#O!==void 0)throw new y("Stream is closed",this.#O);else if(this.#H)throw new y("Stream is closing",void 0);else this.#J.push(X),H2(()=>this.#D())}#D(){if(this.#W||this.#_!==void 0)return;if(this.#H&&this.#J.length===0){this._setClosed(new k("Stream was gracefully closed"));return}let X=this.#X._endpoint;if(X===void 0){this.#X._endpointPromise.then(()=>this.#D(),(Z)=>this._setClosed(Z));return}let $=this.#J.shift();if($===void 0)return;else if($.type==="pipeline"){let Z=[$];for(;;){let Y=this.#J.first();if(Y!==void 0&&Y.type==="pipeline")Z.push(Y),this.#J.shift();else if(Y===void 0&&this.#H&&!this.#z){Z.push({type:"pipeline",request:{type:"close"},responseCallback:()=>{return},errorCallback:()=>{return}}),this.#z=!0;break}else break}this.#A(X,Z)}else if($.type==="cursor")this.#K(X,$);else throw Q($,"Impossible type of QueueEntry")}#A(X,$){this.#V(()=>this.#E($,X),(Z)=>t7(Z,X.encoding),(Z)=>Z.baton,(Z)=>Z.baseUrl,(Z)=>s7($,Z),(Z)=>$.forEach((Y)=>Y.errorCallback(Z)))}#K(X,$){let Z=new o6(this,X.encoding);this.#_=Z,this.#V(()=>this.#M($,X),(Y)=>Z.open(Y),(Y)=>Y.baton,(Y)=>Y.baseUrl,(Y)=>$.cursorCallback(Z),(Y)=>$.errorCallback(Y))}#V(X,$,Z,Y,G,J){let _;try{let W=X(),z=this.#Y;_=z(W)}catch(W){_=Promise.reject(W)}this.#W=!0,_.then((W)=>{if(!W.ok)return r7(W).then((z)=>{throw z});return $(W)}).then((W)=>{this.#G=Z(W),this.#$=Y(W)??this.#$,G(W)}).catch((W)=>{this._setClosed(W),J(W)}).finally(()=>{this.#W=!1,this.#D()})}#E(X,$){return this.#I(new URL($.pipelinePath,this.#$),{baton:this.#G,requests:X.map((Z)=>Z.request)},$.encoding,aX,X$)}#M(X,$){if($.cursorPath===void 0)throw new D1(`Cursors are supported only on protocol version 3 and higher, but the HTTP server only supports version ${$.version}.`);return this.#I(new URL($.cursorPath,this.#$),{baton:this.#G,batch:X.batch},$.encoding,eX,$$)}#I(X,$,Z,Y,G){let J,_;if(Z==="json")J=X0($,Y),_="application/json";else if(Z==="protobuf")J=Y0($,G),_="application/x-protobuf";else throw Q(Z,"Impossible encoding");let W=new u6;if(W.set("content-type",_),this.#Z!==void 0)W.set("authorization",`Bearer ${this.#Z}`);return new O0(X.toString(),{method:"POST",headers:W,body:J})}}function s7(X,$){if($.results.length!==X.length)throw new E("Server returned unexpected number of pipeline results");for(let Z=0;Z<X.length;++Z){let Y=$.results[Z],G=X[Z];if(Y.type==="ok"){if(Y.response.type!==G.request.type)throw new E("Received unexpected type of response");G.responseCallback(Y.response)}else if(Y.type==="error")G.errorCallback(h1(Y.error));else if(Y.type==="none")throw new E("Received unrecognized type of StreamResult");else throw Q(Y,"Received impossible type of StreamResult")}}async function t7(X,$){if($==="json"){let Z=await X.json();return G2(Z,sX)}if($==="protobuf"){let Z=await X.arrayBuffer();return c1(new Uint8Array(Z),rX)}throw await X.body?.cancel(),Q($,"Impossible encoding")}async function r7(X){let $=X.headers.get("content-type")??"text/plain",Z=`Server returned HTTP status ${X.status}`;if($==="application/json"){let Y=await X.json();if("message"in Y)return h1(Y);return new Y2(Z,X.status)}if($==="text/plain"){let Y=(await X.text()).trim();if(Y!=="")Z+=`: ${Y}`;return new Y2(Z,X.status)}return await X.body?.cancel(),new Y2(Z,X.status)}var l7=[{versionPath:"v3-protobuf",pipelinePath:"v3-protobuf/pipeline",cursorPath:"v3-protobuf/cursor",version:3,encoding:"protobuf"}],i6={versionPath:"v2",pipelinePath:"v2/pipeline",cursorPath:void 0,version:2,encoding:"json"};class c0 extends E2{#X;#$;#Z;#Y;#G;_endpointPromise;_endpoint;constructor(X,$,Z,Y=2){super();if(this.#X=X,this.#$=$,this.#Z=Z??c6,this.#Y=void 0,this.#G=new Set,Y==3)this._endpointPromise=a7(this.#Z,this.#X),this._endpointPromise.then((G)=>this._endpoint=G,(G)=>this.#J(G));else this._endpointPromise=Promise.resolve(i6),this._endpointPromise.then((G)=>this._endpoint=G,(G)=>this.#J(G))}async getVersion(){if(this._endpoint!==void 0)return this._endpoint.version;return(await this._endpointPromise).version}_ensureVersion(X,$){if(X<=i6.version)return;else if(this._endpoint===void 0)throw new D1(`${$} is supported only on protocol version ${X} and higher, but the version supported by the HTTP server is not yet known. Use Client.getVersion() to wait until the version is available.`);else if(this._endpoint.version<X)throw new D1(`${$} is supported only on protocol version ${X} and higher, but the HTTP server only supports version ${this._endpoint.version}.`)}openStream(){if(this.#Y!==void 0)throw new y("Client is closed",this.#Y);let X=new u0(this,this.#X,this.#$,this.#Z);return this.#G.add(X),X}_streamClosed(X){this.#G.delete(X)}close(){this.#J(new k("Client was manually closed"))}get closed(){return this.#Y!==void 0}#J(X){if(this.#Y!==void 0)return;this.#Y=X;for(let $ of Array.from(this.#G))$._setClosed(new y("Client was closed",X))}}async function a7(X,$){let Z=X;for(let Y of l7){let G=new URL(Y.versionPath,$),J=new O0(G.toString(),{method:"GET"}),_=await Z(J);if(await _.arrayBuffer(),_.ok)return Y}return i6}function s6(X,$,Z=2){if(typeof r2.default>"u")throw new a2("WebSockets are not supported in this environment");var Y=void 0;if(Z==3)Y=Array.from(m6.keys());else Y=Array.from(iX.keys());let G=new r2.default(X,Y);return new m0(G,$)}function t6(X,$,Z,Y=2){return new c0(X instanceof URL?X:new URL(X),$,Z,Y)}class U0{#X;#$;#Z;constructor(X,$){this.#X=X,this.#$=$,this.#Z=void 0}execute(X){return this.batch([X]).then(($)=>$[0])}async batch(X){let $=this._getStream();if($.closed)throw new N("Cannot execute statements because the transaction is closed","TRANSACTION_CLOSED");try{let Z=X.map(q1),Y;if(this.#Z===void 0){this._getSqlCache().apply(Z);let J=$.batch(this.#$>=3),_=J.step(),W=_.run(b1(this.#X)),z=_;Y=Z.map((H)=>{let D=J.step().condition(q.ok(z));if(this.#$>=3)D.condition(q.not(q.isAutocommit(J)));let V=D.query(H);return V.catch(()=>{return}),z=D,V}),this.#Z=J.execute().then(()=>W).then(()=>{return});try{await this.#Z}catch(H){throw this.close(),H}}else{if(this.#$<3)await this.#Z;this._getSqlCache().apply(Z);let J=$.batch(this.#$>=3),_=void 0;Y=Z.map((W)=>{let z=J.step();if(_!==void 0)z.condition(q.ok(_));if(this.#$>=3)z.condition(q.not(q.isAutocommit(J)));let H=z.query(W);return H.catch(()=>{return}),_=z,H}),await J.execute()}let G=[];for(let J of Y){let _=await J;if(_===void 0)throw new N("Statement in a transaction was not executed, probably because the transaction has been rolled back","TRANSACTION_CLOSED");G.push(k2(_))}return G}catch(Z){throw S(Z)}}async executeMultiple(X){let $=this._getStream();if($.closed)throw new N("Cannot execute statements because the transaction is closed","TRANSACTION_CLOSED");try{if(this.#Z===void 0){this.#Z=$.run(b1(this.#X)).then(()=>{return});try{await this.#Z}catch(Z){throw this.close(),Z}}else await this.#Z;await $.sequence(X)}catch(Z){throw S(Z)}}async rollback(){try{let X=this._getStream();if(X.closed)return;if(this.#Z!==void 0);else return;let $=X.run("ROLLBACK").catch((Z)=>{throw S(Z)});X.closeGracefully(),await $}catch(X){throw S(X)}finally{this.close()}}async commit(){try{let X=this._getStream();if(X.closed)throw new N("Cannot commit the transaction because it is already closed","TRANSACTION_CLOSED");if(this.#Z!==void 0)await this.#Z;else return;let $=X.run("COMMIT").catch((Z)=>{throw S(Z)});X.closeGracefully(),await $}catch(X){throw S(X)}finally{this.close()}}}async function j2(X,$,Z,Y,G=!1){if(G)Z.step().run("PRAGMA foreign_keys=off");let J=Z.step(),_=J.run(b1(X)),W=J,z=Y.map((M)=>{let K=Z.step().condition(q.ok(W));if($>=3)K.condition(q.not(q.isAutocommit(Z)));let w=K.query(M);return W=K,w}),H=Z.step().condition(q.ok(W));if($>=3)H.condition(q.not(q.isAutocommit(Z)));let D=H.run("COMMIT");if(Z.step().condition(q.not(q.ok(H))).run("ROLLBACK").catch((M)=>{return}),G)Z.step().run("PRAGMA foreign_keys=on");await Z.execute();let I=[];await _;for(let M of z){let K=await M;if(K===void 0)throw new N("Statement in a batch was not executed, probably because the transaction has been rolled back","TRANSACTION_CLOSED");I.push(k2(K))}return await D,I}function q1(X){let $,Z;if(Array.isArray(X))[$,Z]=X;else if(typeof X==="string")$=X;else $=X.sql,Z=X.args;let Y=new J0($);if(Z)if(Array.isArray(Z))Y.bindIndexes(Z);else for(let[G,J]of Object.entries(Z))Y.bindName(G,J);return Y}function k2(X){let $=X.columnNames.map((_)=>_??""),Z=X.columnDecltypes.map((_)=>_??""),Y=X.rows,G=X.affectedRowCount,J=X.lastInsertRowid!==void 0?X.lastInsertRowid:void 0;return new V2($,Z,Y,G,J)}function S(X){if(X instanceof k){let $=Z$(X);return new N(X.message,$,void 0,X)}return X}function Z$(X){if(X instanceof l2&&X.code!==void 0)return X.code;else if(X instanceof E)return"HRANA_PROTO_ERROR";else if(X instanceof y)return X.cause instanceof k?Z$(X.cause):"HRANA_CLOSED_ERROR";else if(X instanceof M2)return"HRANA_WEBSOCKET_ERROR";else if(X instanceof Y2)return"SERVER_ERROR";else if(X instanceof D1)return"PROTOCOL_VERSION_ERROR";else if(X instanceof l)return"INTERNAL_ERROR";else return"UNKNOWN"}class L2{#X;#$;capacity;constructor(X,$){this.#X=X,this.#$=new Y$,this.capacity=$}apply(X){if(this.capacity<=0)return;let $=new Set;for(let Z of X){if(typeof Z.sql!=="string")continue;let Y=Z.sql;if(Y.length>=5000)continue;let G=this.#$.get(Y);if(G===void 0){while(this.#$.size+1>this.capacity){let[J,_]=this.#$.peekLru();if($.has(_))break;_.close(),this.#$.delete(J)}if(this.#$.size+1<=this.capacity)G=this.#X.storeSql(Y),this.#$.set(Y,G)}if(G!==void 0)Z.sql=G,$.add(G)}}}class Y${#X;constructor(){this.#X=new Map}get(X){let $=this.#X.get(X);if($!==void 0)this.#X.delete(X),this.#X.set(X,$);return $}set(X,$){this.#X.set(X,$)}peekLru(){for(let X of this.#X.entries())return X;return}delete(X){this.#X.delete(X)}get size(){return this.#X.size}}var W$=C0(l6(),1);function H$(X){if(X.scheme!=="wss"&&X.scheme!=="ws")throw new N(`The WebSocket client supports only "libsql:", "wss:" and "ws:" URLs, got ${JSON.stringify(X.scheme+":")}. For more information, please read ${M1}`,"URL_SCHEME_NOT_SUPPORTED");if(X.encryptionKey!==void 0)throw new N("Encryption key is not supported by the remote client.","ENCRYPTION_KEY_NOT_SUPPORTED");if(X.scheme==="ws"&&X.tls)throw new N('A "ws:" URL cannot opt into TLS by using ?tls=1',"URL_INVALID");else if(X.scheme==="wss"&&!X.tls)throw new N('A "wss:" URL cannot opt out of TLS by using ?tls=0',"URL_INVALID");let $=o2(X.scheme,X.authority,X.path),Z;try{Z=s6($,X.authToken)}catch(Y){if(Y instanceof a2){let G=X.scheme==="wss"?"https":"http",J=o2(G,X.authority,X.path);throw new N(`This environment does not support WebSockets, please switch to the HTTP client by using a "${G}:" URL (${JSON.stringify(J)}). For more information, please read ${M1}`,"WEBSOCKETS_NOT_SUPPORTED")}throw S(Y)}return new z$(Z,$,X.authToken,X.intMode,X.concurrency)}var $G=60000,_$=100;class z${#X;#$;#Z;#Y;#G;closed;protocol;#J;#W;constructor(X,$,Z,Y,G){this.#X=$,this.#$=Z,this.#Z=Y,this.#Y=this.#H(X),this.#G=void 0,this.closed=!1,this.protocol="ws",this.#W=W$.default(G)}async limit(X){return this.#W(X)}async execute(X,$){let Z;if(typeof X==="string")Z={sql:X,args:$||[]};else Z=X;return this.limit(async()=>{let Y=await this.#_();try{let G=q1(Z);Y.conn.sqlCache.apply([G]);let J=Y.stream.query(G);Y.stream.closeGracefully();let _=await J;return k2(_)}catch(G){throw S(G)}finally{this._closeStream(Y)}})}async batch(X,$="deferred"){return this.limit(async()=>{let Z=await this.#_();try{let G=X.map((H)=>{if(Array.isArray(H))return{sql:H[0],args:H[1]||[]};return H}).map(q1),J=await Z.conn.client.getVersion();Z.conn.sqlCache.apply(G);let _=Z.stream.batch(J>=3);return await j2($,J,_,G)}catch(Y){throw S(Y)}finally{this._closeStream(Z)}})}async migrate(X){return this.limit(async()=>{let $=await this.#_();try{let Z=X.map(q1),Y=await $.conn.client.getVersion(),G=$.stream.batch(Y>=3);return await j2("deferred",Y,G,Z,!0)}catch(Z){throw S(Z)}finally{this._closeStream($)}})}async transaction(X="write"){return this.limit(async()=>{let $=await this.#_();try{let Z=await $.conn.client.getVersion();return new A$(this,$,X,Z)}catch(Z){throw this._closeStream($),S(Z)}})}async executeMultiple(X){return this.limit(async()=>{let $=await this.#_();try{let Z=$.stream.sequence(X);$.stream.closeGracefully(),await Z}catch(Z){throw S(Z)}finally{this._closeStream($)}})}sync(){throw new N("sync not supported in ws mode","SYNC_NOT_SUPPORTED")}async#_(){if(this.closed)throw new N("The client is closed","CLIENT_CLOSED");if(new Date().valueOf()-this.#Y.openTime.valueOf()>$G&&this.#G===void 0){let Y=this.#H();this.#G=Y,Y.client.getVersion().then((G)=>{if(this.#Y!==Y){if(this.#Y.streamStates.size===0)this.#Y.client.close()}this.#Y=Y,this.#G=void 0},(G)=>{this.#G=void 0})}if(this.#Y.client.closed)try{if(this.#G!==void 0)this.#Y=this.#G;else this.#Y=this.#H()}catch(Y){throw S(Y)}let Z=this.#Y;try{if(Z.useSqlCache===void 0){if(Z.useSqlCache=await Z.client.getVersion()>=2,Z.useSqlCache)Z.sqlCache.capacity=_$}let Y=Z.client.openStream();Y.intMode=this.#Z;let G={conn:Z,stream:Y};return Z.streamStates.add(G),G}catch(Y){throw S(Y)}}#H(X){try{return X??=s6(this.#X,this.#$),{client:X,useSqlCache:void 0,sqlCache:new L2(X,0),openTime:new Date,streamStates:new Set}}catch($){throw S($)}}async reconnect(){try{for(let Z of Array.from(this.#Y.streamStates))try{Z.stream.close()}catch{}this.#Y.client.close()}catch{}if(this.#G){try{this.#G.client.close()}catch{}this.#G=void 0}let X=this.#H(),$=await X.client.getVersion();if(X.useSqlCache=$>=2,X.useSqlCache)X.sqlCache.capacity=_$;this.#Y=X,this.closed=!1}_closeStream(X){X.stream.close();let $=X.conn;if($.streamStates.delete(X),$.streamStates.size===0&&$!==this.#Y)$.client.close()}close(){if(this.#Y.client.close(),this.closed=!0,this.#G){try{this.#G.client.close()}catch{}this.#G=void 0}this.closed=!0}}class A$ extends U0{#X;#$;constructor(X,$,Z,Y){super(Z,Y);this.#X=X,this.#$=$}_getStream(){return this.#$.stream}_getSqlCache(){return this.#$.conn.sqlCache}close(){this.#X._closeStream(this.#$)}get closed(){return this.#$.stream.closed}}var O$=C0(l6(),1);function U$(X){if(X.scheme!=="https"&&X.scheme!=="http")throw new N(`The HTTP client supports only "libsql:", "https:" and "http:" URLs, got ${JSON.stringify(X.scheme+":")}. For more information, please read ${M1}`,"URL_SCHEME_NOT_SUPPORTED");if(X.encryptionKey!==void 0)throw new N("Encryption key is not supported by the remote client.","ENCRYPTION_KEY_NOT_SUPPORTED");if(X.scheme==="http"&&X.tls)throw new N('A "http:" URL cannot opt into TLS by using ?tls=1',"URL_INVALID");else if(X.scheme==="https"&&!X.tls)throw new N('A "https:" URL cannot opt out of TLS by using ?tls=0',"URL_INVALID");let $=o2(X.scheme,X.authority,X.path);return new F$($,X.authToken,X.intMode,X.fetch,X.concurrency)}var D$=30;class F${#X;protocol;#$;#Z;#Y;#G;#J;#W;constructor(X,$,Z,Y,G){this.#$=X,this.#J=$,this.#Z=Z,this.#Y=Y,this.#G=G,this.#X=t6(this.#$,this.#J,this.#Y),this.#X.intMode=this.#Z,this.protocol="http",this.#W=O$.default(this.#G)}async limit(X){return this.#W(X)}async execute(X,$){let Z;if(typeof X==="string")Z={sql:X,args:$||[]};else Z=X;return this.limit(async()=>{try{let Y=q1(Z),G,J=this.#X.openStream();try{G=J.query(Y)}finally{J.closeGracefully()}let _=await G;return k2(_)}catch(Y){throw S(Y)}})}async batch(X,$="deferred"){return this.limit(async()=>{try{let Y=X.map((z)=>{if(Array.isArray(z))return{sql:z[0],args:z[1]||[]};return z}).map(q1),G=await this.#X.getVersion(),J,_=this.#X.openStream();try{new L2(_,D$).apply(Y);let H=_.batch(!1);J=j2($,G,H,Y)}finally{_.closeGracefully()}return await J}catch(Z){throw S(Z)}})}async migrate(X){return this.limit(async()=>{try{let $=X.map(q1),Z=await this.#X.getVersion(),Y,G=this.#X.openStream();try{let _=G.batch(!1);Y=j2("deferred",Z,_,$,!0)}finally{G.closeGracefully()}return await Y}catch($){throw S($)}})}async transaction(X="write"){return this.limit(async()=>{try{let $=await this.#X.getVersion();return new R$(this.#X.openStream(),X,$)}catch($){throw S($)}})}async executeMultiple(X){return this.limit(async()=>{try{let $,Z=this.#X.openStream();try{$=Z.sequence(X)}finally{Z.closeGracefully()}await $}catch($){throw S($)}})}sync(){throw new N("sync not supported in http mode","SYNC_NOT_SUPPORTED")}close(){this.#X.close()}async reconnect(){try{if(!this.closed)this.#X.close()}finally{this.#X=t6(this.#$,this.#J,this.#Y),this.#X.intMode=this.#Z}}get closed(){return this.#X.closed}}class R$ extends U0{#X;#$;constructor(X,$,Z){super($,Z);this.#X=X,this.#$=new L2(X,D$)}_getStream(){return this.#X}_getSqlCache(){return this.#$}close(){this.#X.close()}get closed(){return this.#X.closed}}function C2(X){return ZG(s2(X,!0))}function ZG(X){if(X.scheme==="wss"||X.scheme==="ws")return H$(X);else if(X.scheme==="https"||X.scheme==="http")return U$(X);else return wX(X)}class d{static[O]="SelectionProxyHandler";config;constructor(X){this.config={...X}}get(X,$){if($==="_")return{...X._,selectedFields:new Proxy(X._.selectedFields,this)};if($===h)return{...X[h],selectedFields:new Proxy(X[h].selectedFields,this)};if(typeof $==="symbol")return X[$];let Y=(U(X,g)?X._.selectedFields:U(X,_1)?X[h].selectedFields:X)[$];if(U(Y,R.Aliased)){if(this.config.sqlAliasedBehavior==="sql"&&!Y.isSelectionField)return Y.sql;let G=Y.clone();return G.isSelectionField=!0,G}if(U(Y,R)){if(this.config.sqlBehavior==="sql")return Y;throw Error(`You tried to reference "${$}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`)}if(U(Y,j)){if(this.config.alias)return new Proxy(Y,new O2(new Proxy(Y.table,new b2(this.config.alias,this.config.replaceOriginalName??!1))));return Y}if(typeof Y!=="object"||Y===null)return Y;return new Proxy(Y,new d(this.config))}}class a6{static[O]="SQLiteForeignKeyBuilder";reference;_onUpdate;_onDelete;constructor(X,$){if(this.reference=()=>{let{name:Z,columns:Y,foreignColumns:G}=X();return{name:Z,columns:Y,foreignTable:G[0].table,foreignColumns:G}},$)this._onUpdate=$.onUpdate,this._onDelete=$.onDelete}onUpdate(X){return this._onUpdate=X,this}onDelete(X){return this._onDelete=X,this}build(X){return new V$(X,this)}}class V${constructor(X,$){this.table=X,this.reference=$.reference,this.onUpdate=$._onUpdate,this.onDelete=$._onDelete}static[O]="SQLiteForeignKey";reference;onUpdate;onDelete;getName(){let{name:X,columns:$,foreignColumns:Z}=this.reference(),Y=$.map((_)=>_.name),G=Z.map((_)=>_.name),J=[this.table[$1],...Y,Z[0].table[$1],...G];return X??`${J.join("_")}_fk`}}function K$(X,$){return`${X[$1]}_${$.join("_")}_unique`}class o extends F6{static[O]="SQLiteColumnBuilder";foreignKeyConfigs=[];references(X,$={}){return this.foreignKeyConfigs.push({ref:X,actions:$}),this}unique(X){return this.config.isUnique=!0,this.config.uniqueName=X,this}generatedAlwaysAs(X,$){return this.config.generated={as:X,type:"always",mode:$?.mode??"virtual"},this}buildForeignKeys(X,$){return this.foreignKeyConfigs.map(({ref:Z,actions:Y})=>{return((G,J)=>{let _=new a6(()=>{let W=G();return{columns:[X],foreignColumns:[W]}});if(J.onUpdate)_.onUpdate(J.onUpdate);if(J.onDelete)_.onDelete(J.onDelete);return _.build($)})(Z,Y)})}}class f extends j{constructor(X,$){if(!$.uniqueName)$.uniqueName=K$(X,[$.name]);super(X,$);this.table=X}static[O]="SQLiteColumn"}class I$ extends o{static[O]="SQLiteBigIntBuilder";constructor(X){super(X,"bigint","SQLiteBigInt")}build(X){return new E$(X,this.config)}}class E$ extends f{static[O]="SQLiteBigInt";getSQLType(){return"blob"}mapFromDriverValue(X){if(typeof Buffer<"u"&&Buffer.from){let $=Buffer.isBuffer(X)?X:X instanceof ArrayBuffer?Buffer.from(X):X.buffer?Buffer.from(X.buffer,X.byteOffset,X.byteLength):Buffer.from(X);return BigInt($.toString("utf8"))}return BigInt(B6.decode(X))}mapToDriverValue(X){return Buffer.from(X.toString())}}class M$ extends o{static[O]="SQLiteBlobJsonBuilder";constructor(X){super(X,"json","SQLiteBlobJson")}build(X){return new N$(X,this.config)}}class N$ extends f{static[O]="SQLiteBlobJson";getSQLType(){return"blob"}mapFromDriverValue(X){if(typeof Buffer<"u"&&Buffer.from){let $=Buffer.isBuffer(X)?X:X instanceof ArrayBuffer?Buffer.from(X):X.buffer?Buffer.from(X.buffer,X.byteOffset,X.byteLength):Buffer.from(X);return JSON.parse($.toString("utf8"))}return JSON.parse(B6.decode(X))}mapToDriverValue(X){return Buffer.from(JSON.stringify(X))}}class w$ extends o{static[O]="SQLiteBlobBufferBuilder";constructor(X){super(X,"buffer","SQLiteBlobBuffer")}build(X){return new x$(X,this.config)}}class x$ extends f{static[O]="SQLiteBlobBuffer";mapFromDriverValue(X){if(Buffer.isBuffer(X))return X;return Buffer.from(X)}getSQLType(){return"blob"}}function P$(X,$){let{name:Z,config:Y}=E1(X,$);if(Y?.mode==="json")return new M$(Z);if(Y?.mode==="bigint")return new I$(Z);return new w$(Z)}class B$ extends o{static[O]="SQLiteCustomColumnBuilder";constructor(X,$,Z){super(X,"custom","SQLiteCustomColumn");this.config.fieldConfig=$,this.config.customTypeParams=Z}build(X){return new T$(X,this.config)}}class T$ extends f{static[O]="SQLiteCustomColumn";sqlName;mapTo;mapFrom;constructor(X,$){super(X,$);this.sqlName=$.customTypeParams.dataType($.fieldConfig),this.mapTo=$.customTypeParams.toDriver,this.mapFrom=$.customTypeParams.fromDriver}getSQLType(){return this.sqlName}mapFromDriverValue(X){return typeof this.mapFrom==="function"?this.mapFrom(X):X}mapToDriverValue(X){return typeof this.mapTo==="function"?this.mapTo(X):X}}function Q$(X){return($,Z)=>{let{name:Y,config:G}=E1($,Z);return new B$(Y,G,X)}}class n0 extends o{static[O]="SQLiteBaseIntegerBuilder";constructor(X,$,Z){super(X,$,Z);this.config.autoIncrement=!1}primaryKey(X){if(X?.autoIncrement)this.config.autoIncrement=!0;return this.config.hasDefault=!0,super.primaryKey()}}class o0 extends f{static[O]="SQLiteBaseInteger";autoIncrement=this.config.autoIncrement;getSQLType(){return"integer"}}class j$ extends n0{static[O]="SQLiteIntegerBuilder";constructor(X){super(X,"number","SQLiteInteger")}build(X){return new k$(X,this.config)}}class k$ extends o0{static[O]="SQLiteInteger"}class L$ extends n0{static[O]="SQLiteTimestampBuilder";constructor(X,$){super(X,"date","SQLiteTimestamp");this.config.mode=$}defaultNow(){return this.default(A`(cast((julianday('now') - 2440587.5)*86400000 as integer))`)}build(X){return new C$(X,this.config)}}class C$ extends o0{static[O]="SQLiteTimestamp";mode=this.config.mode;mapFromDriverValue(X){if(this.config.mode==="timestamp")return new Date(X*1000);return new Date(X)}mapToDriverValue(X){let $=X.getTime();if(this.config.mode==="timestamp")return Math.floor($/1000);return $}}class v$ extends n0{static[O]="SQLiteBooleanBuilder";constructor(X,$){super(X,"boolean","SQLiteBoolean");this.config.mode=$}build(X){return new h$(X,this.config)}}class h$ extends o0{static[O]="SQLiteBoolean";mode=this.config.mode;mapFromDriverValue(X){return Number(X)===1}mapToDriverValue(X){return X?1:0}}function t1(X,$){let{name:Z,config:Y}=E1(X,$);if(Y?.mode==="timestamp"||Y?.mode==="timestamp_ms")return new L$(Z,Y.mode);if(Y?.mode==="boolean")return new v$(Z,Y.mode);return new j$(Z)}class q$ extends o{static[O]="SQLiteNumericBuilder";constructor(X){super(X,"string","SQLiteNumeric")}build(X){return new S$(X,this.config)}}class S$ extends f{static[O]="SQLiteNumeric";mapFromDriverValue(X){if(typeof X==="string")return X;return String(X)}getSQLType(){return"numeric"}}class f$ extends o{static[O]="SQLiteNumericNumberBuilder";constructor(X){super(X,"number","SQLiteNumericNumber")}build(X){return new y$(X,this.config)}}class y$ extends f{static[O]="SQLiteNumericNumber";mapFromDriverValue(X){if(typeof X==="number")return X;return Number(X)}mapToDriverValue=String;getSQLType(){return"numeric"}}class p$ extends o{static[O]="SQLiteNumericBigIntBuilder";constructor(X){super(X,"bigint","SQLiteNumericBigInt")}build(X){return new g$(X,this.config)}}class g$ extends f{static[O]="SQLiteNumericBigInt";mapFromDriverValue=BigInt;mapToDriverValue=String;getSQLType(){return"numeric"}}function b$(X,$){let{name:Z,config:Y}=E1(X,$),G=Y?.mode;return G==="number"?new f$(Z):G==="bigint"?new p$(Z):new q$(Z)}class d$ extends o{static[O]="SQLiteRealBuilder";constructor(X){super(X,"number","SQLiteReal")}build(X){return new m$(X,this.config)}}class m$ extends f{static[O]="SQLiteReal";getSQLType(){return"real"}}function v2(X){return new d$(X??"")}class u$ extends o{static[O]="SQLiteTextBuilder";constructor(X,$){super(X,"string","SQLiteText");this.config.enumValues=$.enum,this.config.length=$.length}build(X){return new c$(X,this.config)}}class c$ extends f{static[O]="SQLiteText";enumValues=this.config.enumValues;length=this.config.length;constructor(X,$){super(X,$)}getSQLType(){return`text${this.config.length?`(${this.config.length})`:""}`}}class n$ extends o{static[O]="SQLiteTextJsonBuilder";constructor(X){super(X,"json","SQLiteTextJson")}build(X){return new o$(X,this.config)}}class o$ extends f{static[O]="SQLiteTextJson";getSQLType(){return"text"}mapFromDriverValue(X){return JSON.parse(X)}mapToDriverValue(X){return JSON.stringify(X)}}function p(X,$={}){let{name:Z,config:Y}=E1(X,$);if(Y.mode==="json")return new n$(Z);return new u$(Z,Y)}function i$(){return{blob:P$,customType:Q$,integer:t1,numeric:b$,real:v2,text:p}}var e6=Symbol.for("drizzle:SQLiteInlineForeignKeys");class m extends F{static[O]="SQLiteTable";static Symbol=Object.assign({},F.Symbol,{InlineForeignKeys:e6});[F.Symbol.Columns];[e6]=[];[F.Symbol.ExtraConfigBuilder]=void 0}function YG(X,$,Z,Y,G=X){let J=new m(X,Y,G),_=typeof $==="function"?$(i$()):$,W=Object.fromEntries(Object.entries(_).map(([H,D])=>{let V=D;V.setName(H);let I=V.build(J);return J[e6].push(...V.buildForeignKeys(I,J)),[H,I]})),z=Object.assign(J,W);if(z[F.Symbol.Columns]=W,z[F.Symbol.ExtraConfigColumns]=W,Z)z[m.Symbol.ExtraConfigBuilder]=Z;return z}var r1=(X,$,Z)=>{return YG(X,$,Z)};class s${constructor(X,$){this.name=X,this.unique=$}static[O]="SQLiteIndexBuilderOn";on(...X){return new t$(this.name,X,this.unique)}}class t${static[O]="SQLiteIndexBuilder";config;constructor(X,$,Z){this.config={name:X,columns:$,unique:Z,where:void 0}}where(X){return this.config.where=X,this}build(X){return new r$(this.config,X)}}class r${static[O]="SQLiteIndex";config;constructor(X,$){this.config={...X,table:$}}}function S1(X){return new s$(X,!1)}function i0(...X){if(X[0].columns)return new X4(X[0].columns,X[0].name);return new X4(X)}class X4{static[O]="SQLitePrimaryKeyBuilder";columns;name;constructor(X,$){this.columns=X,this.name=$}build(X){return new l$(X,this.columns,this.name)}}class l${constructor(X,$,Z){this.table=X,this.columns=$,this.name=Z}static[O]="SQLitePrimaryKey";columns;name;getName(){return this.name??`${this.table[m.Symbol.Name]}_${this.columns.map((X)=>X.name).join("_")}_pk`}}function R1(X){if(U(X,m))return[`${X[F.Symbol.BaseName]}`];if(U(X,g))return X._.usedTables??[];if(U(X,R))return X.usedTables??[];return[]}class s0 extends a{constructor(X,$,Z,Y){super();this.table=X,this.session=$,this.dialect=Z,this.config={table:X,withList:Y}}static[O]="SQLiteDelete";config;where(X){return this.config.where=X,this}orderBy(...X){if(typeof X[0]==="function"){let $=X[0](new Proxy(this.config.table[F.Symbol.Columns],new d({sqlAliasedBehavior:"alias",sqlBehavior:"sql"}))),Z=Array.isArray($)?$:[$];this.config.orderBy=Z}else{let $=X;this.config.orderBy=$}return this}limit(X){return this.config.limit=X,this}returning(X=this.table[m.Symbol.Columns]){return this.config.returning=W1(X),this}getSQL(){return this.dialect.buildDeleteQuery(this.config)}toSQL(){let{typings:X,...$}=this.dialect.sqlToQuery(this.getSQL());return $}_prepare(X=!0){return this.session[X?"prepareOneTimeQuery":"prepareQuery"](this.dialect.sqlToQuery(this.getSQL()),this.config.returning,this.config.returning?"all":"run",!0,void 0,{type:"delete",tables:R1(this.config.table)})}prepare(){return this._prepare(!1)}run=(X)=>{return this._prepare().run(X)};all=(X)=>{return this._prepare().all(X)};get=(X)=>{return this._prepare().get(X)};values=(X)=>{return this._prepare().values(X)};async execute(X){return this._prepare().execute(X)}$dynamic(){return this}}function GG(X){return(X.replace(/['\u2019]/g,"").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g)??[]).map((Z)=>Z.toLowerCase()).join("_")}function JG(X){return(X.replace(/['\u2019]/g,"").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g)??[]).reduce((Z,Y,G)=>{let J=G===0?Y.toLowerCase():`${Y[0].toUpperCase()}${Y.slice(1)}`;return Z+J},"")}function _G(X){return X}class $4{static[O]="CasingCache";cache={};cachedTables={};convert;constructor(X){this.convert=X==="snake_case"?GG:X==="camelCase"?JG:_G}getColumnCasing(X){if(!X.keyAsName)return X.name;let $=X.table[F.Symbol.Schema]??"public",Z=X.table[F.Symbol.OriginalName],Y=`${$}.${Z}.${X.name}`;if(!this.cache[Y])this.cacheTable(X.table);return this.cache[Y]}cacheTable(X){let $=X[F.Symbol.Schema]??"public",Z=X[F.Symbol.OriginalName],Y=`${$}.${Z}`;if(!this.cachedTables[Y]){for(let G of Object.values(X[F.Symbol.Columns])){let J=`${Y}.${G.name}`;this.cache[J]=this.convert(G.name)}this.cachedTables[Y]=!0}}clearCache(){this.cache={},this.cachedTables={}}}class z2 extends _1{static[O]="SQLiteViewBase"}class h2{static[O]="SQLiteDialect";casing;constructor(X){this.casing=new $4(X?.casing)}escapeName(X){return`"${X}"`}escapeParam(X){return"?"}escapeString(X){return`'${X.replace(/'/g,"''")}'`}buildWithCTE(X){if(!X?.length)return;let $=[A`with `];for(let[Z,Y]of X.entries())if($.push(A`${A.identifier(Y._.alias)} as (${Y._.sql})`),Z<X.length-1)$.push(A`, `);return $.push(A` `),A.join($)}buildDeleteQuery({table:X,where:$,returning:Z,withList:Y,limit:G,orderBy:J}){let _=this.buildWithCTE(Y),W=Z?A` returning ${this.buildSelection(Z,{isSingleTable:!0})}`:void 0,z=$?A` where ${$}`:void 0,H=this.buildOrderBy(J),D=this.buildLimit(G);return A`${_}delete from ${X}${z}${W}${H}${D}`}buildUpdateSet(X,$){let Z=X[F.Symbol.Columns],Y=Object.keys(Z).filter((J)=>$[J]!==void 0||Z[J]?.onUpdateFn!==void 0),G=Y.length;return A.join(Y.flatMap((J,_)=>{let W=Z[J],z=$[J]??A.param(W.onUpdateFn(),W),H=A`${A.identifier(this.casing.getColumnCasing(W))} = ${z}`;if(_<G-1)return[H,A.raw(", ")];return[H]}))}buildUpdateQuery({table:X,set:$,where:Z,returning:Y,withList:G,joins:J,from:_,limit:W,orderBy:z}){let H=this.buildWithCTE(G),D=this.buildUpdateSet(X,$),V=_&&A.join([A.raw(" from "),this.buildFromTable(_)]),I=this.buildJoins(J),M=Y?A` returning ${this.buildSelection(Y,{isSingleTable:!0})}`:void 0,K=Z?A` where ${Z}`:void 0,w=this.buildOrderBy(z),P=this.buildLimit(W);return A`${H}update ${X} set ${D}${V}${I}${K}${M}${w}${P}`}buildSelection(X,{isSingleTable:$=!1}={}){let Z=X.length,Y=X.flatMap(({field:G},J)=>{let _=[];if(U(G,R.Aliased)&&G.isSelectionField)_.push(A.identifier(G.fieldAlias));else if(U(G,R.Aliased)||U(G,R)){let W=U(G,R.Aliased)?G.sql:G;if($)_.push(new R(W.queryChunks.map((z)=>{if(U(z,j))return A.identifier(this.casing.getColumnCasing(z));return z})));else _.push(W);if(U(G,R.Aliased))_.push(A` as ${A.identifier(G.fieldAlias)}`)}else if(U(G,j)){let W=G.table[F.Symbol.Name];if(G.columnType==="SQLiteNumericBigInt")if($)_.push(A`cast(${A.identifier(this.casing.getColumnCasing(G))} as text)`);else _.push(A`cast(${A.identifier(W)}.${A.identifier(this.casing.getColumnCasing(G))} as text)`);else if($)_.push(A.identifier(this.casing.getColumnCasing(G)));else _.push(A`${A.identifier(W)}.${A.identifier(this.casing.getColumnCasing(G))}`)}if(J<Z-1)_.push(A`, `);return _});return A.join(Y)}buildJoins(X){if(!X||X.length===0)return;let $=[];if(X)for(let[Z,Y]of X.entries()){if(Z===0)$.push(A` `);let G=Y.table,J=Y.on?A` on ${Y.on}`:void 0;if(U(G,m)){let _=G[m.Symbol.Name],W=G[m.Symbol.Schema],z=G[m.Symbol.OriginalName],H=_===z?void 0:Y.alias;$.push(A`${A.raw(Y.joinType)} join ${W?A`${A.identifier(W)}.`:void 0}${A.identifier(z)}${H&&A` ${A.identifier(H)}`}${J}`)}else $.push(A`${A.raw(Y.joinType)} join ${G}${J}`);if(Z<X.length-1)$.push(A` `)}return A.join($)}buildLimit(X){return typeof X==="object"||typeof X==="number"&&X>=0?A` limit ${X}`:void 0}buildOrderBy(X){let $=[];if(X){for(let[Z,Y]of X.entries())if($.push(Y),Z<X.length-1)$.push(A`, `)}return $.length>0?A` order by ${A.join($)}`:void 0}buildFromTable(X){if(U(X,F)&&X[F.Symbol.IsAlias])return A`${A`${A.identifier(X[F.Symbol.Schema]??"")}.`.if(X[F.Symbol.Schema])}${A.identifier(X[F.Symbol.OriginalName])} ${A.identifier(X[F.Symbol.Name])}`;return X}buildSelectQuery({withList:X,fields:$,fieldsFlat:Z,where:Y,having:G,table:J,joins:_,orderBy:W,groupBy:z,limit:H,offset:D,distinct:V,setOperators:I}){let M=Z??W1($);for(let U1 of M)if(U(U1.field,j)&&f1(U1.field.table)!==(U(J,g)?J._.alias:U(J,z2)?J[h].name:U(J,R)?void 0:f1(J))&&!((K1)=>_?.some(({alias:M0})=>M0===(K1[F.Symbol.IsAlias]?f1(K1):K1[F.Symbol.BaseName])))(U1.field.table)){let K1=f1(U1.field.table);throw Error(`Your "${U1.path.join("->")}" field references a column "${K1}"."${U1.field.name}", but the table "${K1}" is not part of the query! Did you forget to join it?`)}let K=!_||_.length===0,w=this.buildWithCTE(X),P=V?A` distinct`:void 0,u=this.buildSelection(M,{isSingleTable:K}),i=this.buildFromTable(J),L=this.buildJoins(_),T1=Y?A` where ${Y}`:void 0,J1=G?A` having ${G}`:void 0,x=[];if(z){for(let[U1,K1]of z.entries())if(x.push(K1),U1<z.length-1)x.push(A`, `)}let C=x.length>0?A` group by ${A.join(x)}`:void 0,Q1=this.buildOrderBy(W),E0=this.buildLimit(H),G6=D?A` offset ${D}`:void 0,A2=A`${w}select${P} ${u} from ${i}${L}${T1}${C}${J1}${Q1}${E0}${G6}`;if(I.length>0)return this.buildSetOperations(A2,I);return A2}buildSetOperations(X,$){let[Z,...Y]=$;if(!Z)throw Error("Cannot pass undefined values to any set operator");if(Y.length===0)return this.buildSetOperationQuery({leftSelect:X,setOperator:Z});return this.buildSetOperations(this.buildSetOperationQuery({leftSelect:X,setOperator:Z}),Y)}buildSetOperationQuery({leftSelect:X,setOperator:{type:$,isAll:Z,rightSelect:Y,limit:G,orderBy:J,offset:_}}){let W=A`${X.getSQL()} `,z=A`${Y.getSQL()}`,H;if(J&&J.length>0){let M=[];for(let K of J)if(U(K,f))M.push(A.identifier(K.name));else if(U(K,R)){for(let w=0;w<K.queryChunks.length;w++){let P=K.queryChunks[w];if(U(P,f))K.queryChunks[w]=A.identifier(this.casing.getColumnCasing(P))}M.push(A`${K}`)}else M.push(A`${K}`);H=A` order by ${A.join(M,A`, `)}`}let D=typeof G==="object"||typeof G==="number"&&G>=0?A` limit ${G}`:void 0,V=A.raw(`${$} ${Z?"all ":""}`),I=_?A` offset ${_}`:void 0;return A`${W}${V}${z}${H}${D}${I}`}buildInsertQuery({table:X,values:$,onConflict:Z,returning:Y,withList:G,select:J}){let _=[],W=X[F.Symbol.Columns],z=Object.entries(W).filter(([K,w])=>!w.shouldDisableInsert()),H=z.map(([,K])=>A.identifier(this.casing.getColumnCasing(K)));if(J){let K=$;if(U(K,R))_.push(K);else _.push(K.getSQL())}else{let K=$;_.push(A.raw("values "));for(let[w,P]of K.entries()){let u=[];for(let[i,L]of z){let T1=P[i];if(T1===void 0||U(T1,Z1)&&T1.value===void 0){let J1;if(L.default!==null&&L.default!==void 0)J1=U(L.default,R)?L.default:A.param(L.default,L);else if(L.defaultFn!==void 0){let x=L.defaultFn();J1=U(x,R)?x:A.param(x,L)}else if(!L.default&&L.onUpdateFn!==void 0){let x=L.onUpdateFn();J1=U(x,R)?x:A.param(x,L)}else J1=A`null`;u.push(J1)}else u.push(T1)}if(_.push(u),w<K.length-1)_.push(A`, `)}}let D=this.buildWithCTE(G),V=A.join(_),I=Y?A` returning ${this.buildSelection(Y,{isSingleTable:!0})}`:void 0,M=Z?.length?A.join(Z):void 0;return A`${D}insert into ${X} ${H} ${V}${M}${I}`}sqlToQuery(X,$){return X.toQuery({casing:this.casing,escapeName:this.escapeName,escapeParam:this.escapeParam,escapeString:this.escapeString,invokeSource:$})}buildRelationalQuery({fullSchema:X,schema:$,tableNamesMap:Z,table:Y,tableConfig:G,queryConfig:J,tableAlias:_,nestedQueryRelation:W,joinOn:z}){let H=[],D,V,I=[],M,K=[];if(J===!0)H=Object.entries(G.columns).map(([u,i])=>({dbKey:i.name,tsKey:u,field:I1(i,_),relationTableTsKey:void 0,isJson:!1,selection:[]}));else{let P=Object.fromEntries(Object.entries(G.columns).map(([x,C])=>[x,I1(C,_)]));if(J.where){let x=typeof J.where==="function"?J.where(P,U8()):J.where;M=x&&d2(x,_)}let u=[],i=[];if(J.columns){let x=!1;for(let[C,Q1]of Object.entries(J.columns)){if(Q1===void 0)continue;if(C in G.columns){if(!x&&Q1===!0)x=!0;i.push(C)}}if(i.length>0)i=x?i.filter((C)=>J.columns?.[C]===!0):Object.keys(G.columns).filter((C)=>!i.includes(C))}else i=Object.keys(G.columns);for(let x of i){let C=G.columns[x];u.push({tsKey:x,value:C})}let L=[];if(J.with)L=Object.entries(J.with).filter((x)=>!!x[1]).map(([x,C])=>({tsKey:x,queryConfig:C,relation:G.relations[x]}));let T1;if(J.extras){T1=typeof J.extras==="function"?J.extras(P,{sql:A}):J.extras;for(let[x,C]of Object.entries(T1))u.push({tsKey:x,value:M6(C,_)})}for(let{tsKey:x,value:C}of u)H.push({dbKey:U(C,R.Aliased)?C.fieldAlias:G.columns[x].name,tsKey:x,field:U(C,j)?I1(C,_):C,relationTableTsKey:void 0,isJson:!1,selection:[]});let J1=typeof J.orderBy==="function"?J.orderBy(P,D8()):J.orderBy??[];if(!Array.isArray(J1))J1=[J1];I=J1.map((x)=>{if(U(x,j))return I1(x,_);return d2(x,_)}),D=J.limit,V=J.offset;for(let{tsKey:x,queryConfig:C,relation:Q1}of L){let E0=R8($,Z,Q1),G6=l1(Q1.referencedTable),A2=Z[G6],U1=`${_}_${x}`,K1=H1(...E0.fields.map((HZ,zZ)=>T(I1(E0.references[zZ],U1),I1(HZ,_)))),M0=this.buildRelationalQuery({fullSchema:X,schema:$,tableNamesMap:Z,table:X[A2],tableConfig:$[A2],queryConfig:U(Q1,p1)?C===!0?{limit:1}:{...C,limit:1}:C,tableAlias:U1,joinOn:K1,nestedQueryRelation:Q1}),WZ=A`(${M0.sql})`.as(x);H.push({dbKey:x,tsKey:x,field:WZ,relationTableTsKey:A2,isJson:!0,selection:M0.selection})}}if(H.length===0)throw new U2({message:`No fields selected for table "${G.tsName}" ("${_}"). You need to have at least one item in "columns", "with" or "extras". If you need to select all columns, omit the "columns" key or set it to undefined.`});let w;if(M=H1(z,M),W){let P=A`json_array(${A.join(H.map(({field:L})=>U(L,f)?A.identifier(this.casing.getColumnCasing(L)):U(L,R.Aliased)?L.sql:L),A`, `)})`;if(U(W,n2))P=A`coalesce(json_group_array(${P}), json_array())`;let u=[{dbKey:"data",tsKey:"data",field:P.as("data"),isJson:!0,relationTableTsKey:G.tsName,selection:H}];if(D!==void 0||V!==void 0||I.length>0)w=this.buildSelectQuery({table:P0(Y,_),fields:{},fieldsFlat:[{path:[],field:A.raw("*")}],where:M,limit:D,offset:V,orderBy:I,setOperators:[]}),M=void 0,D=void 0,V=void 0,I=void 0;else w=P0(Y,_);w=this.buildSelectQuery({table:U(w,m)?w:new g(w,{},_),fields:{},fieldsFlat:u.map(({field:L})=>({path:[],field:U(L,j)?I1(L,_):L})),joins:K,where:M,limit:D,offset:V,orderBy:I,setOperators:[]})}else w=this.buildSelectQuery({table:P0(Y,_),fields:{},fieldsFlat:H.map(({field:P})=>({path:[],field:U(P,j)?I1(P,_):P})),joins:K,where:M,limit:D,offset:V,orderBy:I,setOperators:[]});return{tableTsKey:G.tsName,sql:w,selection:H}}}class Z4 extends h2{static[O]="SQLiteSyncDialect";migrate(X,$,Z){let Y=Z===void 0?"__drizzle_migrations":typeof Z==="string"?"__drizzle_migrations":Z.migrationsTable??"__drizzle_migrations",G=A`
			CREATE TABLE IF NOT EXISTS ${A.identifier(Y)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;$.run(G);let _=$.values(A`SELECT id, hash, created_at FROM ${A.identifier(Y)} ORDER BY created_at DESC LIMIT 1`)[0]??void 0;$.run(A`BEGIN`);try{for(let W of X)if(!_||Number(_[2])<W.folderMillis){for(let z of W.sql)$.run(A.raw(z));$.run(A`INSERT INTO ${A.identifier(Y)} ("hash", "created_at") VALUES(${W.hash}, ${W.folderMillis})`)}$.run(A`COMMIT`)}catch(W){throw $.run(A`ROLLBACK`),W}}}class Y4 extends h2{static[O]="SQLiteAsyncDialect";async migrate(X,$,Z){let Y=Z===void 0?"__drizzle_migrations":typeof Z==="string"?"__drizzle_migrations":Z.migrationsTable??"__drizzle_migrations",G=A`
			CREATE TABLE IF NOT EXISTS ${A.identifier(Y)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;await $.run(G);let _=(await $.values(A`SELECT id, hash, created_at FROM ${A.identifier(Y)} ORDER BY created_at DESC LIMIT 1`))[0]??void 0;await $.transaction(async(W)=>{for(let z of X)if(!_||Number(_[2])<z.folderMillis){for(let H of z.sql)await W.run(A.raw(H));await W.run(A`INSERT INTO ${A.identifier(Y)} ("hash", "created_at") VALUES(${z.hash}, ${z.folderMillis})`)}})}}class G4{static[O]="TypedQueryBuilder";getSelectedFields(){return this._.selectedFields}}class V1{static[O]="SQLiteSelectBuilder";fields;session;dialect;withList;distinct;constructor(X){this.fields=X.fields,this.session=X.session,this.dialect=X.dialect,this.withList=X.withList,this.distinct=X.distinct}from(X){let $=!!this.fields,Z;if(this.fields)Z=this.fields;else if(U(X,g))Z=Object.fromEntries(Object.keys(X._.selectedFields).map((Y)=>[Y,X[Y]]));else if(U(X,z2))Z=X[h].selectedFields;else if(U(X,R))Z={};else Z=m4(X);return new J4({table:X,fields:Z,isPartialSelect:$,session:this.session,dialect:this.dialect,withList:this.withList,distinct:this.distinct})}}class a$ extends G4{static[O]="SQLiteSelectQueryBuilder";_;config;joinsNotNullableMap;tableName;isPartialSelect;session;dialect;cacheConfig=void 0;usedTables=new Set;constructor({table:X,fields:$,isPartialSelect:Z,session:Y,dialect:G,withList:J,distinct:_}){super();this.config={withList:J,table:X,fields:{...$},distinct:_,setOperators:[]},this.isPartialSelect=Z,this.session=Y,this.dialect=G,this._={selectedFields:$,config:this.config},this.tableName=u2(X),this.joinsNotNullableMap=typeof this.tableName==="string"?{[this.tableName]:!0}:{};for(let W of R1(X))this.usedTables.add(W)}getUsedTables(){return[...this.usedTables]}createJoin(X){return($,Z)=>{let Y=this.tableName,G=u2($);for(let J of R1($))this.usedTables.add(J);if(typeof G==="string"&&this.config.joins?.some((J)=>J.alias===G))throw Error(`Alias "${G}" is already used in this query`);if(!this.isPartialSelect){if(Object.keys(this.joinsNotNullableMap).length===1&&typeof Y==="string")this.config.fields={[Y]:this.config.fields};if(typeof G==="string"&&!U($,R)){let J=U($,g)?$._.selectedFields:U($,_1)?$[h].selectedFields:$[F.Symbol.Columns];this.config.fields[G]=J}}if(typeof Z==="function")Z=Z(new Proxy(this.config.fields,new d({sqlAliasedBehavior:"sql",sqlBehavior:"sql"})));if(!this.config.joins)this.config.joins=[];if(this.config.joins.push({on:Z,table:$,joinType:X,alias:G}),typeof G==="string")switch(X){case"left":{this.joinsNotNullableMap[G]=!1;break}case"right":{this.joinsNotNullableMap=Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([J])=>[J,!1])),this.joinsNotNullableMap[G]=!0;break}case"cross":case"inner":{this.joinsNotNullableMap[G]=!0;break}case"full":{this.joinsNotNullableMap=Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([J])=>[J,!1])),this.joinsNotNullableMap[G]=!1;break}}return this}}leftJoin=this.createJoin("left");rightJoin=this.createJoin("right");innerJoin=this.createJoin("inner");fullJoin=this.createJoin("full");crossJoin=this.createJoin("cross");createSetOperator(X,$){return(Z)=>{let Y=typeof Z==="function"?Z(WG()):Z;if(!m2(this.getSelectedFields(),Y.getSelectedFields()))throw Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");return this.config.setOperators.push({type:X,isAll:$,rightSelect:Y}),this}}union=this.createSetOperator("union",!1);unionAll=this.createSetOperator("union",!0);intersect=this.createSetOperator("intersect",!1);except=this.createSetOperator("except",!1);addSetOperators(X){return this.config.setOperators.push(...X),this}where(X){if(typeof X==="function")X=X(new Proxy(this.config.fields,new d({sqlAliasedBehavior:"sql",sqlBehavior:"sql"})));return this.config.where=X,this}having(X){if(typeof X==="function")X=X(new Proxy(this.config.fields,new d({sqlAliasedBehavior:"sql",sqlBehavior:"sql"})));return this.config.having=X,this}groupBy(...X){if(typeof X[0]==="function"){let $=X[0](new Proxy(this.config.fields,new d({sqlAliasedBehavior:"alias",sqlBehavior:"sql"})));this.config.groupBy=Array.isArray($)?$:[$]}else this.config.groupBy=X;return this}orderBy(...X){if(typeof X[0]==="function"){let $=X[0](new Proxy(this.config.fields,new d({sqlAliasedBehavior:"alias",sqlBehavior:"sql"}))),Z=Array.isArray($)?$:[$];if(this.config.setOperators.length>0)this.config.setOperators.at(-1).orderBy=Z;else this.config.orderBy=Z}else{let $=X;if(this.config.setOperators.length>0)this.config.setOperators.at(-1).orderBy=$;else this.config.orderBy=$}return this}limit(X){if(this.config.setOperators.length>0)this.config.setOperators.at(-1).limit=X;else this.config.limit=X;return this}offset(X){if(this.config.setOperators.length>0)this.config.setOperators.at(-1).offset=X;else this.config.offset=X;return this}getSQL(){return this.dialect.buildSelectQuery(this.config)}toSQL(){let{typings:X,...$}=this.dialect.sqlToQuery(this.getSQL());return $}as(X){let $=[];if($.push(...R1(this.config.table)),this.config.joins)for(let Z of this.config.joins)$.push(...R1(Z.table));return new Proxy(new g(this.getSQL(),this.config.fields,X,!1,[...new Set($)]),new d({alias:X,sqlAliasedBehavior:"alias",sqlBehavior:"error"}))}getSelectedFields(){return new Proxy(this.config.fields,new d({alias:this.tableName,sqlAliasedBehavior:"alias",sqlBehavior:"error"}))}$dynamic(){return this}}class J4 extends a${static[O]="SQLiteSelect";_prepare(X=!0){if(!this.session)throw Error("Cannot execute a query on a query builder. Please use a database instance instead.");let $=W1(this.config.fields),Z=this.session[X?"prepareOneTimeQuery":"prepareQuery"](this.dialect.sqlToQuery(this.getSQL()),$,"all",!0,void 0,{type:"select",tables:[...this.usedTables]},this.cacheConfig);return Z.joinsNotNullableMap=this.joinsNotNullableMap,Z}$withCache(X){return this.cacheConfig=X===void 0?{config:{},enable:!0,autoInvalidate:!0}:X===!1?{enable:!1}:{enable:!0,autoInvalidate:!0,...X},this}prepare(){return this._prepare(!1)}run=(X)=>{return this._prepare().run(X)};all=(X)=>{return this._prepare().all(X)};get=(X)=>{return this._prepare().get(X)};values=(X)=>{return this._prepare().values(X)};async execute(){return this.all()}}d4(J4,[a]);function t0(X,$){return(Z,Y,...G)=>{let J=[Y,...G].map((_)=>({type:X,isAll:$,rightSelect:_}));for(let _ of J)if(!m2(Z.getSelectedFields(),_.rightSelect.getSelectedFields()))throw Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");return Z.addSetOperators(J)}}var WG=()=>({union:HG,unionAll:zG,intersect:AG,except:OG}),HG=t0("union",!1),zG=t0("union",!0),AG=t0("intersect",!1),OG=t0("except",!1);class D0{static[O]="SQLiteQueryBuilder";dialect;dialectConfig;constructor(X){this.dialect=U(X,h2)?X:void 0,this.dialectConfig=U(X,h2)?void 0:X}$with=(X,$)=>{let Z=this;return{as:(G)=>{if(typeof G==="function")G=G(Z);return new Proxy(new y2(G.getSQL(),$??("getSelectedFields"in G?G.getSelectedFields()??{}:{}),X,!0),new d({alias:X,sqlAliasedBehavior:"alias",sqlBehavior:"error"}))}}};with(...X){let $=this;function Z(G){return new V1({fields:G??void 0,session:void 0,dialect:$.getDialect(),withList:X})}function Y(G){return new V1({fields:G??void 0,session:void 0,dialect:$.getDialect(),withList:X,distinct:!0})}return{select:Z,selectDistinct:Y}}select(X){return new V1({fields:X??void 0,session:void 0,dialect:this.getDialect()})}selectDistinct(X){return new V1({fields:X??void 0,session:void 0,dialect:this.getDialect(),distinct:!0})}getDialect(){if(!this.dialect)this.dialect=new Z4(this.dialectConfig);return this.dialect}}class r0{constructor(X,$,Z,Y){this.table=X,this.session=$,this.dialect=Z,this.withList=Y}static[O]="SQLiteInsertBuilder";values(X){if(X=Array.isArray(X)?X:[X],X.length===0)throw Error("values() must be called with at least one value");let $=X.map((Z)=>{let Y={},G=this.table[F.Symbol.Columns];for(let J of Object.keys(Z)){let _=Z[J];Y[J]=U(_,R)?_:new Z1(_,G[J])}return Y});return new _4(this.table,$,this.session,this.dialect,this.withList)}select(X){let $=typeof X==="function"?X(new D0):X;if(!U($,R)&&!m2(this.table[w0],$._.selectedFields))throw Error("Insert select error: selected fields are not the same or are in a different order compared to the table definition");return new _4(this.table,$,this.session,this.dialect,this.withList,!0)}}class _4 extends a{constructor(X,$,Z,Y,G,J){super();this.session=Z,this.dialect=Y,this.config={table:X,values:$,withList:G,select:J}}static[O]="SQLiteInsert";config;returning(X=this.config.table[m.Symbol.Columns]){return this.config.returning=W1(X),this}onConflictDoNothing(X={}){if(!this.config.onConflict)this.config.onConflict=[];if(X.target===void 0)this.config.onConflict.push(A` on conflict do nothing`);else{let $=Array.isArray(X.target)?A`${X.target}`:A`${[X.target]}`,Z=X.where?A` where ${X.where}`:A``;this.config.onConflict.push(A` on conflict ${$} do nothing${Z}`)}return this}onConflictDoUpdate(X){if(X.where&&(X.targetWhere||X.setWhere))throw Error('You cannot use both "where" and "targetWhere"/"setWhere" at the same time - "where" is deprecated, use "targetWhere" or "setWhere" instead.');if(!this.config.onConflict)this.config.onConflict=[];let $=X.where?A` where ${X.where}`:void 0,Z=X.targetWhere?A` where ${X.targetWhere}`:void 0,Y=X.setWhere?A` where ${X.setWhere}`:void 0,G=Array.isArray(X.target)?A`${X.target}`:A`${[X.target]}`,J=this.dialect.buildUpdateSet(this.config.table,B0(this.config.table,X.set));return this.config.onConflict.push(A` on conflict ${G}${Z} do update set ${J}${$}${Y}`),this}getSQL(){return this.dialect.buildInsertQuery(this.config)}toSQL(){let{typings:X,...$}=this.dialect.sqlToQuery(this.getSQL());return $}_prepare(X=!0){return this.session[X?"prepareOneTimeQuery":"prepareQuery"](this.dialect.sqlToQuery(this.getSQL()),this.config.returning,this.config.returning?"all":"run",!0,void 0,{type:"insert",tables:R1(this.config.table)})}prepare(){return this._prepare(!1)}run=(X)=>{return this._prepare().run(X)};all=(X)=>{return this._prepare().all(X)};get=(X)=>{return this._prepare().get(X)};values=(X)=>{return this._prepare().values(X)};async execute(){return this.config.returning?this.all():this.run()}$dynamic(){return this}}class l0{constructor(X,$,Z,Y){this.table=X,this.session=$,this.dialect=Z,this.withList=Y}static[O]="SQLiteUpdateBuilder";set(X){return new e$(this.table,B0(this.table,X),this.session,this.dialect,this.withList)}}class e$ extends a{constructor(X,$,Z,Y,G){super();this.session=Z,this.dialect=Y,this.config={set:$,table:X,withList:G,joins:[]}}static[O]="SQLiteUpdate";config;from(X){return this.config.from=X,this}createJoin(X){return($,Z)=>{let Y=u2($);if(typeof Y==="string"&&this.config.joins.some((G)=>G.alias===Y))throw Error(`Alias "${Y}" is already used in this query`);if(typeof Z==="function"){let G=this.config.from?U($,m)?$[F.Symbol.Columns]:U($,g)?$._.selectedFields:U($,z2)?$[h].selectedFields:void 0:void 0;Z=Z(new Proxy(this.config.table[F.Symbol.Columns],new d({sqlAliasedBehavior:"sql",sqlBehavior:"sql"})),G&&new Proxy(G,new d({sqlAliasedBehavior:"sql",sqlBehavior:"sql"})))}return this.config.joins.push({on:Z,table:$,joinType:X,alias:Y}),this}}leftJoin=this.createJoin("left");rightJoin=this.createJoin("right");innerJoin=this.createJoin("inner");fullJoin=this.createJoin("full");where(X){return this.config.where=X,this}orderBy(...X){if(typeof X[0]==="function"){let $=X[0](new Proxy(this.config.table[F.Symbol.Columns],new d({sqlAliasedBehavior:"alias",sqlBehavior:"sql"}))),Z=Array.isArray($)?$:[$];this.config.orderBy=Z}else{let $=X;this.config.orderBy=$}return this}limit(X){return this.config.limit=X,this}returning(X=this.config.table[m.Symbol.Columns]){return this.config.returning=W1(X),this}getSQL(){return this.dialect.buildUpdateQuery(this.config)}toSQL(){let{typings:X,...$}=this.dialect.sqlToQuery(this.getSQL());return $}_prepare(X=!0){return this.session[X?"prepareOneTimeQuery":"prepareQuery"](this.dialect.sqlToQuery(this.getSQL()),this.config.returning,this.config.returning?"all":"run",!0,void 0,{type:"insert",tables:R1(this.config.table)})}prepare(){return this._prepare(!1)}run=(X)=>{return this._prepare().run(X)};all=(X)=>{return this._prepare().all(X)};get=(X)=>{return this._prepare().get(X)};values=(X)=>{return this._prepare().values(X)};async execute(){return this.config.returning?this.all():this.run()}$dynamic(){return this}}class F0 extends R{constructor(X){super(F0.buildEmbeddedCount(X.source,X.filters).queryChunks);this.params=X,this.session=X.session,this.sql=F0.buildCount(X.source,X.filters)}sql;static[O]="SQLiteCountBuilderAsync";[Symbol.toStringTag]="SQLiteCountBuilderAsync";session;static buildEmbeddedCount(X,$){return A`(select count(*) from ${X}${A.raw(" where ").if($)}${$})`}static buildCount(X,$){return A`select count(*) from ${X}${A.raw(" where ").if($)}${$}`}then(X,$){return Promise.resolve(this.session.count(this.sql)).then(X,$)}catch(X){return this.then(void 0,X)}finally(X){return this.then(($)=>{return X?.(),$},($)=>{throw X?.(),$})}}class H4{constructor(X,$,Z,Y,G,J,_,W){this.mode=X,this.fullSchema=$,this.schema=Z,this.tableNamesMap=Y,this.table=G,this.tableConfig=J,this.dialect=_,this.session=W}static[O]="SQLiteAsyncRelationalQueryBuilder";findMany(X){return this.mode==="sync"?new W4(this.fullSchema,this.schema,this.tableNamesMap,this.table,this.tableConfig,this.dialect,this.session,X?X:{},"many"):new a0(this.fullSchema,this.schema,this.tableNamesMap,this.table,this.tableConfig,this.dialect,this.session,X?X:{},"many")}findFirst(X){return this.mode==="sync"?new W4(this.fullSchema,this.schema,this.tableNamesMap,this.table,this.tableConfig,this.dialect,this.session,X?{...X,limit:1}:{limit:1},"first"):new a0(this.fullSchema,this.schema,this.tableNamesMap,this.table,this.tableConfig,this.dialect,this.session,X?{...X,limit:1}:{limit:1},"first")}}class a0 extends a{constructor(X,$,Z,Y,G,J,_,W,z){super();this.fullSchema=X,this.schema=$,this.tableNamesMap=Z,this.table=Y,this.tableConfig=G,this.dialect=J,this.session=_,this.config=W,this.mode=z}static[O]="SQLiteAsyncRelationalQuery";mode;getSQL(){return this.dialect.buildRelationalQuery({fullSchema:this.fullSchema,schema:this.schema,tableNamesMap:this.tableNamesMap,table:this.table,tableConfig:this.tableConfig,queryConfig:this.config,tableAlias:this.tableConfig.tsName}).sql}_prepare(X=!1){let{query:$,builtQuery:Z}=this._toSQL();return this.session[X?"prepareOneTimeQuery":"prepareQuery"](Z,void 0,this.mode==="first"?"get":"all",!0,(Y,G)=>{let J=Y.map((_)=>T0(this.schema,this.tableConfig,_,$.selection,G));if(this.mode==="first")return J[0];return J})}prepare(){return this._prepare(!1)}_toSQL(){let X=this.dialect.buildRelationalQuery({fullSchema:this.fullSchema,schema:this.schema,tableNamesMap:this.tableNamesMap,table:this.table,tableConfig:this.tableConfig,queryConfig:this.config,tableAlias:this.tableConfig.tsName}),$=this.dialect.sqlToQuery(X.sql);return{query:X,builtQuery:$}}toSQL(){return this._toSQL().builtQuery}executeRaw(){if(this.mode==="first")return this._prepare(!1).get();return this._prepare(!1).all()}async execute(){return this.executeRaw()}}class W4 extends a0{static[O]="SQLiteSyncRelationalQuery";sync(){return this.executeRaw()}}class q2 extends a{constructor(X,$,Z,Y,G){super();this.execute=X,this.getSQL=$,this.dialect=Y,this.mapBatchResult=G,this.config={action:Z}}static[O]="SQLiteRaw";config;getQuery(){return{...this.dialect.sqlToQuery(this.getSQL()),method:this.config.action}}mapResult(X,$){return $?this.mapBatchResult(X):X}_prepare(){return this}isResponseInArrayMode(){return!1}}class R0{constructor(X,$,Z,Y){this.resultKind=X,this.dialect=$,this.session=Z,this._=Y?{schema:Y.schema,fullSchema:Y.fullSchema,tableNamesMap:Y.tableNamesMap}:{schema:void 0,fullSchema:{},tableNamesMap:{}},this.query={};let G=this.query;if(this._.schema)for(let[J,_]of Object.entries(this._.schema))G[J]=new H4(X,Y.fullSchema,this._.schema,this._.tableNamesMap,Y.fullSchema[J],_,$,Z);this.$cache={invalidate:async(J)=>{}}}static[O]="BaseSQLiteDatabase";query;$with=(X,$)=>{let Z=this;return{as:(G)=>{if(typeof G==="function")G=G(new D0(Z.dialect));return new Proxy(new y2(G.getSQL(),$??("getSelectedFields"in G?G.getSelectedFields()??{}:{}),X,!0),new d({alias:X,sqlAliasedBehavior:"alias",sqlBehavior:"error"}))}}};$count(X,$){return new F0({source:X,filters:$,session:this.session})}with(...X){let $=this;function Z(W){return new V1({fields:W??void 0,session:$.session,dialect:$.dialect,withList:X})}function Y(W){return new V1({fields:W??void 0,session:$.session,dialect:$.dialect,withList:X,distinct:!0})}function G(W){return new l0(W,$.session,$.dialect,X)}function J(W){return new r0(W,$.session,$.dialect,X)}function _(W){return new s0(W,$.session,$.dialect,X)}return{select:Z,selectDistinct:Y,update:G,insert:J,delete:_}}select(X){return new V1({fields:X??void 0,session:this.session,dialect:this.dialect})}selectDistinct(X){return new V1({fields:X??void 0,session:this.session,dialect:this.dialect,distinct:!0})}update(X){return new l0(X,this.session,this.dialect)}$cache;insert(X){return new r0(X,this.session,this.dialect)}delete(X){return new s0(X,this.session,this.dialect)}run(X){let $=typeof X==="string"?A.raw(X):X.getSQL();if(this.resultKind==="async")return new q2(async()=>this.session.run($),()=>$,"run",this.dialect,this.session.extractRawRunValueFromBatchResult.bind(this.session));return this.session.run($)}all(X){let $=typeof X==="string"?A.raw(X):X.getSQL();if(this.resultKind==="async")return new q2(async()=>this.session.all($),()=>$,"all",this.dialect,this.session.extractRawAllValueFromBatchResult.bind(this.session));return this.session.all($)}get(X){let $=typeof X==="string"?A.raw(X):X.getSQL();if(this.resultKind==="async")return new q2(async()=>this.session.get($),()=>$,"get",this.dialect,this.session.extractRawGetValueFromBatchResult.bind(this.session));return this.session.get($)}values(X){let $=typeof X==="string"?A.raw(X):X.getSQL();if(this.resultKind==="async")return new q2(async()=>this.session.values($),()=>$,"values",this.dialect,this.session.extractRawValuesValueFromBatchResult.bind(this.session));return this.session.values($)}transaction(X,$){return this.session.transaction(X,$)}}class XZ{static[O]="Cache"}class V0 extends XZ{strategy(){return"all"}static[O]="NoopCache";async get(X){return}async put(X,$,Z,Y){}async onMutate(X){}}async function z4(X,$){let Z=`${X}-${JSON.stringify($)}`,G=new TextEncoder().encode(Z),J=await crypto.subtle.digest("SHA-256",G);return[...new Uint8Array(J)].map((z)=>z.toString(16).padStart(2,"0")).join("")}class $Z extends a{constructor(X){super();this.resultCb=X}static[O]="ExecuteResultSync";async execute(){return this.resultCb()}sync(){return this.resultCb()}}class A4{constructor(X,$,Z,Y,G,J){if(this.mode=X,this.executeMethod=$,this.query=Z,this.cache=Y,this.queryMetadata=G,this.cacheConfig=J,Y&&Y.strategy()==="all"&&J===void 0)this.cacheConfig={enable:!0,autoInvalidate:!0};if(!this.cacheConfig?.enable)this.cacheConfig=void 0}static[O]="PreparedQuery";joinsNotNullableMap;async queryWithCache(X,$,Z){if(this.cache===void 0||U(this.cache,V0)||this.queryMetadata===void 0)try{return await Z()}catch(Y){throw new k1(X,$,Y)}if(this.cacheConfig&&!this.cacheConfig.enable)try{return await Z()}catch(Y){throw new k1(X,$,Y)}if((this.queryMetadata.type==="insert"||this.queryMetadata.type==="update"||this.queryMetadata.type==="delete")&&this.queryMetadata.tables.length>0)try{let[Y]=await Promise.all([Z(),this.cache.onMutate({tables:this.queryMetadata.tables})]);return Y}catch(Y){throw new k1(X,$,Y)}if(!this.cacheConfig)try{return await Z()}catch(Y){throw new k1(X,$,Y)}if(this.queryMetadata.type==="select"){let Y=await this.cache.get(this.cacheConfig.tag??await z4(X,$),this.queryMetadata.tables,this.cacheConfig.tag!==void 0,this.cacheConfig.autoInvalidate);if(Y===void 0){let G;try{G=await Z()}catch(J){throw new k1(X,$,J)}return await this.cache.put(this.cacheConfig.tag??await z4(X,$),G,this.cacheConfig.autoInvalidate?this.queryMetadata.tables:[],this.cacheConfig.tag!==void 0,this.cacheConfig.config),G}return Y}try{return await Z()}catch(Y){throw new k1(X,$,Y)}}getQuery(){return this.query}mapRunResult(X,$){return X}mapAllResult(X,$){throw Error("Not implemented")}mapGetResult(X,$){throw Error("Not implemented")}execute(X){if(this.mode==="async")return this[this.executeMethod](X);return new $Z(()=>this[this.executeMethod](X))}mapResult(X,$){switch(this.executeMethod){case"run":return this.mapRunResult(X,$);case"all":return this.mapAllResult(X,$);case"get":return this.mapGetResult(X,$)}}}class O4{constructor(X){this.dialect=X}static[O]="SQLiteSession";prepareOneTimeQuery(X,$,Z,Y,G,J,_){return this.prepareQuery(X,$,Z,Y,G,J,_)}run(X){let $=this.dialect.sqlToQuery(X);try{return this.prepareOneTimeQuery($,void 0,"run",!1).run()}catch(Z){throw new U2({cause:Z,message:`Failed to run the query '${$.sql}'`})}}extractRawRunValueFromBatchResult(X){return X}all(X){return this.prepareOneTimeQuery(this.dialect.sqlToQuery(X),void 0,"run",!1).all()}extractRawAllValueFromBatchResult(X){throw Error("Not implemented")}get(X){return this.prepareOneTimeQuery(this.dialect.sqlToQuery(X),void 0,"run",!1).get()}extractRawGetValueFromBatchResult(X){throw Error("Not implemented")}values(X){return this.prepareOneTimeQuery(this.dialect.sqlToQuery(X),void 0,"run",!1).values()}async count(X){return(await this.values(X))[0][0]}extractRawValuesValueFromBatchResult(X){throw Error("Not implemented")}}class U4 extends R0{constructor(X,$,Z,Y,G=0){super(X,$,Z,Y);this.schema=Y,this.nestedIndex=G}static[O]="SQLiteTransaction";rollback(){throw new N6}}class X6 extends O4{constructor(X,$,Z,Y,G){super($);this.client=X,this.schema=Z,this.options=Y,this.tx=G,this.logger=Y.logger??new x6,this.cache=Y.cache??new V0}static[O]="LibSQLSession";logger;cache;prepareQuery(X,$,Z,Y,G,J,_){return new YZ(this.client,X,this.logger,this.cache,J,_,$,this.tx,Z,Y,G)}async batch(X){let $=[],Z=[];for(let G of X){let J=G._prepare(),_=J.getQuery();$.push(J),Z.push({sql:_.sql,args:_.params})}return(await this.client.batch(Z)).map((G,J)=>$[J].mapResult(G,!0))}async migrate(X){let $=[],Z=[];for(let G of X){let J=G._prepare(),_=J.getQuery();$.push(J),Z.push({sql:_.sql,args:_.params})}return(await this.client.migrate(Z)).map((G,J)=>$[J].mapResult(G,!0))}async transaction(X,$){let Z=await this.client.transaction(),Y=new X6(this.client,this.dialect,this.schema,this.options,Z),G=new D4("async",this.dialect,Y,this.schema);try{let J=await X(G);return await Z.commit(),J}catch(J){throw await Z.rollback(),J}}extractRawAllValueFromBatchResult(X){return X.rows}extractRawGetValueFromBatchResult(X){return X.rows[0]}extractRawValuesValueFromBatchResult(X){return X.rows}}class D4 extends U4{static[O]="LibSQLTransaction";async transaction(X){let $=`sp${this.nestedIndex}`,Z=new D4("async",this.dialect,this.session,this.schema,this.nestedIndex+1);await this.session.run(A.raw(`savepoint ${$}`));try{let Y=await X(Z);return await this.session.run(A.raw(`release savepoint ${$}`)),Y}catch(Y){throw await this.session.run(A.raw(`rollback to savepoint ${$}`)),Y}}}class YZ extends A4{constructor(X,$,Z,Y,G,J,_,W,z,H,D){super("async",z,$,Y,G,J);this.client=X,this.logger=Z,this.fields=_,this.tx=W,this._isResponseInArrayMode=H,this.customResultMapper=D,this.customResultMapper=D,this.fields=_}static[O]="LibSQLPreparedQuery";async run(X){let $=g2(this.query.params,X??{});return this.logger.logQuery(this.query.sql,$),await this.queryWithCache(this.query.sql,$,async()=>{let Z={sql:this.query.sql,args:$};return this.tx?this.tx.execute(Z):this.client.execute(Z)})}async all(X){let{fields:$,logger:Z,query:Y,tx:G,client:J,customResultMapper:_}=this;if(!$&&!_){let z=g2(Y.params,X??{});return Z.logQuery(Y.sql,z),await this.queryWithCache(Y.sql,z,async()=>{let H={sql:Y.sql,args:z};return(G?G.execute(H):J.execute(H)).then(({rows:D})=>this.mapAllResult(D))})}let W=await this.values(X);return this.mapAllResult(W)}mapAllResult(X,$){if($)X=X.rows;if(!this.fields&&!this.customResultMapper)return X.map((Z)=>ZZ(Z));if(this.customResultMapper)return this.customResultMapper(X,e0);return X.map((Z)=>{return P6(this.fields,Array.prototype.slice.call(Z).map((Y)=>e0(Y)),this.joinsNotNullableMap)})}async get(X){let{fields:$,logger:Z,query:Y,tx:G,client:J,customResultMapper:_}=this;if(!$&&!_){let z=g2(Y.params,X??{});return Z.logQuery(Y.sql,z),await this.queryWithCache(Y.sql,z,async()=>{let H={sql:Y.sql,args:z};return(G?G.execute(H):J.execute(H)).then(({rows:D})=>this.mapGetResult(D))})}let W=await this.values(X);return this.mapGetResult(W)}mapGetResult(X,$){if($)X=X.rows;let Z=X[0];if(!this.fields&&!this.customResultMapper)return ZZ(Z);if(!Z)return;if(this.customResultMapper)return this.customResultMapper(X,e0);return P6(this.fields,Array.prototype.slice.call(Z).map((Y)=>e0(Y)),this.joinsNotNullableMap)}async values(X){let $=g2(this.query.params,X??{});return this.logger.logQuery(this.query.sql,$),await this.queryWithCache(this.query.sql,$,async()=>{let Z={sql:this.query.sql,args:$};return(this.tx?this.tx.execute(Z):this.client.execute(Z)).then(({rows:Y})=>Y)})}isResponseInArrayMode(){return this._isResponseInArrayMode}}function ZZ(X){return Object.keys(X).reduce(($,Z)=>{if(Object.prototype.propertyIsEnumerable.call(X,Z))$[Z]=X[Z];return $},{})}function e0(X){if(typeof ArrayBuffer<"u"&&X instanceof ArrayBuffer){if(typeof Buffer<"u"){if(!(X instanceof Buffer))return Buffer.from(X);return X}if(typeof TextDecoder<"u")return new TextDecoder().decode(X);throw Error("TextDecoder is not available. Please provide either Buffer or TextDecoder polyfill.")}return X}class GZ extends R0{static[O]="LibSQLDatabase";async batch(X){return this.session.batch(X)}}function S2(X,$={}){let Z=new Y4({casing:$.casing}),Y;if($.logger===!0)Y=new w6;else if($.logger!==!1)Y=$.logger;let G;if($.schema){let W=F8($.schema,V8);G={fullSchema:$.schema,schema:W.tables,tableNamesMap:W.tableNamesMap}}let J=new X6(X,Z,G,{logger:Y,cache:$.cache},void 0),_=new GZ("async",Z,J,G);if(_.$client=X,_.$cache=$.cache,_.$cache)_.$cache.invalidate=$.cache?.onMutate;return _}function $6(...X){if(typeof X[0]==="string"){let $=C2({url:X[0]});return S2($,X[1])}if(u4(X[0])){let{connection:$,client:Z,...Y}=X[0];if(Z)return S2(Z,Y);let G=typeof $==="string"?C2({url:$}):C2($);return S2(G,Y)}return S2(X[0],X[1])}((X)=>{function $(Z){return S2({},Z)}X.mock=$})($6||($6={}));class I0{client;db;dbName;constructor(X,$){this.dbName=X;try{let Z=K0.join(process.cwd(),".sylphx-flow");if(!Z6.existsSync(Z))Z6.mkdirSync(Z,{recursive:!0});let Y=K0.join(Z,`${X}.db`);this.client=C2({url:`file:${Y}`}),this.db=$6(this.client,{schema:$})}catch(Z){throw new k6(`Failed to initialize ${X} database connection`,{url:`file:${K0.join(process.cwd(),".sylphx-flow",`${X}.db`)}`},Z)}}async close(){}getDatabasePath(){return K0.join(process.cwd(),".sylphx-flow",`${this.dbName}.db`)}async createTable(X){try{await this.client.execute(X)}catch($){throw new s(`Failed to create table for ${this.dbName}`,`${this.dbName}.createTable`,$)}}async createIndex(X){try{await this.client.execute(X)}catch($){throw new s(`Failed to create index for ${this.dbName}`,`${this.dbName}.createIndex`,$)}}async tableExists(X){try{return(await this.client.execute(`
        SELECT name FROM sqlite_master 
        WHERE type='table' AND name='${X}'
      `)).rows.length>0}catch($){throw new s(`Failed to check if table ${X} exists`,`${this.dbName}.tableExists`,$)}}}var F4={};JZ(F4,{tfidfTerms:()=>O1,tfidfIdf:()=>B1,tfidfDocuments:()=>P1,codebaseMetadata:()=>G1,codebaseFiles:()=>r});var r=r1("codebase_files_table",{path:p("path").primaryKey(),mtime:t1("mtime").notNull(),hash:p("hash").notNull(),content:p("content"),language:p("language"),size:t1("size"),indexedAt:p("indexed_at").notNull()},(X)=>[S1("idx_codebase_files_mtime").on(X.mtime),S1("idx_codebase_files_hash").on(X.hash)]),G1=r1("codebase_metadata_table",{key:p("key").primaryKey(),value:p("value").notNull()}),O1=r1("tfidf_terms_table",{filePath:p("file_path").notNull().references(()=>r.path,{onDelete:"cascade"}),term:p("term").notNull(),frequency:v2("frequency").notNull()},(X)=>[i0({columns:[X.filePath,X.term]}),S1("idx_tfidf_terms_term").on(X.term),S1("idx_tfidf_terms_file").on(X.filePath)]),P1=r1("tfidf_documents_table",{filePath:p("file_path").primaryKey().references(()=>r.path,{onDelete:"cascade"}),magnitude:v2("magnitude").notNull(),termCount:t1("term_count").notNull(),rawTerms:p("raw_terms").notNull()}),B1=r1("tfidf_idf_table",{term:p("term").primaryKey(),idfValue:v2("idf_value").notNull()});class V4 extends I0{constructor(){super("cache",F4)}async initialize(){try{if((await this.getMigrationStatus()).isMigrated){console.error("[INFO] Cache database tables already exist");return}await this.createTables(),console.error("[INFO] Cache database tables created")}catch(X){throw new s("Failed to initialize cache database","cache.initialize",X)}}async createTables(){await this.createTable(`
      CREATE TABLE IF NOT EXISTS codebase_files_table (
        path TEXT PRIMARY KEY,
        mtime INTEGER NOT NULL,
        hash TEXT NOT NULL,
        content TEXT,
        language TEXT,
        size INTEGER,
        indexed_at TEXT NOT NULL
      )
    `),await this.createTable(`
      CREATE TABLE IF NOT EXISTS codebase_metadata_table (
        key TEXT PRIMARY KEY,
        value TEXT NOT NULL
      )
    `),await this.createTable(`
      CREATE TABLE IF NOT EXISTS tfidf_documents_table (
        file_path TEXT PRIMARY KEY,
        magnitude REAL NOT NULL,
        term_count INTEGER NOT NULL,
        raw_terms TEXT NOT NULL,
        FOREIGN KEY (file_path) REFERENCES codebase_files_table(path) ON DELETE CASCADE
      )
    `),await this.createTable(`
      CREATE TABLE IF NOT EXISTS tfidf_idf_table (
        term TEXT PRIMARY KEY,
        idf_value REAL NOT NULL
      )
    `),await this.createTable(`
      CREATE TABLE IF NOT EXISTS tfidf_terms_table (
        file_path TEXT NOT NULL,
        term TEXT NOT NULL,
        frequency REAL NOT NULL,
        PRIMARY KEY (file_path, term),
        FOREIGN KEY (file_path) REFERENCES codebase_files_table(path) ON DELETE CASCADE
      )
    `),await this.createIndex(`
      CREATE INDEX IF NOT EXISTS idx_codebase_files_mtime ON codebase_files_table (mtime)
    `),await this.createIndex(`
      CREATE INDEX IF NOT EXISTS idx_codebase_files_hash ON codebase_files_table (hash)
    `),await this.createIndex(`
      CREATE INDEX IF NOT EXISTS idx_tfidf_terms_term ON tfidf_terms_table (term)
    `),await this.createIndex(`
      CREATE INDEX IF NOT EXISTS idx_tfidf_terms_file ON tfidf_terms_table (file_path)
    `)}async getMigrationStatus(){try{let X=["codebase_files_table","tfidf_terms_table","tfidf_documents_table"],$=0;for(let Z of X)if(await this.tableExists(Z))$++;return{isMigrated:$>=2,migrationCount:$}}catch(X){throw new s("Failed to check cache database migration status","cache.getMigrationStatus",X)}}async clearCache(){try{await this.client.execute("DELETE FROM tfidf_terms_table"),await this.client.execute("DELETE FROM tfidf_documents_table"),await this.client.execute("DELETE FROM tfidf_idf_table"),await this.client.execute("DELETE FROM codebase_files_table"),await this.client.execute("DELETE FROM codebase_metadata_table"),console.error("[INFO] Cache database cleared")}catch(X){throw new s("Failed to clear cache database","cache.clearCache",X)}}async healthCheck(){try{await this.client.execute("SELECT 1");let X=await this.getMigrationStatus(),$=await this.client.execute(`
        SELECT count(*) as count FROM codebase_files_table
      `);return{healthy:!0,details:{tablesExist:X.isMigrated,tableCount:X.migrationCount,cachedFiles:$.rows[0]?.count||0}}}catch(X){return{healthy:!1,error:X.message}}}async close(){}getDatabasePath(){let X=R4.join(process.cwd(),".sylphx-flow");return R4.join(X,"cache.db")}}class K4{cacheDb;cache;constructor(){this.cacheDb=new V4,this.cache=this.cacheDb.db}async initialize(){await this.cacheDb.initialize()}async setCodebaseFile(X){return v(`set codebase file: ${X.path}`,async()=>{await this.cache.insert(r).values(X).onConflictDoUpdate({target:r.path,set:{mtime:X.mtime,hash:X.hash,content:X.content,language:X.language,size:X.size,indexedAt:X.indexedAt}})})}async getCodebaseFile(X){return v(`get codebase file: ${X}`,async()=>{let $=await this.cache.select().from(r).where(T(r.path,X)).limit(1);if($.length===0)return null;let Z=$[0];return{path:Z.path,mtime:Z.mtime,hash:Z.hash,content:Z.content||void 0,language:Z.language||void 0,size:Z.size||void 0,indexedAt:Z.indexedAt}})}async getAllCodebaseFiles(){return v("get all codebase files",async()=>{return(await this.cache.select().from(r).orderBy(e1(r.mtime))).map(($)=>({path:$.path,mtime:$.mtime,hash:$.hash,content:$.content||void 0,language:$.language||void 0,size:$.size||void 0,indexedAt:$.indexedAt}))})}async deleteCodebaseFile(X){return v(`delete codebase file: ${X}`,async()=>{let $=await this.cache.delete(r).where(T(r.path,X));return(await this.cache.select().from(r).where(T(r.path,X)).limit(1)).length===0})}async clearCodebaseFiles(){return v("clear codebase files",async()=>{await this.cache.delete(r)})}async setMetadata(X,$){return v(`set metadata: ${X}`,async()=>{await this.cache.insert(G1).values({key:X,value:$}).onConflictDoUpdate({target:G1.key,set:{value:$}})})}async getMetadata(X){return v(`get metadata: ${X}`,async()=>{let $=await this.cache.select().from(G1).where(T(G1.key,X)).limit(1);return $.length>0?$[0].value:null})}async getAllMetadata(){return v("get all metadata",async()=>{let X=await this.cache.select().from(G1),$={};for(let Z of X)$[Z.key]=Z.value;return $})}async deleteMetadata(X){return v(`delete metadata: ${X}`,async()=>{let $=await this.cache.delete(G1).where(T(G1.key,X));return(await this.cache.select().from(G1).where(T(G1.key,X)).limit(1)).length===0})}async setTfidfTerms(X){return v("set TF-IDF terms",async()=>{let $=[...new Set(X.map((Z)=>Z.filePath))];for(let Z of $)await this.cache.delete(O1).where(T(O1.filePath,Z));if(X.length>0)await this.cache.insert(O1).values(X)})}async getTfidfTerms(X){return v(`get TF-IDF terms for file: ${X}`,async()=>{return(await this.cache.select().from(O1).where(T(O1.filePath,X))).map((Z)=>({filePath:Z.filePath,term:Z.term,frequency:Z.frequency}))})}async getTfidfTermsByTerm(X){return v(`get TF-IDF terms by term: ${X}`,async()=>{return(await this.cache.select().from(O1).where(T(O1.term,X))).map((Z)=>({filePath:Z.filePath,term:Z.term,frequency:Z.frequency}))})}async clearTfidfTerms(){return v("clear TF-IDF terms",async()=>{await this.cache.delete(O1)})}async setTfidfDocument(X){return v(`set TF-IDF document: ${X.filePath}`,async()=>{await this.cache.insert(P1).values(X).onConflictDoUpdate({target:P1.filePath,set:{magnitude:X.magnitude,termCount:X.termCount,rawTerms:X.rawTerms}})})}async getTfidfDocument(X){return v(`get TF-IDF document: ${X}`,async()=>{let $=await this.cache.select().from(P1).where(T(P1.filePath,X)).limit(1);if($.length===0)return null;let Z=$[0];return{filePath:Z.filePath,magnitude:Z.magnitude,termCount:Z.termCount,rawTerms:Z.rawTerms}})}async getAllTfidfDocuments(){return v("get all TF-IDF documents",async()=>{return(await this.cache.select().from(P1)).map(($)=>({filePath:$.filePath,magnitude:$.magnitude,termCount:$.termCount,rawTerms:$.rawTerms}))})}async clearTfidfDocuments(){return v("clear TF-IDF documents",async()=>{await this.cache.delete(P1)})}async setTfidfIdf(X){return v(`set TF-IDF IDF: ${X.term}`,async()=>{await this.cache.insert(B1).values(X).onConflictDoUpdate({target:B1.term,set:{idfValue:X.idfValue}})})}async getTfidfIdf(X){return v(`get TF-IDF IDF: ${X}`,async()=>{let $=await this.cache.select().from(B1).where(T(B1.term,X)).limit(1);if($.length===0)return null;let Z=$[0];return{term:Z.term,idfValue:Z.idfValue}})}async getAllTfidfIdf(){return v("get all TF-IDF IDF values",async()=>{return(await this.cache.select().from(B1)).map(($)=>({term:$.term,idfValue:$.idfValue}))})}async clearTfidfIdf(){return v("clear TF-IDF IDF values",async()=>{await this.cache.delete(B1)})}async getStats(){return v("get cache statistics",async()=>{let[X,$,Z,Y,G]=await Promise.all([this.cache.select({count:g1()}).from(r),this.cache.select({count:g1()}).from(G1),this.cache.select({count:g1()}).from(O1),this.cache.select({count:g1()}).from(P1),this.cache.select({count:g1()}).from(B1)]);return{codebaseFiles:X[0]?.count||0,metadataEntries:$[0]?.count||0,tfidfTerms:Z[0]?.count||0,tfidfDocuments:Y[0]?.count||0,tfidfIdfValues:G[0]?.count||0}})}async clearAll(){return v("clear all cache data",async()=>{await Promise.all([this.cache.delete(r),this.cache.delete(G1),this.cache.delete(O1),this.cache.delete(P1),this.cache.delete(B1)])})}}import*as Y6 from"node:path";var I4={};JZ(I4,{memory:()=>B});var B=r1("memory_table",{key:p("key").notNull(),namespace:p("namespace").notNull().default("default"),value:p("value").notNull(),timestamp:t1("timestamp").notNull(),created_at:p("created_at").notNull(),updated_at:p("updated_at").notNull()},(X)=>[i0({columns:[X.key,X.namespace]}),S1("idx_memory_namespace").on(X.namespace),S1("idx_memory_timestamp").on(X.timestamp),S1("idx_memory_key").on(X.key)]);class E4 extends I0{constructor(){super("memory",I4)}async initialize(){try{if((await this.getMigrationStatus()).isMigrated){console.error("[INFO] Memory database tables already exist");return}let $=Y6.join(process.cwd(),"drizzle","memory");await this.createTables(),console.error("[INFO] Memory database tables created")}catch(X){throw new s("Failed to initialize memory database","memory.initialize",X)}}async createTables(){await this.createTable(`
        CREATE TABLE IF NOT EXISTS memory_table (
          key TEXT NOT NULL,
          namespace TEXT NOT NULL DEFAULT 'default',
          value TEXT NOT NULL,
          timestamp INTEGER NOT NULL,
          created_at TEXT NOT NULL,
          updated_at TEXT NOT NULL,
          PRIMARY KEY (key, namespace)
        )
      `),await this.createIndex(`
        CREATE INDEX IF NOT EXISTS idx_memory_namespace ON memory_table (namespace)
      `),await this.createIndex(`
        CREATE INDEX IF NOT EXISTS idx_memory_timestamp ON memory_table (timestamp)
      `),await this.createIndex(`
        CREATE INDEX IF NOT EXISTS idx_memory_key ON memory_table (key)
      `)}async getMigrationStatus(){try{let X=await this.tableExists("memory_table");return{isMigrated:X,migrationCount:X?1:0}}catch(X){throw new s("Failed to check memory database migration status","memory.getMigrationStatus",X)}}async healthCheck(){try{await this.client.execute("SELECT 1");let X=await this.getMigrationStatus(),$=await this.client.execute(`
        SELECT count(*) as count FROM memory_table
      `);return{healthy:!0,details:{tablesExist:X.isMigrated,memoryEntries:$.rows[0]?.count||0}}}catch(X){return{healthy:!1,error:X.message}}}async close(){}getDatabasePath(){let X=Y6.join(process.cwd(),".sylphx-flow");return Y6.join(X,"memory.db")}}class M4{memoryDb;memory;constructor(){this.memoryDb=new E4,this.memory=this.memoryDb.db}async initialize(){await this.memoryDb.initialize()}safeSerialize(X){try{return JSON.stringify(X)}catch($){throw Error(`Failed to serialize value: ${$.message}`)}}safeDeserialize(X){try{return JSON.parse(X)}catch($){throw Error(`Failed to deserialize value: ${$.message}`)}}async set(X,$,Z="default"){let Y=`Failed to set memory entry: ${Z}:${X}`;try{let G=new Date().toISOString(),J=Date.now(),_=this.safeSerialize($);if((await this.memory.select().from(B).where(H1(T(B.key,X),T(B.namespace,Z))).limit(1)).length>0)await this.memory.update(B).set({value:_,timestamp:J,updated_at:G}).where(H1(T(B.key,X),T(B.namespace,Z)));else await this.memory.insert(B).values({key:X,namespace:Z,value:_,timestamp:J,created_at:G,updated_at:G})}catch(G){throw Error(`${Y}: ${G.message}`)}}async get(X,$="default"){let Z=`Failed to get memory entry: ${$}:${X}`;try{let Y=await this.memory.select().from(B).where(H1(T(B.key,X),T(B.namespace,$))).limit(1);if(Y.length===0)return null;let G=Y[0];return{key:G.key,namespace:G.namespace,value:this.safeDeserialize(G.value),timestamp:G.timestamp,created_at:G.created_at,updated_at:G.updated_at}}catch(Y){throw Error(`${Z}: ${Y.message}`)}}async getAll(X){try{let Z=this.memory.select().from(B);if(X&&X!=="all")Z=Z.where(T(B.namespace,X));return(await Z.orderBy(e1(B.timestamp))).map((G)=>({key:G.key,namespace:G.namespace,value:this.safeDeserialize(G.value),timestamp:G.timestamp,created_at:G.created_at,updated_at:G.updated_at}))}catch(Z){throw Error(`Failed to get all memory entries: ${Z.message}`)}}async search(X,$){let Z=`Failed to search memory entries: ${X}`;try{let Y=this.memory.select().from(B).where(c2(a1(B.key,`%${X}%`),a1(B.value,`%${X}%`)));if($&&$!=="all")Y=Y.where(H1(T(B.namespace,$),c2(a1(B.key,`%${X}%`),a1(B.value,`%${X}%`))));return(await Y.orderBy(e1(B.timestamp))).map((J)=>({key:J.key,namespace:J.namespace,value:this.safeDeserialize(J.value),timestamp:J.timestamp,created_at:J.created_at,updated_at:J.updated_at}))}catch(Y){throw Error(`${Z}: ${Y.message}`)}}async delete(X,$="default"){let Z=`Failed to delete memory entry: ${$}:${X}`;try{let Y=await this.memory.delete(B).where(H1(T(B.key,X),T(B.namespace,$)));return(await this.memory.select().from(B).where(H1(T(B.key,X),T(B.namespace,$))).limit(1)).length===0}catch(Y){throw Error(`${Z}: ${Y.message}`)}}async clear(X="default"){let $=`Failed to clear memory namespace: ${X}`;try{await this.memory.delete(B).where(T(B.namespace,X))}catch(Z){throw Error(`${$}: ${Z.message}`)}}async getStats(X){try{let Z=this.memory.select({count:g1()}).from(B);if(X&&X!=="all")Z=Z.where(T(B.namespace,X));let G=(await Z)[0]?.count||0,_=(await this.memory.selectDistinct({namespace:B.namespace}).from(B)).map((W)=>W.namespace);return{totalEntries:G,namespaces:_}}catch(Z){throw Error(`Failed to get memory statistics: ${Z.message}`)}}}class N4{memoryStorage;cacheStorage;constructor(){this.memoryStorage=new M4,this.cacheStorage=new K4}async initialize(){await Promise.all([this.memoryStorage.initialize(),this.cacheStorage.initialize()])}async set(X,$,Z="default"){return this.memoryStorage.set(X,$,Z)}async get(X,$="default"){return this.memoryStorage.get(X,$)}async getAll(X){return this.memoryStorage.getAll(X)}async search(X,$){return this.memoryStorage.search(X,$)}async delete(X,$="default"){return this.memoryStorage.delete(X,$)}async clear(X="default"){return this.memoryStorage.clear(X)}async getStats(X){return this.memoryStorage.getStats(X)}async setCodebaseFile(X,$,Z,Y,G,J){let _=new Date().toISOString();return this.cacheStorage.setCodebaseFile({path:X,mtime:$,hash:Z,content:Y,language:G,size:J,indexedAt:_})}async getCodebaseFile(X){return this.cacheStorage.getCodebaseFile(X)}async getAllCodebaseFiles(){return this.cacheStorage.getAllCodebaseFiles()}async deleteCodebaseFile(X){return this.cacheStorage.deleteCodebaseFile(X)}async clearCodebaseFiles(){return this.cacheStorage.clearCodebaseFiles()}async setMetadata(X,$){return this.cacheStorage.setMetadata(X,$)}async getMetadata(X){return this.cacheStorage.getMetadata(X)}async getAllMetadata(){return this.cacheStorage.getAllMetadata()}async deleteMetadata(X){return this.cacheStorage.deleteMetadata(X)}async setTfidfTerms(X){return this.cacheStorage.setTfidfTerms(X)}async getTfidfTerms(X){return this.cacheStorage.getTfidfTerms(X)}async getTfidfTermsByTerm(X){return this.cacheStorage.getTfidfTermsByTerm(X)}async clearTfidfTerms(){return this.cacheStorage.clearTfidfTerms()}async setTfidfDocument(X,$,Z,Y){return this.cacheStorage.setTfidfDocument({filePath:X,magnitude:$,termCount:Z,rawTerms:Y})}async getTFIDFDocument(X){return this.cacheStorage.getTfidfDocument(X)}async getAllTfidfDocuments(){return this.cacheStorage.getAllTfidfDocuments()}async clearTfidfDocuments(){return this.cacheStorage.clearTfidfDocuments()}async setTfidfIdf(X,$){return this.cacheStorage.setTfidfIdf({term:X,idfValue:$})}async getTfidfIdf(X){return this.cacheStorage.getTfidfIdf(X)}async getAllTfidfIdf(){return this.cacheStorage.getAllTfidfIdf()}async clearTfidfIdf(){return this.cacheStorage.clearTfidfIdf()}async getCacheStats(){return this.cacheStorage.getStats()}async clearAllCache(){return this.cacheStorage.clearAll()}async getAllStats(){let[X,$]=await Promise.all([this.memoryStorage.getStats(),this.cacheStorage.getStats()]);return{memory:X,cache:$}}async clearAll(){await Promise.all([this.memoryStorage.clear("default"),this.cacheStorage.clearAll()])}async getCodebaseIndexStats(){let X=await this.cacheStorage.getAllMetadata();return{indexedAt:X.indexedAt,totalFiles:Number.parseInt(X.totalFiles||"0"),totalTerms:Number.parseInt(X.totalTerms||"0")}}async getIDFValues(){return this.cacheStorage.getAllTfidfIdf()}async upsertTFIDFDocument(X,$){return this.cacheStorage.setTfidfDocument({filePath:X,magnitude:$.magnitude,termCount:$.termCount,rawTerms:JSON.stringify($.rawTerms)})}async upsertCodebaseFile(X){return this.cacheStorage.setCodebaseFile({...X,indexedAt:X.indexedAt||new Date().toISOString()})}async setIDFValues(X){let $=Object.entries(X).map(([Z,Y])=>this.cacheStorage.setTfidfIdf({term:Z,idfValue:Y}));await Promise.all($)}async clearCodebaseIndex(){await Promise.all([this.cacheStorage.clearCodebaseFiles(),this.cacheStorage.clearTfidfTerms(),this.cacheStorage.clearTfidfDocuments(),this.cacheStorage.clearTfidfIdf()])}async getCodebaseMetadata(X){return this.cacheStorage.getMetadata(X)}async setCodebaseMetadata(X,$){return this.cacheStorage.setMetadata(X,$)}async setTFIDFTerms(X,$){let Z=Object.entries($).map(([Y,G])=>({filePath:X,term:Y,frequency:G}));return this.cacheStorage.setTfidfTerms(Z)}}class _Z{memoryStorage;knowledgeIndexer=D6();embeddingProvider;constructor(){this.memoryStorage=new N4}async initialize(){if(await this.memoryStorage.initialize(),!this.embeddingProvider)this.embeddingProvider=await(await import("./embeddings-w1d56emg.js")).getDefaultEmbeddingProvider();this.knowledgeIndexer=D6(this.embeddingProvider)}async getStatus(){let X=await this.memoryStorage.getAllCodebaseFiles(),$=await this.memoryStorage.getCodebaseIndexStats(),Z=this.knowledgeIndexer.getStatus(),Y=!1,G=0;try{let J=await this.knowledgeIndexer.loadIndex();Y=!0,G=J.totalDocuments}catch{}return{codebase:{indexed:X.length>0,fileCount:X.length,indexedAt:$.indexedAt},knowledge:{indexed:Y,documentCount:G,isIndexing:Z.isIndexing,progress:Z.progress}}}async searchCodebase(X,$={}){let{limit:Z=10,include_content:Y=!0,file_extensions:G,path_filter:J,exclude_paths:_,min_score:W=0.1}=$,z=await this.memoryStorage.getAllCodebaseFiles();if(z.length===0)throw Error('Codebase not indexed yet. Run "sylphx search reindex" first.');let H=z;if(G?.length)H=H.filter((M)=>G.some((K)=>M.path.endsWith(K)));if(J)H=H.filter((M)=>M.path.includes(J));if(_?.length)H=H.filter((M)=>!_.some((K)=>M.path.includes(K)));if(H.length===0)return{results:[],totalIndexed:z.length,query:X};let D=await this.buildSearchIndex(H);if(!D)throw Error("No searchable content found");let V=await H6(X,D,{limit:Z,minScore:W}),I=[];for(let M of V){let K=M.uri?.replace("file://","")||"Unknown",w="";if(Y){let P=await this.memoryStorage.getCodebaseFile(K);if(P?.content){if(w=P.content.substring(0,500),P.content.length>500)w+="..."}}I.push({uri:M.uri,score:M.score||0,title:K.split("/").pop()||K,content:Y?w:void 0})}return{results:I,totalIndexed:z.length,query:X}}async searchKnowledge(X,$={}){let{limit:Z=10,include_content:Y=!0}=$;try{let G=await this.knowledgeIndexer.loadIndex();return{results:(await H6(X,G,{limit:Z})).map((W)=>({uri:W.uri,score:W.score||0,title:W.uri?.split("/").pop()||"Unknown",content:Y?"":void 0})),totalIndexed:G.totalDocuments,query:X}}catch{throw Error("Knowledge base not indexed yet")}}async buildSearchIndex(X){try{let $=[];for(let G of X){let J=await this.memoryStorage.getTFIDFDocument(G.path);if(J){let _=J.rawTerms||{},W=new Map,z=new Map;for(let[H,D]of Object.entries(_))W.set(H,D),z.set(H,D);$.push({uri:`file://${G.path}`,terms:W,rawTerms:z,magnitude:J.magnitude})}}if($.length===0)return null;let Z=await this.memoryStorage.getIDFValues(),Y=new Map;for(let G of Z)if(G.term&&G.idfValue!==void 0)Y.set(G.term,G.idfValue);return{documents:$,idf:Y,totalDocuments:$.length,metadata:{generatedAt:new Date().toISOString(),version:"1.0.0"}}}catch($){return console.error("[ERROR] Failed to build search index:",$),null}}formatResultsForCLI(X,$,Z){if(X.length===0)return`\uD83D\uDCED No results found for "${$}"

**Total indexed files:** ${Z}`;let Y=` Found ${X.length} result(s) for "${$}":

`,G=X.map((J,_)=>{let W=`${_+1}. **${J.title}** (Score: ${J.score.toFixed(3)})`;if(J.uri.startsWith("file://")){let z=J.uri.replace("file://","");W+=`
   \uD83D\uDCC1 Path: \`${z}\``}else if(J.uri.startsWith("knowledge://"))W+=`
   \uD83D\uDCDA Source: ${J.uri}`;else W+=`
   \uD83D\uDD17 URI: ${J.uri}`;if(J.content)W+=`
   \`\`\`
${J.content}
\`\`\``;return W}).join(`

`);return Y+G}formatResultsForMCP(X,$,Z){let Y=`Found ${X.length} result(s) for "${$}":

`,G=X.map((J,_)=>{let W=`${_+1}. **${J.title}** (Score: ${J.score.toFixed(3)})`;if(J.uri.startsWith("file://")){let z=J.uri.replace("file://","");W+=`
   \uD83D\uDCC1 Path: \`${z}\``}else if(J.uri.startsWith("knowledge://"))W+=`
   \uD83D\uDCDA URI: ${J.uri}`;else W+=`
   \uD83D\uDD17 URI: ${J.uri}`;if(J.content)W+=`
\`\`\`
${J.content}
\`\`\``;return W}).join(`

`);return{content:[{type:"text",text:Y+G}]}}async getAvailableKnowledgeURIs(){try{return(await this.knowledgeIndexer.loadIndex()).documents.map(($)=>$.uri)}catch{return[]}}}var vA=new _Z;
export{A as d,T as e,H1 as f,a1 as g,e1 as h,g1 as i,s as j,wZ as k,k6 as l,v as m,C2 as n,t1 as o,v2 as p,p as q,r1 as r,S1 as s,i0 as t,$6 as u,N4 as v,T4 as w,vA as x};
