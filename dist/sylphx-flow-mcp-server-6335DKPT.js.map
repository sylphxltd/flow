{"version":3,"sources":["../src/servers/sylphx-flow-mcp-server.ts"],"sourcesContent":["#!/usr/bin/env node\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\n\n// ============================================================================\n// CONFIGURATION AND SETUP\n// ============================================================================\n\ninterface MemoryEntry {\n  key: string;\n  namespace: string;\n  value: any;\n  timestamp: number;\n  created_at: string;\n  updated_at: string;\n}\n\nclass MemoryStorage {\n  private data: Map<string, MemoryEntry> = new Map();\n  private memoryDir: string;\n  private filePath: string;\n\n  constructor() {\n    this.memoryDir = path.join(process.cwd(), '.memory');\n    this.filePath = path.join(this.memoryDir, 'memory.json');\n    \n    // Ensure .memory directory exists\n    fs.mkdir(this.memoryDir, { recursive: true }).catch(() => {});\n    \n    // Load existing data\n    this.loadData();\n  }\n\n  private getFullKey(key: string, namespace: string): string {\n    return `${namespace}:${key}`;\n  }\n\n  private async loadData(): Promise<void> {\n    try {\n      const data = await fs.readFile(this.filePath, 'utf8');\n      const parsed = JSON.parse(data);\n      this.data = new Map(Object.entries(parsed));\n    } catch {\n      // File doesn't exist or is invalid, start with empty storage\n      this.data = new Map();\n    }\n  }\n\n  private async saveData(): Promise<void> {\n    try {\n      const data = Object.fromEntries(this.data);\n      await fs.writeFile(this.filePath, JSON.stringify(data, null, 2), 'utf8');\n    } catch (error) {\n      console.warn('Warning: Could not save memory data:', error);\n    }\n  }\n\n  set(key: string, value: any, namespace: string = 'default'): void {\n    const fullKey = this.getFullKey(key, namespace);\n    const now = new Date().toISOString();\n    const timestamp = Date.now();\n    \n    const existing = this.data.get(fullKey);\n    \n    this.data.set(fullKey, {\n      key,\n      namespace,\n      value,\n      timestamp,\n      created_at: existing?.created_at || now,\n      updated_at: now\n    });\n    \n    // Save asynchronously (don't await to avoid blocking)\n    this.saveData().catch(() => {});\n  }\n\n  get(key: string, namespace: string = 'default'): MemoryEntry | null {\n    const fullKey = this.getFullKey(key, namespace);\n    return this.data.get(fullKey) || null;\n  }\n\n  search(pattern: string, namespace?: string): MemoryEntry[] {\n    const searchPattern = pattern.replace(/\\*/g, '.*');\n    const regex = new RegExp(searchPattern);\n    \n    const results: MemoryEntry[] = [];\n    \n    for (const entry of this.data.values()) {\n      if (namespace && entry.namespace !== namespace) {\n        continue;\n      }\n      \n      if (regex.test(entry.key)) {\n        results.push(entry);\n      }\n    }\n    \n    return results.sort((a, b) => b.timestamp - a.timestamp);\n  }\n\n  list(namespace?: string): MemoryEntry[] {\n    const results: MemoryEntry[] = [];\n    \n    for (const entry of this.data.values()) {\n      if (namespace && entry.namespace !== namespace) {\n        continue;\n      }\n      results.push(entry);\n    }\n    \n    return results.sort((a, b) => b.timestamp - a.timestamp);\n  }\n\n  delete(key: string, namespace: string = 'default'): boolean {\n    const fullKey = this.getFullKey(key, namespace);\n    const deleted = this.data.delete(fullKey);\n    \n    if (deleted) {\n      this.saveData().catch(() => {});\n    }\n    \n    return deleted;\n  }\n\n  clear(namespace?: string): number {\n    let count = 0;\n    \n    if (namespace) {\n      const keysToDelete: string[] = [];\n      for (const [fullKey, entry] of this.data.entries()) {\n        if (entry.namespace === namespace) {\n          keysToDelete.push(fullKey);\n        }\n      }\n      \n      for (const key of keysToDelete) {\n        this.data.delete(key);\n        count++;\n      }\n    } else {\n      count = this.data.size;\n      this.data.clear();\n    }\n    \n    if (count > 0) {\n      this.saveData().catch(() => {});\n    }\n    \n    return count;\n  }\n\n  getStats(): { total_entries: number; namespaces: { namespace: string; count: number }[]; oldest_entry: number; newest_entry: number } {\n    const entries = Array.from(this.data.values());\n    const namespaces = [...new Set(entries.map(entry => entry.namespace))];\n    const namespaceStats = namespaces.map(ns => ({\n      namespace: ns,\n      count: entries.filter(entry => entry.namespace === ns).length\n    }));\n    \n    const timestamps = entries.map(entry => entry.timestamp);\n    const oldestEntry = timestamps.length > 0 ? Math.min(...timestamps) : 0;\n    const newestEntry = timestamps.length > 0 ? Math.max(...timestamps) : 0;\n    \n    return {\n      total_entries: entries.length,\n      namespaces: namespaceStats,\n      oldest_entry: oldestEntry,\n      newest_entry: newestEntry\n    };\n  }\n}\n\n// ============================================================================\n// LOGGER\n// ============================================================================\n\nclass Logger {\n  private static logLevel = process.env.LOG_LEVEL || 'info';\n  \n  static info(message: string, ...args: any[]) {\n    if (['info', 'debug'].includes(this.logLevel)) {\n      console.log(`â„¹ï¸  ${message}`, ...args);\n    }\n  }\n  \n  static debug(message: string, ...args: any[]) {\n    if (this.logLevel === 'debug') {\n      console.log(`ðŸ› ${message}`, ...args);\n    }\n  }\n  \n  static warn(message: string, ...args: any[]) {\n    console.warn(`âš ï¸  ${message}`, ...args);\n  }\n  \n  static error(message: string, error?: Error | any) {\n    console.error(`âŒ ${message}`);\n    if (error) {\n      console.error(`   Error details:`, error instanceof Error ? error.message : error);\n      if (error instanceof Error && error.stack) {\n        console.error(`   Stack trace:`, error.stack);\n      }\n    }\n  }\n  \n  static success(message: string, ...args: any[]) {\n    console.log(`âœ… ${message}`, ...args);\n  }\n}\n\n// ============================================================================\n// MCP SERVER SETUP\n// ============================================================================\n\nconst DEFAULT_CONFIG = {\n  name: \"sylphx-flow-mcp-server\",\n  version: \"1.0.0\",\n  description: \"Sylphx Flow MCP server providing memory coordination tools for AI agents. Persistent JSON-based storage with namespace support for agent coordination and state management.\"\n};\n\nLogger.info(\"ðŸš€ Starting Sylphx Flow MCP Server...\");\nLogger.info(`ðŸ“‹ Description: ${DEFAULT_CONFIG.description.substring(0, 100)}...`);\n\nconst server = new McpServer({\n  name: DEFAULT_CONFIG.name,\n  version: DEFAULT_CONFIG.version,\n  description: DEFAULT_CONFIG.description\n});\n\n// Initialize memory storage\nconst memoryStorage = new MemoryStorage();\nLogger.success(\"âœ… Memory storage initialized\");\n\n// ============================================================================\n// TOOL REGISTRATION\n// ============================================================================\n\n// Store a value in memory\nserver.registerTool(\n  \"memory_set\",\n  {\n    title: \"Store Memory\",\n    description: \"Store a value in persistent memory for agent coordination\",\n    inputSchema: z.object({\n      key: z.string().describe(\"Memory key (e.g., 'swarm/coder/status')\"),\n      value: z.string().describe(\"Value to store (will be JSON stringified)\"),\n      namespace: z.string().optional().describe(\"Optional namespace for organization\")\n    }) as any\n  },\n  async (args: any, extra: any) => {\n    try {\n      const { key, value, namespace = 'default' } = args;\n      const parsedValue = JSON.parse(value);\n      \n      memoryStorage.set(key, parsedValue, namespace);\n      \n      Logger.info(`Stored memory: ${namespace}:${key}`);\n      return {\n        content: [{\n          type: \"text\",\n          text: `âœ… Stored memory: ${namespace}:${key}`\n        }]\n      };\n    } catch (error: any) {\n      Logger.error(\"Error storing memory\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `âŒ Error storing memory: ${error.message}`\n        }],\n        isError: true\n      };\n    }\n  }\n);\n\n// Retrieve a value from memory\nserver.registerTool(\n  \"memory_get\",\n  {\n    title: \"Retrieve Memory\",\n    description: \"Retrieve a value from persistent memory\",\n    inputSchema: z.object({\n      key: z.string().describe(\"Memory key to retrieve\"),\n      namespace: z.string().optional().describe(\"Optional namespace\")\n    }) as any\n  },\n  async (args: any, extra: any) => {\n    try {\n      const { key, namespace = 'default' } = args;\n      const memory = memoryStorage.get(key, namespace);\n      \n      if (!memory) {\n        return {\n          content: [{\n            type: \"text\",\n            text: `âŒ Memory not found: ${namespace}:${key}`\n          }],\n          isError: true\n        };\n      }\n      \n      const age = Date.now() - memory.timestamp;\n      \n      Logger.info(`Retrieved memory: ${namespace}:${key}`);\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify({\n            key: `${namespace}:${key}`,\n            value: memory.value,\n            timestamp: memory.timestamp,\n            created_at: memory.created_at,\n            updated_at: memory.updated_at,\n            namespace: memory.namespace,\n            age: age\n          }, null, 2)\n        }]\n      };\n    } catch (error: any) {\n      Logger.error(\"Error retrieving memory\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `âŒ Error retrieving memory: ${error.message}`\n        }],\n        isError: true\n      };\n    }\n  }\n);\n\n// Search memory keys by pattern\nserver.registerTool(\n  \"memory_search\",\n  {\n    title: \"Search Memory\",\n    description: \"Search memory keys by pattern with optional namespace filtering\",\n    inputSchema: z.object({\n      pattern: z.string().describe(\"Search pattern (supports * wildcards)\"),\n      namespace: z.string().optional().describe(\"Optional namespace to limit search\")\n    }) as any\n  },\n  async (args: any, extra: any) => {\n    try {\n      const { pattern, namespace } = args;\n      const results = memoryStorage.search(pattern, namespace);\n      \n      const processedResults = results.map(memory => ({\n        key: `${memory.namespace}:${memory.key}`,\n        value: memory.value,\n        timestamp: memory.timestamp,\n        created_at: memory.created_at,\n        updated_at: memory.updated_at,\n        namespace: memory.namespace,\n        age: Date.now() - memory.timestamp\n      }));\n      \n      Logger.info(`Searched memory: ${pattern} (${results.length} results)`);\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify({\n            pattern: pattern,\n            namespace: namespace || 'all',\n            count: results.length,\n            results: processedResults\n          }, null, 2)\n        }]\n      };\n    } catch (error: any) {\n      Logger.error(\"Error searching memory\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `âŒ Error searching memory: ${error.message}`\n        }],\n        isError: true\n      };\n    }\n  }\n);\n\n// List all memory keys\nserver.registerTool(\n  \"memory_list\",\n  {\n    title: \"List Memory\",\n    description: \"List all memory keys, optionally filtered by namespace\",\n    inputSchema: z.object({\n      namespace: z.string().optional().describe(\"Optional namespace to filter\")\n    }) as any\n  },\n  async (args: any, extra: any) => {\n    try {\n      const { namespace } = args;\n      const entries = memoryStorage.list(namespace);\n      \n      const processedEntries = entries.map(memory => ({\n        key: `${memory.namespace}:${memory.key}`,\n        namespace: memory.namespace,\n        timestamp: memory.timestamp,\n        created_at: memory.created_at,\n        updated_at: memory.updated_at,\n        age: Date.now() - memory.timestamp\n      }));\n      \n      Logger.info(`Listed memory: ${namespace || 'all'} (${entries.length} entries)`);\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify({\n            namespace: namespace || 'all',\n            count: entries.length,\n            keys: processedEntries\n          }, null, 2)\n        }]\n      };\n    } catch (error: any) {\n      Logger.error(\"Error listing memory\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `âŒ Error listing memory: ${error.message}`\n        }],\n        isError: true\n      };\n    }\n  }\n);\n\n// Delete memory\nserver.registerTool(\n  \"memory_delete\",\n  {\n    title: \"Delete Memory\",\n    description: \"Delete a specific memory entry\",\n    inputSchema: z.object({\n      key: z.string().describe(\"Memory key to delete\"),\n      namespace: z.string().optional().describe(\"Optional namespace\")\n    }) as any\n  },\n  async (args: any, extra: any) => {\n    try {\n      const { key, namespace = 'default' } = args;\n      const deleted = memoryStorage.delete(key, namespace);\n      \n      if (deleted) {\n        Logger.info(`Deleted memory: ${namespace}:${key}`);\n        return {\n          content: [{\n            type: \"text\",\n            text: `âœ… Deleted memory: ${namespace}:${key}`\n          }]\n        };\n      } else {\n        return {\n          content: [{\n            type: \"text\",\n            text: `âŒ Memory not found: ${namespace}:${key}`\n          }],\n          isError: true\n        };\n      }\n    } catch (error: any) {\n      Logger.error(\"Error deleting memory\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `âŒ Error deleting memory: ${error.message}`\n        }],\n        isError: true\n      };\n    }\n  }\n);\n\n// Clear all memory or specific namespace\nserver.registerTool(\n  \"memory_clear\",\n  {\n    title: \"Clear Memory\",\n    description: \"Clear all memory or specific namespace\",\n    inputSchema: z.object({\n      namespace: z.string().optional().describe(\"Optional namespace to clear\"),\n      confirm: z.boolean().describe(\"Confirmation required for clearing all memory\")\n    }) as any\n  },\n  async (args: any, extra: any) => {\n    try {\n      const { namespace, confirm } = args;\n      \n      if (!namespace && !confirm) {\n        return {\n          content: [{\n            type: \"text\",\n            text: `âŒ Confirmation required. Set confirm: true to clear all memory.`\n          }],\n          isError: true\n        };\n      }\n      \n      const count = memoryStorage.clear(namespace);\n      \n      if (namespace) {\n        Logger.info(`Cleared memory namespace: ${namespace} (${count} entries)`);\n        return {\n          content: [{\n            type: \"text\",\n            text: `âœ… Cleared ${count} memories from namespace: ${namespace}`\n          }]\n        };\n      } else {\n        Logger.info(`Cleared all memory (${count} entries)`);\n        return {\n          content: [{\n            type: \"text\",\n            text: `âœ… Cleared all ${count} memory entries`\n          }]\n        };\n      }\n    } catch (error: any) {\n      Logger.error(\"Error clearing memory\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `âŒ Error clearing memory: ${error.message}`\n        }],\n        isError: true\n      };\n    }\n  }\n);\n\n// Get database statistics\nserver.registerTool(\n  \"memory_stats\",\n  {\n    title: \"Memory Statistics\",\n    description: \"Get statistics about the memory storage\",\n    inputSchema: z.object({}) as any\n  },\n  async (args: any, extra: any) => {\n    try {\n      const stats = memoryStorage.getStats();\n      \n      Logger.info(`Retrieved memory statistics`);\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify({\n            ...stats,\n            database_path: path.join(process.cwd(), '.memory', 'memory.json'),\n            age_days: stats.oldest_entry > 0 ? Math.floor((Date.now() - stats.oldest_entry) / (1000 * 60 * 60 * 24)) : 0\n          }, null, 2)\n        }]\n      };\n    } catch (error: any) {\n      Logger.error(\"Error getting memory statistics\", error);\n      return {\n        content: [{\n          type: \"text\",\n          text: `âŒ Error getting memory statistics: ${error.message}`\n        }],\n        isError: true\n      };\n    }\n  }\n);\n\n// ============================================================================\n// ERROR HANDLING AND GRACEFUL SHUTDOWN\n// ============================================================================\n\nprocess.on('SIGINT', () => {\n  Logger.info(\"ðŸ›‘ Received SIGINT, shutting down gracefully...\");\n  process.exit(0);\n});\n\nprocess.on('SIGTERM', () => {\n  Logger.info(\"ðŸ›‘ Received SIGTERM, shutting down gracefully...\");\n  process.exit(0);\n});\n\nprocess.on('uncaughtException', (error) => {\n  Logger.error(\"Uncaught Exception\", error);\n  process.exit(1);\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n  Logger.error(\"Unhandled Rejection\", reason);\n  process.exit(1);\n});\n\n// ============================================================================\n// START SERVER\n// ============================================================================\n\nLogger.success(\"ðŸš€ Sylphx Flow MCP Server ready!\");\nLogger.info(`ðŸ“ Storage: ${path.join(process.cwd(), '.memory', 'memory.json')}`);\nLogger.info(`ðŸ”§ Available tools: memory_set, memory_get, memory_search, memory_list, memory_delete, memory_clear, memory_stats`);\n\n// Start the server with stdio transport\nasync function startServer() {\n  const transport = new StdioServerTransport();\n  await server.connect(transport);\n  Logger.info(\"ðŸ”— Server connected via stdio transport\");\n}\n\n// Start the server\nstartServer().catch((error) => {\n  Logger.error(\"Failed to start server\", error);\n  process.exit(1);\n});\n\nexport default server;"],"mappings":";;;AACA,SAAS,iBAAiB;AAC1B,SAAS,4BAA4B;AACrC,SAAS,SAAS;AAClB,YAAY,QAAQ;AACpB,YAAY,UAAU;AAetB,IAAM,gBAAN,MAAoB;AAAA,EACV,OAAiC,oBAAI,IAAI;AAAA,EACzC;AAAA,EACA;AAAA,EAER,cAAc;AACZ,SAAK,YAAiB,UAAK,QAAQ,IAAI,GAAG,SAAS;AACnD,SAAK,WAAgB,UAAK,KAAK,WAAW,aAAa;AAGvD,IAAG,SAAM,KAAK,WAAW,EAAE,WAAW,KAAK,CAAC,EAAE,MAAM,MAAM;AAAA,IAAC,CAAC;AAG5D,SAAK,SAAS;AAAA,EAChB;AAAA,EAEQ,WAAW,KAAa,WAA2B;AACzD,WAAO,GAAG,SAAS,IAAI,GAAG;AAAA,EAC5B;AAAA,EAEA,MAAc,WAA0B;AACtC,QAAI;AACF,YAAM,OAAO,MAAS,YAAS,KAAK,UAAU,MAAM;AACpD,YAAM,SAAS,KAAK,MAAM,IAAI;AAC9B,WAAK,OAAO,IAAI,IAAI,OAAO,QAAQ,MAAM,CAAC;AAAA,IAC5C,QAAQ;AAEN,WAAK,OAAO,oBAAI,IAAI;AAAA,IACtB;AAAA,EACF;AAAA,EAEA,MAAc,WAA0B;AACtC,QAAI;AACF,YAAM,OAAO,OAAO,YAAY,KAAK,IAAI;AACzC,YAAS,aAAU,KAAK,UAAU,KAAK,UAAU,MAAM,MAAM,CAAC,GAAG,MAAM;AAAA,IACzE,SAAS,OAAO;AACd,cAAQ,KAAK,wCAAwC,KAAK;AAAA,IAC5D;AAAA,EACF;AAAA,EAEA,IAAI,KAAa,OAAY,YAAoB,WAAiB;AAChE,UAAM,UAAU,KAAK,WAAW,KAAK,SAAS;AAC9C,UAAM,OAAM,oBAAI,KAAK,GAAE,YAAY;AACnC,UAAM,YAAY,KAAK,IAAI;AAE3B,UAAM,WAAW,KAAK,KAAK,IAAI,OAAO;AAEtC,SAAK,KAAK,IAAI,SAAS;AAAA,MACrB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,YAAY,UAAU,cAAc;AAAA,MACpC,YAAY;AAAA,IACd,CAAC;AAGD,SAAK,SAAS,EAAE,MAAM,MAAM;AAAA,IAAC,CAAC;AAAA,EAChC;AAAA,EAEA,IAAI,KAAa,YAAoB,WAA+B;AAClE,UAAM,UAAU,KAAK,WAAW,KAAK,SAAS;AAC9C,WAAO,KAAK,KAAK,IAAI,OAAO,KAAK;AAAA,EACnC;AAAA,EAEA,OAAO,SAAiB,WAAmC;AACzD,UAAM,gBAAgB,QAAQ,QAAQ,OAAO,IAAI;AACjD,UAAM,QAAQ,IAAI,OAAO,aAAa;AAEtC,UAAM,UAAyB,CAAC;AAEhC,eAAW,SAAS,KAAK,KAAK,OAAO,GAAG;AACtC,UAAI,aAAa,MAAM,cAAc,WAAW;AAC9C;AAAA,MACF;AAEA,UAAI,MAAM,KAAK,MAAM,GAAG,GAAG;AACzB,gBAAQ,KAAK,KAAK;AAAA,MACpB;AAAA,IACF;AAEA,WAAO,QAAQ,KAAK,CAAC,GAAG,MAAM,EAAE,YAAY,EAAE,SAAS;AAAA,EACzD;AAAA,EAEA,KAAK,WAAmC;AACtC,UAAM,UAAyB,CAAC;AAEhC,eAAW,SAAS,KAAK,KAAK,OAAO,GAAG;AACtC,UAAI,aAAa,MAAM,cAAc,WAAW;AAC9C;AAAA,MACF;AACA,cAAQ,KAAK,KAAK;AAAA,IACpB;AAEA,WAAO,QAAQ,KAAK,CAAC,GAAG,MAAM,EAAE,YAAY,EAAE,SAAS;AAAA,EACzD;AAAA,EAEA,OAAO,KAAa,YAAoB,WAAoB;AAC1D,UAAM,UAAU,KAAK,WAAW,KAAK,SAAS;AAC9C,UAAM,UAAU,KAAK,KAAK,OAAO,OAAO;AAExC,QAAI,SAAS;AACX,WAAK,SAAS,EAAE,MAAM,MAAM;AAAA,MAAC,CAAC;AAAA,IAChC;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,WAA4B;AAChC,QAAI,QAAQ;AAEZ,QAAI,WAAW;AACb,YAAM,eAAyB,CAAC;AAChC,iBAAW,CAAC,SAAS,KAAK,KAAK,KAAK,KAAK,QAAQ,GAAG;AAClD,YAAI,MAAM,cAAc,WAAW;AACjC,uBAAa,KAAK,OAAO;AAAA,QAC3B;AAAA,MACF;AAEA,iBAAW,OAAO,cAAc;AAC9B,aAAK,KAAK,OAAO,GAAG;AACpB;AAAA,MACF;AAAA,IACF,OAAO;AACL,cAAQ,KAAK,KAAK;AAClB,WAAK,KAAK,MAAM;AAAA,IAClB;AAEA,QAAI,QAAQ,GAAG;AACb,WAAK,SAAS,EAAE,MAAM,MAAM;AAAA,MAAC,CAAC;AAAA,IAChC;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,WAAsI;AACpI,UAAM,UAAU,MAAM,KAAK,KAAK,KAAK,OAAO,CAAC;AAC7C,UAAM,aAAa,CAAC,GAAG,IAAI,IAAI,QAAQ,IAAI,WAAS,MAAM,SAAS,CAAC,CAAC;AACrE,UAAM,iBAAiB,WAAW,IAAI,SAAO;AAAA,MAC3C,WAAW;AAAA,MACX,OAAO,QAAQ,OAAO,WAAS,MAAM,cAAc,EAAE,EAAE;AAAA,IACzD,EAAE;AAEF,UAAM,aAAa,QAAQ,IAAI,WAAS,MAAM,SAAS;AACvD,UAAM,cAAc,WAAW,SAAS,IAAI,KAAK,IAAI,GAAG,UAAU,IAAI;AACtE,UAAM,cAAc,WAAW,SAAS,IAAI,KAAK,IAAI,GAAG,UAAU,IAAI;AAEtE,WAAO;AAAA,MACL,eAAe,QAAQ;AAAA,MACvB,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,cAAc;AAAA,IAChB;AAAA,EACF;AACF;AAMA,IAAM,SAAN,MAAa;AAAA,EACX,OAAe,WAAW,QAAQ,IAAI,aAAa;AAAA,EAEnD,OAAO,KAAK,YAAoB,MAAa;AAC3C,QAAI,CAAC,QAAQ,OAAO,EAAE,SAAS,KAAK,QAAQ,GAAG;AAC7C,cAAQ,IAAI,iBAAO,OAAO,IAAI,GAAG,IAAI;AAAA,IACvC;AAAA,EACF;AAAA,EAEA,OAAO,MAAM,YAAoB,MAAa;AAC5C,QAAI,KAAK,aAAa,SAAS;AAC7B,cAAQ,IAAI,aAAM,OAAO,IAAI,GAAG,IAAI;AAAA,IACtC;AAAA,EACF;AAAA,EAEA,OAAO,KAAK,YAAoB,MAAa;AAC3C,YAAQ,KAAK,iBAAO,OAAO,IAAI,GAAG,IAAI;AAAA,EACxC;AAAA,EAEA,OAAO,MAAM,SAAiB,OAAqB;AACjD,YAAQ,MAAM,UAAK,OAAO,EAAE;AAC5B,QAAI,OAAO;AACT,cAAQ,MAAM,qBAAqB,iBAAiB,QAAQ,MAAM,UAAU,KAAK;AACjF,UAAI,iBAAiB,SAAS,MAAM,OAAO;AACzC,gBAAQ,MAAM,mBAAmB,MAAM,KAAK;AAAA,MAC9C;AAAA,IACF;AAAA,EACF;AAAA,EAEA,OAAO,QAAQ,YAAoB,MAAa;AAC9C,YAAQ,IAAI,UAAK,OAAO,IAAI,GAAG,IAAI;AAAA,EACrC;AACF;AAMA,IAAM,iBAAiB;AAAA,EACrB,MAAM;AAAA,EACN,SAAS;AAAA,EACT,aAAa;AACf;AAEA,OAAO,KAAK,8CAAuC;AACnD,OAAO,KAAK,0BAAmB,eAAe,YAAY,UAAU,GAAG,GAAG,CAAC,KAAK;AAEhF,IAAM,SAAS,IAAI,UAAU;AAAA,EAC3B,MAAM,eAAe;AAAA,EACrB,SAAS,eAAe;AAAA,EACxB,aAAa,eAAe;AAC9B,CAAC;AAGD,IAAM,gBAAgB,IAAI,cAAc;AACxC,OAAO,QAAQ,mCAA8B;AAO7C,OAAO;AAAA,EACL;AAAA,EACA;AAAA,IACE,OAAO;AAAA,IACP,aAAa;AAAA,IACb,aAAa,EAAE,OAAO;AAAA,MACpB,KAAK,EAAE,OAAO,EAAE,SAAS,yCAAyC;AAAA,MAClE,OAAO,EAAE,OAAO,EAAE,SAAS,2CAA2C;AAAA,MACtE,WAAW,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,qCAAqC;AAAA,IACjF,CAAC;AAAA,EACH;AAAA,EACA,OAAO,MAAW,UAAe;AAC/B,QAAI;AACF,YAAM,EAAE,KAAK,OAAO,YAAY,UAAU,IAAI;AAC9C,YAAM,cAAc,KAAK,MAAM,KAAK;AAEpC,oBAAc,IAAI,KAAK,aAAa,SAAS;AAE7C,aAAO,KAAK,kBAAkB,SAAS,IAAI,GAAG,EAAE;AAChD,aAAO;AAAA,QACL,SAAS,CAAC;AAAA,UACR,MAAM;AAAA,UACN,MAAM,yBAAoB,SAAS,IAAI,GAAG;AAAA,QAC5C,CAAC;AAAA,MACH;AAAA,IACF,SAAS,OAAY;AACnB,aAAO,MAAM,wBAAwB,KAAK;AAC1C,aAAO;AAAA,QACL,SAAS,CAAC;AAAA,UACR,MAAM;AAAA,UACN,MAAM,gCAA2B,MAAM,OAAO;AAAA,QAChD,CAAC;AAAA,QACD,SAAS;AAAA,MACX;AAAA,IACF;AAAA,EACF;AACF;AAGA,OAAO;AAAA,EACL;AAAA,EACA;AAAA,IACE,OAAO;AAAA,IACP,aAAa;AAAA,IACb,aAAa,EAAE,OAAO;AAAA,MACpB,KAAK,EAAE,OAAO,EAAE,SAAS,wBAAwB;AAAA,MACjD,WAAW,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,oBAAoB;AAAA,IAChE,CAAC;AAAA,EACH;AAAA,EACA,OAAO,MAAW,UAAe;AAC/B,QAAI;AACF,YAAM,EAAE,KAAK,YAAY,UAAU,IAAI;AACvC,YAAM,SAAS,cAAc,IAAI,KAAK,SAAS;AAE/C,UAAI,CAAC,QAAQ;AACX,eAAO;AAAA,UACL,SAAS,CAAC;AAAA,YACR,MAAM;AAAA,YACN,MAAM,4BAAuB,SAAS,IAAI,GAAG;AAAA,UAC/C,CAAC;AAAA,UACD,SAAS;AAAA,QACX;AAAA,MACF;AAEA,YAAM,MAAM,KAAK,IAAI,IAAI,OAAO;AAEhC,aAAO,KAAK,qBAAqB,SAAS,IAAI,GAAG,EAAE;AACnD,aAAO;AAAA,QACL,SAAS,CAAC;AAAA,UACR,MAAM;AAAA,UACN,MAAM,KAAK,UAAU;AAAA,YACnB,KAAK,GAAG,SAAS,IAAI,GAAG;AAAA,YACxB,OAAO,OAAO;AAAA,YACd,WAAW,OAAO;AAAA,YAClB,YAAY,OAAO;AAAA,YACnB,YAAY,OAAO;AAAA,YACnB,WAAW,OAAO;AAAA,YAClB;AAAA,UACF,GAAG,MAAM,CAAC;AAAA,QACZ,CAAC;AAAA,MACH;AAAA,IACF,SAAS,OAAY;AACnB,aAAO,MAAM,2BAA2B,KAAK;AAC7C,aAAO;AAAA,QACL,SAAS,CAAC;AAAA,UACR,MAAM;AAAA,UACN,MAAM,mCAA8B,MAAM,OAAO;AAAA,QACnD,CAAC;AAAA,QACD,SAAS;AAAA,MACX;AAAA,IACF;AAAA,EACF;AACF;AAGA,OAAO;AAAA,EACL;AAAA,EACA;AAAA,IACE,OAAO;AAAA,IACP,aAAa;AAAA,IACb,aAAa,EAAE,OAAO;AAAA,MACpB,SAAS,EAAE,OAAO,EAAE,SAAS,uCAAuC;AAAA,MACpE,WAAW,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,oCAAoC;AAAA,IAChF,CAAC;AAAA,EACH;AAAA,EACA,OAAO,MAAW,UAAe;AAC/B,QAAI;AACF,YAAM,EAAE,SAAS,UAAU,IAAI;AAC/B,YAAM,UAAU,cAAc,OAAO,SAAS,SAAS;AAEvD,YAAM,mBAAmB,QAAQ,IAAI,aAAW;AAAA,QAC9C,KAAK,GAAG,OAAO,SAAS,IAAI,OAAO,GAAG;AAAA,QACtC,OAAO,OAAO;AAAA,QACd,WAAW,OAAO;AAAA,QAClB,YAAY,OAAO;AAAA,QACnB,YAAY,OAAO;AAAA,QACnB,WAAW,OAAO;AAAA,QAClB,KAAK,KAAK,IAAI,IAAI,OAAO;AAAA,MAC3B,EAAE;AAEF,aAAO,KAAK,oBAAoB,OAAO,KAAK,QAAQ,MAAM,WAAW;AACrE,aAAO;AAAA,QACL,SAAS,CAAC;AAAA,UACR,MAAM;AAAA,UACN,MAAM,KAAK,UAAU;AAAA,YACnB;AAAA,YACA,WAAW,aAAa;AAAA,YACxB,OAAO,QAAQ;AAAA,YACf,SAAS;AAAA,UACX,GAAG,MAAM,CAAC;AAAA,QACZ,CAAC;AAAA,MACH;AAAA,IACF,SAAS,OAAY;AACnB,aAAO,MAAM,0BAA0B,KAAK;AAC5C,aAAO;AAAA,QACL,SAAS,CAAC;AAAA,UACR,MAAM;AAAA,UACN,MAAM,kCAA6B,MAAM,OAAO;AAAA,QAClD,CAAC;AAAA,QACD,SAAS;AAAA,MACX;AAAA,IACF;AAAA,EACF;AACF;AAGA,OAAO;AAAA,EACL;AAAA,EACA;AAAA,IACE,OAAO;AAAA,IACP,aAAa;AAAA,IACb,aAAa,EAAE,OAAO;AAAA,MACpB,WAAW,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,8BAA8B;AAAA,IAC1E,CAAC;AAAA,EACH;AAAA,EACA,OAAO,MAAW,UAAe;AAC/B,QAAI;AACF,YAAM,EAAE,UAAU,IAAI;AACtB,YAAM,UAAU,cAAc,KAAK,SAAS;AAE5C,YAAM,mBAAmB,QAAQ,IAAI,aAAW;AAAA,QAC9C,KAAK,GAAG,OAAO,SAAS,IAAI,OAAO,GAAG;AAAA,QACtC,WAAW,OAAO;AAAA,QAClB,WAAW,OAAO;AAAA,QAClB,YAAY,OAAO;AAAA,QACnB,YAAY,OAAO;AAAA,QACnB,KAAK,KAAK,IAAI,IAAI,OAAO;AAAA,MAC3B,EAAE;AAEF,aAAO,KAAK,kBAAkB,aAAa,KAAK,KAAK,QAAQ,MAAM,WAAW;AAC9E,aAAO;AAAA,QACL,SAAS,CAAC;AAAA,UACR,MAAM;AAAA,UACN,MAAM,KAAK,UAAU;AAAA,YACnB,WAAW,aAAa;AAAA,YACxB,OAAO,QAAQ;AAAA,YACf,MAAM;AAAA,UACR,GAAG,MAAM,CAAC;AAAA,QACZ,CAAC;AAAA,MACH;AAAA,IACF,SAAS,OAAY;AACnB,aAAO,MAAM,wBAAwB,KAAK;AAC1C,aAAO;AAAA,QACL,SAAS,CAAC;AAAA,UACR,MAAM;AAAA,UACN,MAAM,gCAA2B,MAAM,OAAO;AAAA,QAChD,CAAC;AAAA,QACD,SAAS;AAAA,MACX;AAAA,IACF;AAAA,EACF;AACF;AAGA,OAAO;AAAA,EACL;AAAA,EACA;AAAA,IACE,OAAO;AAAA,IACP,aAAa;AAAA,IACb,aAAa,EAAE,OAAO;AAAA,MACpB,KAAK,EAAE,OAAO,EAAE,SAAS,sBAAsB;AAAA,MAC/C,WAAW,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,oBAAoB;AAAA,IAChE,CAAC;AAAA,EACH;AAAA,EACA,OAAO,MAAW,UAAe;AAC/B,QAAI;AACF,YAAM,EAAE,KAAK,YAAY,UAAU,IAAI;AACvC,YAAM,UAAU,cAAc,OAAO,KAAK,SAAS;AAEnD,UAAI,SAAS;AACX,eAAO,KAAK,mBAAmB,SAAS,IAAI,GAAG,EAAE;AACjD,eAAO;AAAA,UACL,SAAS,CAAC;AAAA,YACR,MAAM;AAAA,YACN,MAAM,0BAAqB,SAAS,IAAI,GAAG;AAAA,UAC7C,CAAC;AAAA,QACH;AAAA,MACF,OAAO;AACL,eAAO;AAAA,UACL,SAAS,CAAC;AAAA,YACR,MAAM;AAAA,YACN,MAAM,4BAAuB,SAAS,IAAI,GAAG;AAAA,UAC/C,CAAC;AAAA,UACD,SAAS;AAAA,QACX;AAAA,MACF;AAAA,IACF,SAAS,OAAY;AACnB,aAAO,MAAM,yBAAyB,KAAK;AAC3C,aAAO;AAAA,QACL,SAAS,CAAC;AAAA,UACR,MAAM;AAAA,UACN,MAAM,iCAA4B,MAAM,OAAO;AAAA,QACjD,CAAC;AAAA,QACD,SAAS;AAAA,MACX;AAAA,IACF;AAAA,EACF;AACF;AAGA,OAAO;AAAA,EACL;AAAA,EACA;AAAA,IACE,OAAO;AAAA,IACP,aAAa;AAAA,IACb,aAAa,EAAE,OAAO;AAAA,MACpB,WAAW,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,6BAA6B;AAAA,MACvE,SAAS,EAAE,QAAQ,EAAE,SAAS,+CAA+C;AAAA,IAC/E,CAAC;AAAA,EACH;AAAA,EACA,OAAO,MAAW,UAAe;AAC/B,QAAI;AACF,YAAM,EAAE,WAAW,QAAQ,IAAI;AAE/B,UAAI,CAAC,aAAa,CAAC,SAAS;AAC1B,eAAO;AAAA,UACL,SAAS,CAAC;AAAA,YACR,MAAM;AAAA,YACN,MAAM;AAAA,UACR,CAAC;AAAA,UACD,SAAS;AAAA,QACX;AAAA,MACF;AAEA,YAAM,QAAQ,cAAc,MAAM,SAAS;AAE3C,UAAI,WAAW;AACb,eAAO,KAAK,6BAA6B,SAAS,KAAK,KAAK,WAAW;AACvE,eAAO;AAAA,UACL,SAAS,CAAC;AAAA,YACR,MAAM;AAAA,YACN,MAAM,kBAAa,KAAK,6BAA6B,SAAS;AAAA,UAChE,CAAC;AAAA,QACH;AAAA,MACF,OAAO;AACL,eAAO,KAAK,uBAAuB,KAAK,WAAW;AACnD,eAAO;AAAA,UACL,SAAS,CAAC;AAAA,YACR,MAAM;AAAA,YACN,MAAM,sBAAiB,KAAK;AAAA,UAC9B,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF,SAAS,OAAY;AACnB,aAAO,MAAM,yBAAyB,KAAK;AAC3C,aAAO;AAAA,QACL,SAAS,CAAC;AAAA,UACR,MAAM;AAAA,UACN,MAAM,iCAA4B,MAAM,OAAO;AAAA,QACjD,CAAC;AAAA,QACD,SAAS;AAAA,MACX;AAAA,IACF;AAAA,EACF;AACF;AAGA,OAAO;AAAA,EACL;AAAA,EACA;AAAA,IACE,OAAO;AAAA,IACP,aAAa;AAAA,IACb,aAAa,EAAE,OAAO,CAAC,CAAC;AAAA,EAC1B;AAAA,EACA,OAAO,MAAW,UAAe;AAC/B,QAAI;AACF,YAAM,QAAQ,cAAc,SAAS;AAErC,aAAO,KAAK,6BAA6B;AACzC,aAAO;AAAA,QACL,SAAS,CAAC;AAAA,UACR,MAAM;AAAA,UACN,MAAM,KAAK,UAAU;AAAA,YACnB,GAAG;AAAA,YACH,eAAoB,UAAK,QAAQ,IAAI,GAAG,WAAW,aAAa;AAAA,YAChE,UAAU,MAAM,eAAe,IAAI,KAAK,OAAO,KAAK,IAAI,IAAI,MAAM,iBAAiB,MAAO,KAAK,KAAK,GAAG,IAAI;AAAA,UAC7G,GAAG,MAAM,CAAC;AAAA,QACZ,CAAC;AAAA,MACH;AAAA,IACF,SAAS,OAAY;AACnB,aAAO,MAAM,mCAAmC,KAAK;AACrD,aAAO;AAAA,QACL,SAAS,CAAC;AAAA,UACR,MAAM;AAAA,UACN,MAAM,2CAAsC,MAAM,OAAO;AAAA,QAC3D,CAAC;AAAA,QACD,SAAS;AAAA,MACX;AAAA,IACF;AAAA,EACF;AACF;AAMA,QAAQ,GAAG,UAAU,MAAM;AACzB,SAAO,KAAK,wDAAiD;AAC7D,UAAQ,KAAK,CAAC;AAChB,CAAC;AAED,QAAQ,GAAG,WAAW,MAAM;AAC1B,SAAO,KAAK,yDAAkD;AAC9D,UAAQ,KAAK,CAAC;AAChB,CAAC;AAED,QAAQ,GAAG,qBAAqB,CAAC,UAAU;AACzC,SAAO,MAAM,sBAAsB,KAAK;AACxC,UAAQ,KAAK,CAAC;AAChB,CAAC;AAED,QAAQ,GAAG,sBAAsB,CAAC,QAAQ,YAAY;AACpD,SAAO,MAAM,uBAAuB,MAAM;AAC1C,UAAQ,KAAK,CAAC;AAChB,CAAC;AAMD,OAAO,QAAQ,yCAAkC;AACjD,OAAO,KAAK,sBAAoB,UAAK,QAAQ,IAAI,GAAG,WAAW,aAAa,CAAC,EAAE;AAC/E,OAAO,KAAK,0HAAmH;AAG/H,eAAe,cAAc;AAC3B,QAAM,YAAY,IAAI,qBAAqB;AAC3C,QAAM,OAAO,QAAQ,SAAS;AAC9B,SAAO,KAAK,gDAAyC;AACvD;AAGA,YAAY,EAAE,MAAM,CAAC,UAAU;AAC7B,SAAO,MAAM,0BAA0B,KAAK;AAC5C,UAAQ,KAAK,CAAC;AAChB,CAAC;AAED,IAAO,iCAAQ;","names":[]}