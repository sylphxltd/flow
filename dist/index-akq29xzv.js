import{d as E2}from"./index-z81ckx8p.js";import{f as Q1,g as i,i as d}from"./index-8z4rbwmp.js";var $f=i((T)=>{var f6=T&&T.__createBinding||(Object.create?function(f,X,$,J){if(J===void 0)J=$;var R=Object.getOwnPropertyDescriptor(X,$);if(!R||("get"in R?!X.__esModule:R.writable||R.configurable))R={enumerable:!0,get:function(){return X[$]}};Object.defineProperty(f,J,R)}:function(f,X,$,J){if(J===void 0)J=$;f[J]=X[$]}),X6=T&&T.__setModuleDefault||(Object.create?function(f,X){Object.defineProperty(f,"default",{enumerable:!0,value:X})}:function(f,X){f.default=X}),Xf=T&&T.__importStar||function(f){if(f&&f.__esModule)return f;var X={};if(f!=null){for(var $ in f)if($!=="default"&&Object.prototype.hasOwnProperty.call(f,$))f6(X,f,$)}return X6(X,f),X};Object.defineProperty(T,"__esModule",{value:!0});T.load=T.currentTarget=void 0;var $6=Xf(d("path")),J6=Xf(d("fs"));function R6(){let f=null;switch(process.platform){case"android":switch(process.arch){case"arm":return"android-arm-eabi";case"arm64":return"android-arm64"}f="Android";break;case"win32":switch(process.arch){case"x64":return"win32-x64-msvc";case"arm64":return"win32-arm64-msvc";case"ia32":return"win32-ia32-msvc"}f="Windows";break;case"darwin":switch(process.arch){case"x64":return"darwin-x64";case"arm64":return"darwin-arm64"}f="macOS";break;case"linux":switch(process.arch){case"x64":case"arm64":return A6()?`linux-${process.arch}-gnu`:`linux-${process.arch}-musl`;case"arm":return"linux-arm-gnueabihf"}f="Linux";break;case"freebsd":if(process.arch==="x64")return"freebsd-x64";f="FreeBSD";break}if(f)throw Error(`Neon: unsupported ${f} architecture: ${process.arch}`);throw Error(`Neon: unsupported system: ${process.platform}`)}T.currentTarget=R6;function A6(){let f=process.report?.getReport();if(typeof f!=="object"||!f||!("header"in f))return!1;let X=f.header;return typeof X==="object"&&!!X&&"glibcVersionRuntime"in X}function Z6(f){let X=$6.join(f,"index.node");return J6.existsSync(X)?d(X):null}T.load=Z6});var Af=i((E4,Rf)=>{var Jf=()=>process.platform==="linux",D1=null,Y6=()=>{if(!D1)D1=Jf()&&process.report?process.report.getReport():{};return D1};Rf.exports={isLinux:Jf,getReport:Y6}});var _f=i((h4,Yf)=>{var Zf=d("fs"),_6=(f)=>Zf.readFileSync(f,"utf-8"),N6=(f)=>new Promise((X,$)=>{Zf.readFile(f,"utf-8",(J,R)=>{if(J)$(J);else X(R)})});Yf.exports={LDD_PATH:"/usr/bin/ldd",readFileSync:_6,readFile:N6}});var Tf=i((P4,Lf)=>{var Gf=d("child_process"),{isLinux:K2,getReport:Kf}=Af(),{LDD_PATH:s2,readFile:zf,readFileSync:Of}=_f(),P,k,n="",Wf=()=>{if(!n)return new Promise((f)=>{Gf.exec("getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true",(X,$)=>{n=X?" ":$,f(n)})});return n},Df=()=>{if(!n)try{n=Gf.execSync("getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true",{encoding:"utf8"})}catch(f){n=" "}return n},p="glibc",xf=/GLIBC\s(\d+\.\d+)/,e="musl",G6=p.toUpperCase(),K6=e.toLowerCase(),z6=(f)=>f.includes("libc.musl-")||f.includes("ld-musl-"),Qf=()=>{let f=Kf();if(f.header&&f.header.glibcVersionRuntime)return p;if(Array.isArray(f.sharedObjects)){if(f.sharedObjects.some(z6))return e}return null},If=(f)=>{let[X,$]=f.split(/[\r\n]+/);if(X&&X.includes(p))return p;if($&&$.includes(e))return e;return null},Bf=(f)=>{if(f.includes(K6))return e;if(f.includes(G6))return p;return null},O6=async()=>{if(P!==void 0)return P;P=null;try{let f=await zf(s2);P=Bf(f)}catch(f){}return P},W6=()=>{if(P!==void 0)return P;P=null;try{let f=Of(s2);P=Bf(f)}catch(f){}return P},Uf=async()=>{let f=null;if(K2()){if(f=await O6(),!f)f=Qf();if(!f){let X=await Wf();f=If(X)}}return f},Vf=()=>{let f=null;if(K2()){if(f=W6(),!f)f=Qf();if(!f){let X=Df();f=If(X)}}return f},D6=async()=>K2()&&await Uf()!==p,x6=()=>K2()&&Vf()!==p,Q6=async()=>{if(k!==void 0)return k;k=null;try{let X=(await zf(s2)).match(xf);if(X)k=X[1]}catch(f){}return k},I6=()=>{if(k!==void 0)return k;k=null;try{let X=Of(s2).match(xf);if(X)k=X[1]}catch(f){}return k},yf=()=>{let f=Kf();if(f.header&&f.header.glibcVersionRuntime)return f.header.glibcVersionRuntime;return null},Nf=(f)=>f.trim().split(/\s+/)[1],Hf=(f)=>{let[X,$,J]=f.split(/[\r\n]+/);if(X&&X.includes(p))return Nf(X);if($&&J&&$.includes(e))return Nf(J);return null},B6=async()=>{let f=null;if(K2()){if(f=await Q6(),!f)f=yf();if(!f){let X=await Wf();f=Hf(X)}}return f},U6=()=>{let f=null;if(K2()){if(f=I6(),!f)f=yf();if(!f){let X=Df();f=Hf(X)}}return f};Lf.exports={GLIBC:p,MUSL:e,family:Uf,familySync:Vf,isNonGlibcLinux:D6,isNonGlibcLinuxSync:x6,version:B6,versionSync:U6}});var Mf=i((k4,Ff)=>{var V6={ALLOW:0,DENY:1};Ff.exports=V6});var jf=i((q4,wf)=>{var x1={value:"SqliteError",writable:!0,enumerable:!1,configurable:!0};function f2(f,X,$){if(new.target!==f2)return new f2(f,X);if(typeof X!=="string")throw TypeError("Expected second argument to be a string");Error.call(this,f),x1.value=""+f,Object.defineProperty(this,"message",x1),Error.captureStackTrace(this,f2),this.code=X,this.rawCode=$}Object.setPrototypeOf(f2,Error);Object.setPrototypeOf(f2.prototype,Error.prototype);Object.defineProperty(f2.prototype,"name",x1);wf.exports=f2});var pf=i((C4,a2)=>{var __dirname="/Users/kyle/rules/node_modules/.pnpm/libsql@0.5.22/node_modules/libsql",{load:y6,currentTarget:H6}=$f(),{familySync:Ef,GLIBC:L6,MUSL:T6}=Tf();function F6(){if(process.env.LIBSQL_JS_DEV)return y6(__dirname);let f=H6();if(Ef()==L6)switch(f){case"linux-x64-musl":f="linux-x64-gnu";break;case"linux-arm64-musl":f="linux-arm64-gnu";break}if(f==="linux-arm-gnueabihf"&&Ef()==T6)f="linux-arm-musleabihf";return d(`@libsql/${f}`)}var{databaseOpen:M6,databaseOpenWithSync:w6,databaseInTransaction:j6,databaseInterrupt:E6,databaseClose:h6,databaseSyncSync:P6,databaseSyncUntilSync:k6,databaseExecSync:q6,databasePrepareSync:C6,databaseDefaultSafeIntegers:b6,databaseAuthorizer:p6,databaseLoadExtension:v6,databaseMaxWriteReplicationIndex:S6,statementRaw:g6,statementIsReader:u6,statementGet:hf,statementRun:Pf,statementInterrupt:i6,statementRowsSync:kf,statementColumns:d6,statementSafeIntegers:n6,rowsNext:m6}=F6(),c6=Mf(),qf=jf();function z2(f){if(f.libsqlError)return new qf(f.message,f.code,f.rawCode);return f}class Cf{constructor(f,X){let $=X?.encryptionCipher??"aes256cbc";if(X&&X.syncUrl){var J="";if(X.syncAuth)console.warn("Warning: The `syncAuth` option is deprecated, please use `authToken` option instead."),J=X.syncAuth;else if(X.authToken)J=X.authToken;let A=X?.encryptionKey??"",Z=X?.syncPeriod??0,Y=X?.readYourWrites??!0,_=X?.offline??!1,N=X?.remoteEncryptionKey??"";this.db=w6(f,X.syncUrl,J,$,A,Z,Y,_,N)}else{let A=X?.authToken??"",Z=X?.encryptionKey??"",Y=X?.timeout??0,_=X?.remoteEncryptionKey??"";this.db=M6(f,A,$,Z,Y,_)}this.memory=f===":memory:",this.readonly=!1,this.name="",this.open=!0;let R=this.db;Object.defineProperties(this,{inTransaction:{get(){return j6(R)}}})}sync(){return P6.call(this.db)}syncUntil(f){return k6.call(this.db,f)}prepare(f){try{let X=C6.call(this.db,f);return new bf(X)}catch(X){throw z2(X)}}transaction(f){if(typeof f!=="function")throw TypeError("Expected first argument to be a function");let X=this,$=(R)=>{return(...A)=>{X.exec("BEGIN "+R);try{let Z=f(...A);return X.exec("COMMIT"),Z}catch(Z){throw X.exec("ROLLBACK"),Z}}},J={default:{value:$("")},deferred:{value:$("DEFERRED")},immediate:{value:$("IMMEDIATE")},exclusive:{value:$("EXCLUSIVE")},database:{value:this,enumerable:!0}};return Object.defineProperties(J.default.value,J),Object.defineProperties(J.deferred.value,J),Object.defineProperties(J.immediate.value,J),Object.defineProperties(J.exclusive.value,J),J.default.value}pragma(f,X){if(X==null)X={};if(typeof f!=="string")throw TypeError("Expected first argument to be a string");if(typeof X!=="object")throw TypeError("Expected second argument to be an options object");let $=X.simple,J=this.prepare(`PRAGMA ${f}`,this,!0);return $?J.pluck().get():J.all()}backup(f,X){throw Error("not implemented")}serialize(f){throw Error("not implemented")}function(f,X,$){if(X==null)X={};if(typeof X==="function")$=X,X={};if(typeof f!=="string")throw TypeError("Expected first argument to be a string");if(typeof $!=="function")throw TypeError("Expected last argument to be a function");if(typeof X!=="object")throw TypeError("Expected second argument to be an options object");if(!f)throw TypeError("User-defined function name cannot be an empty string");throw Error("not implemented")}aggregate(f,X){if(typeof f!=="string")throw TypeError("Expected first argument to be a string");if(typeof X!=="object"||X===null)throw TypeError("Expected second argument to be an options object");if(!f)throw TypeError("User-defined function name cannot be an empty string");throw Error("not implemented")}table(f,X){if(typeof f!=="string")throw TypeError("Expected first argument to be a string");if(!f)throw TypeError("Virtual table module name cannot be an empty string");throw Error("not implemented")}authorizer(f){p6.call(this.db,f)}loadExtension(...f){v6.call(this.db,...f)}maxWriteReplicationIndex(){return S6.call(this.db)}exec(f){try{q6.call(this.db,f)}catch(X){throw z2(X)}}interrupt(){E6.call(this.db)}close(){h6.call(this.db),this.open=!1}defaultSafeIntegers(f){return b6.call(this.db,f??!0),this}unsafeMode(...f){throw Error("not implemented")}}class bf{constructor(f){this.stmt=f,this.pluckMode=!1}raw(f){return g6.call(this.stmt,f??!0),this}pluck(f){return this.pluckMode=f??!0,this}get reader(){return u6.call(this.stmt)}run(...f){try{if(f.length==1&&typeof f[0]==="object")return Pf.call(this.stmt,f[0]);else return Pf.call(this.stmt,f.flat())}catch(X){throw z2(X)}}get(...f){try{if(f.length==1&&typeof f[0]==="object")return hf.call(this.stmt,f[0]);else return hf.call(this.stmt,f.flat())}catch(X){throw z2(X)}}iterate(...f){var X=void 0;if(f.length==1&&typeof f[0]==="object")X=kf.call(this.stmt,f[0]);else X=kf.call(this.stmt,f.flat());return{nextRows:Array(100),nextRowIndex:100,next(){try{if(this.nextRowIndex===100)m6.call(X,this.nextRows),this.nextRowIndex=0;let J=this.nextRows[this.nextRowIndex];if(this.nextRows[this.nextRowIndex]=void 0,!J)return{done:!0};return this.nextRowIndex++,{value:J,done:!1}}catch(J){throw z2(J)}},[Symbol.iterator](){return this}}}all(...f){try{let X=[];for(let $ of this.iterate(...f))if(this.pluckMode)X.push($[Object.keys($)[0]]);else X.push($);return X}catch(X){throw z2(X)}}interrupt(){i6.call(this.stmt)}columns(){return d6.call(this.stmt)}safeIntegers(f){return n6.call(this.stmt,f??!0),this}}a2.exports=Cf;a2.exports.Authorization=c6;a2.exports.SqliteError=qf});var k1=i((g$,L0)=>{function O4(f){var X=0,$=[];function J(){if(X--,X<f)R()}function R(){var _=$.shift();if(Y.queue=$.length,_)Z(_.fn).then(_.resolve).catch(_.reject)}function A(_){return new Promise(function(N,y){$.push({fn:_,resolve:N,reject:y}),Y.queue=$.length})}function Z(_){X++;try{return Promise.resolve(_()).then(function(N){return J(),N},function(N){throw J(),N})}catch(N){return J(),Promise.reject(N)}}var Y=function(_){if(X>=f)return A(_);else return Z(_)};return Y}function W4(f,X){var $=!1,J=this;return Promise.all(f.map(function(){var R=arguments;return J(function(){if(!$)return X.apply(void 0,R).catch(function(A){throw $=!0,A})})}))}function H0(f){return f.queue=0,f.map=W4,f}L0.exports=function(f){if(f)return H0(O4(f));else return H0(function(X){return X()})}});import*as G1 from"node:fs";import*as q1 from"node:path";class K extends Error{code;rawCode;constructor(f,X,$,J){if(X!==void 0)f=`${X}: ${f}`;super(f,{cause:J});this.code=X,this.rawCode=$,this.name="LibsqlError"}}function C1(f){let X=p0.exec(f);if(X===null)throw new K(`The URL '${f}' is not in a valid format`,"URL_INVALID");let $=X.groups,J=$.scheme,R=$.authority!==void 0?v0($.authority):void 0,A=r($.path),Z=$.query!==void 0?g0($.query):void 0,Y=$.fragment!==void 0?r($.fragment):void 0;return{scheme:J,authority:R,path:A,query:Z,fragment:Y}}var p0=(()=>{return new RegExp("^(?<scheme>[A-Za-z][A-Za-z.+-]*):(//(?<authority>[^/?#]*))?(?<path>[^?#]*)(\\?(?<query>[^#]*))?(#(?<fragment>.*))?$","su")})();function v0(f){let X=S0.exec(f);if(X===null)throw new K("The authority part of the URL is not in a valid format","URL_INVALID");let $=X.groups,J=r($.host_br??$.host),R=$.port?parseInt($.port,10):void 0,A=$.username!==void 0?{username:r($.username),password:$.password!==void 0?r($.password):void 0}:void 0;return{host:J,port:R,userinfo:A}}var S0=(()=>{return new RegExp("^((?<username>[^:]*)(:(?<password>.*))?@)?((?<host>[^:\\[\\]]*)|(\\[(?<host_br>[^\\[\\]]*)\\]))(:(?<port>[0-9]*))?$","su")})();function g0(f){let X=f.split("&"),$=[];for(let J of X){if(J==="")continue;let R,A,Z=J.indexOf("=");if(Z<0)R=J,A="";else R=J.substring(0,Z),A=J.substring(Z+1);$.push({key:r(R.replaceAll("+"," ")),value:r(A.replaceAll("+"," "))})}return{pairs:$}}function r(f){try{return decodeURIComponent(f)}catch(X){if(X instanceof URIError)throw new K(`URL component has invalid percent encoding: ${X}`,"URL_INVALID",void 0,X);throw X}}function F2(f,X,$){if(X===void 0)throw new K(`URL with scheme ${JSON.stringify(f+":")} requires authority (the "//" part)`,"URL_INVALID");let J=`${f}:`,R=u0(X.host),A=i0(X.port),Y=`//${d0(X.userinfo)}${R}${A}`,_=$.split("/").map(encodeURIComponent).join("/");if(_!==""&&!_.startsWith("/"))_="/"+_;return new URL(`${J}${Y}${_}`)}function u0(f){return f.includes(":")?`[${encodeURI(f)}]`:encodeURI(f)}function i0(f){return f!==void 0?`:${f}`:""}function d0(f){if(f===void 0)return"";let X=encodeURIComponent(f.username),$=f.password!==void 0?`:${encodeURIComponent(f.password)}`:"";return`${X}${$}@`}var _2=typeof Buffer==="function",b1=typeof TextDecoder==="function"?new TextDecoder:void 0,p1=typeof TextEncoder==="function"?new TextEncoder:void 0;var M2=Array.prototype.slice.call("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="),l2=((f)=>{let X={};return f.forEach(($,J)=>X[$]=J),X})(M2),n0=/^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/,U=String.fromCharCode.bind(String),v1=typeof Uint8Array.from==="function"?Uint8Array.from.bind(Uint8Array):(f)=>new Uint8Array(Array.prototype.slice.call(f,0)),u1=(f)=>f.replace(/=/g,"").replace(/[+\/]/g,(X)=>X=="+"?"-":"_"),i1=(f)=>f.replace(/[^A-Za-z0-9\+\/]/g,""),d1=(f)=>{let X,$,J,R,A="",Z=f.length%3;for(let Y=0;Y<f.length;){if(($=f.charCodeAt(Y++))>255||(J=f.charCodeAt(Y++))>255||(R=f.charCodeAt(Y++))>255)throw TypeError("invalid character found");X=$<<16|J<<8|R,A+=M2[X>>18&63]+M2[X>>12&63]+M2[X>>6&63]+M2[X&63]}return Z?A.slice(0,Z-3)+"===".substring(Z):A},O1=typeof btoa==="function"?(f)=>btoa(f):_2?(f)=>Buffer.from(f,"binary").toString("base64"):d1,K1=_2?(f)=>Buffer.from(f).toString("base64"):(f)=>{let $=[];for(let J=0,R=f.length;J<R;J+=4096)$.push(U.apply(null,f.subarray(J,J+4096)));return O1($.join(""))},t2=(f,X=!1)=>X?u1(K1(f)):K1(f),m0=(f)=>{if(f.length<2){var X=f.charCodeAt(0);return X<128?f:X<2048?U(192|X>>>6)+U(128|X&63):U(224|X>>>12&15)+U(128|X>>>6&63)+U(128|X&63)}else{var X=65536+(f.charCodeAt(0)-55296)*1024+(f.charCodeAt(1)-56320);return U(240|X>>>18&7)+U(128|X>>>12&63)+U(128|X>>>6&63)+U(128|X&63)}},c0=/[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g,n1=(f)=>f.replace(c0,m0),S1=_2?(f)=>Buffer.from(f,"utf8").toString("base64"):p1?(f)=>K1(p1.encode(f)):(f)=>O1(n1(f)),Y2=(f,X=!1)=>X?u1(S1(f)):S1(f),g1=(f)=>Y2(f,!0),l0=/[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g,t0=(f)=>{switch(f.length){case 4:var X=(7&f.charCodeAt(0))<<18|(63&f.charCodeAt(1))<<12|(63&f.charCodeAt(2))<<6|63&f.charCodeAt(3),$=X-65536;return U(($>>>10)+55296)+U(($&1023)+56320);case 3:return U((15&f.charCodeAt(0))<<12|(63&f.charCodeAt(1))<<6|63&f.charCodeAt(2));default:return U((31&f.charCodeAt(0))<<6|63&f.charCodeAt(1))}},m1=(f)=>f.replace(l0,t0),c1=(f)=>{if(f=f.replace(/\s+/g,""),!n0.test(f))throw TypeError("malformed base64.");f+="==".slice(2-(f.length&3));let X,$,J,R=[];for(let A=0;A<f.length;)if(X=l2[f.charAt(A++)]<<18|l2[f.charAt(A++)]<<12|($=l2[f.charAt(A++)])<<6|(J=l2[f.charAt(A++)]),$===64)R.push(U(X>>16&255));else if(J===64)R.push(U(X>>16&255,X>>8&255));else R.push(U(X>>16&255,X>>8&255,X&255));return R.join("")},W1=typeof atob==="function"?(f)=>atob(i1(f)):_2?(f)=>Buffer.from(f,"base64").toString("binary"):c1,l1=_2?(f)=>v1(Buffer.from(f,"base64")):(f)=>v1(W1(f).split("").map((X)=>X.charCodeAt(0))),t1=(f)=>l1(s1(f)),s0=_2?(f)=>Buffer.from(f,"base64").toString("utf8"):b1?(f)=>b1.decode(l1(f)):(f)=>m1(W1(f)),s1=(f)=>i1(f.replace(/[-_]/g,(X)=>X=="-"?"+":"/")),z1=(f)=>s0(s1(f)),a0=(f)=>{if(typeof f!=="string")return!1;let X=f.replace(/\s+/g,"").replace(/={0,2}$/,"");return!/[^\s0-9a-zA-Z\+/]/.test(X)||!/[^\s0-9a-zA-Z\-_]/.test(X)},a1=(f)=>{return{value:f,enumerable:!1,writable:!0,configurable:!0}},o1=function(){let f=(X,$)=>Object.defineProperty(String.prototype,X,a1($));f("fromBase64",function(){return z1(this)}),f("toBase64",function(X){return Y2(this,X)}),f("toBase64URI",function(){return Y2(this,!0)}),f("toBase64URL",function(){return Y2(this,!0)}),f("toUint8Array",function(){return t1(this)})},r1=function(){let f=(X,$)=>Object.defineProperty(Uint8Array.prototype,X,a1($));f("toBase64",function(X){return t2(this,X)}),f("toBase64URI",function(){return t2(this,!0)}),f("toBase64URL",function(){return t2(this,!0)})},o0=()=>{o1(),r1()},N2={version:"3.7.8",VERSION:"3.7.8",atob:W1,atobPolyfill:c1,btoa:O1,btoaPolyfill:d1,fromBase64:z1,toBase64:Y2,encode:Y2,encodeURI:g1,encodeURL:g1,utob:n1,btou:m1,decode:z1,isValid:a0,fromUint8Array:t2,toUint8Array:t1,extendString:o1,extendUint8Array:r1,extendBuiltins:o0};var h="https://github.com/libsql/libsql-client-ts#supported-urls";function u(f){if(f==="write")return"BEGIN IMMEDIATE";else if(f==="read")return"BEGIN TRANSACTION READONLY";else if(f==="deferred")return"BEGIN DEFERRED";else throw RangeError('Unknown transaction mode, supported values are "write", "read" and "deferred"')}class G2{columns;columnTypes;rows;rowsAffected;lastInsertRowid;constructor(f,X,$,J,R){this.columns=f,this.columnTypes=X,this.rows=$,this.rowsAffected=J,this.lastInsertRowid=R}toJSON(){return{columns:this.columns,columnTypes:this.columnTypes,rows:this.rows.map(r0),rowsAffected:this.rowsAffected,lastInsertRowid:this.lastInsertRowid!==void 0?""+this.lastInsertRowid:null}}}function r0(f){return Array.prototype.map.call(f,e0)}function e0(f){if(typeof f==="bigint")return""+f;else if(f instanceof ArrayBuffer)return N2.fromUint8Array(new Uint8Array(f));else return f}var e1=":memory:";function ff(f){return f.scheme==="file"&&(f.path===":memory:"||f.path.startsWith(":memory:?"))}function w2(f,X){if(typeof f!=="object")throw TypeError(`Expected client configuration as object, got ${typeof f}`);let{url:$,authToken:J,tls:R,intMode:A,concurrency:Z}=f;Z=Math.max(0,Z||20),A??="number";let Y=[];if($===e1)$="file::memory:";let _=C1($),N=_.scheme.toLowerCase(),y=N==="file"&&_.path===e1&&_.authority===void 0,C;if(y)C={cache:{values:["shared","private"],update:(M,b)=>Y.push(`${M}=${b}`)}};else C={tls:{values:["0","1"],update:(M,b)=>R=b==="1"},authToken:{update:(M,b)=>J=b}};for(let{key:M,value:b}of _.query?.pairs??[]){if(!Object.hasOwn(C,M))throw new K(`Unsupported URL query parameter ${JSON.stringify(M)}`,"URL_PARAM_NOT_SUPPORTED");let T2=C[M];if(T2.values!==void 0&&!T2.values.includes(b))throw new K(`Unknown value for the "${M}" query argument: ${JSON.stringify(b)}. Supported values are: [${T2.values.map((b0)=>'"'+b0+'"').join(", ")}]`,"URL_INVALID");if(T2.update!==void 0)T2?.update(M,b)}let E=Y.length===0?"":`?${Y.join("&")}`,o=_.path+E,B;if(N==="libsql")if(R===!1){if(_.authority?.port===void 0)throw new K('A "libsql:" URL with ?tls=0 must specify an explicit port',"URL_INVALID");B=X?"http":"ws"}else B=X?"https":"wss";else B=N;if(B==="http"||B==="ws")R??=!1;else R??=!0;if(B!=="http"&&B!=="ws"&&B!=="https"&&B!=="wss"&&B!=="file")throw new K(`The client supports only "libsql:", "wss:", "ws:", "https:", "http:" and "file:" URLs, got ${JSON.stringify(_.scheme+":")}. For more information, please read ${h}`,"URL_SCHEME_NOT_SUPPORTED");if(A!=="number"&&A!=="bigint"&&A!=="string")throw TypeError(`Invalid value for intMode, expected "number", "bigint" or "string", got ${JSON.stringify(A)}`);if(_.fragment!==void 0)throw new K(`URL fragments are not supported: ${JSON.stringify("#"+_.fragment)}`,"URL_INVALID");if(y)return{scheme:"file",tls:!1,path:o,intMode:A,concurrency:Z,syncUrl:f.syncUrl,syncInterval:f.syncInterval,readYourWrites:f.readYourWrites,offline:f.offline,fetch:f.fetch,authToken:void 0,encryptionKey:void 0,authority:void 0};return{scheme:B,tls:R,authority:_.authority,path:o,authToken:J,intMode:A,concurrency:Z,encryptionKey:f.encryptionKey,syncUrl:f.syncUrl,syncInterval:f.syncInterval,readYourWrites:f.readYourWrites,offline:f.offline,fetch:f.fetch}}var j2=Q1(pf(),1);import{Buffer as Sf}from"node:buffer";function gf(f){if(f.scheme!=="file")throw new K(`URL scheme ${JSON.stringify(f.scheme+":")} is not supported by the local sqlite3 client. For more information, please read ${h}`,"URL_SCHEME_NOT_SUPPORTED");let X=f.authority;if(X!==void 0){let Z=X.host.toLowerCase();if(Z!==""&&Z!=="localhost")throw new K(`Invalid host in file URL: ${JSON.stringify(X.host)}. A "file:" URL with an absolute path should start with one slash ("file:/absolute/path.db") or with three slashes ("file:///absolute/path.db"). For more information, please read ${h}`,"URL_INVALID");if(X.port!==void 0)throw new K("File URL cannot have a port","URL_INVALID");if(X.userinfo!==void 0)throw new K("File URL cannot have username and password","URL_INVALID")}let $=ff(f);if($&&f.syncUrl)throw new K(`Embedded replica must use file for local db but URI with in-memory mode were provided instead: ${f.path}`,"URL_INVALID");let J=f.path;if($)J=`${f.scheme}:${f.path}`;let R={authToken:f.authToken,encryptionKey:f.encryptionKey,syncUrl:f.syncUrl,syncPeriod:f.syncInterval,readYourWrites:f.readYourWrites,offline:f.offline},A=new j2.default(J,R);return I(A,"SELECT 1 AS checkThatTheDatabaseCanBeOpened",f.intMode),new uf(J,R,A,f.intMode)}class uf{#f;#X;#$;#J;closed;protocol;constructor(f,X,$,J){this.#f=f,this.#X=X,this.#$=$,this.#J=J,this.closed=!1,this.protocol="file"}async execute(f,X){let $;if(typeof f==="string")$={sql:f,args:X||[]};else $=f;return this.#R(),I(this.#A(),$,this.#J)}async batch(f,X="deferred"){this.#R();let $=this.#A();try{I($,u(X),this.#J);let J=f.map((R)=>{if(!$.inTransaction)throw new K("The transaction has been rolled back","TRANSACTION_CLOSED");let A=Array.isArray(R)?{sql:R[0],args:R[1]||[]}:R;return I($,A,this.#J)});return I($,"COMMIT",this.#J),J}finally{if($.inTransaction)I($,"ROLLBACK",this.#J)}}async migrate(f){this.#R();let X=this.#A();try{I(X,"PRAGMA foreign_keys=off",this.#J),I(X,u("deferred"),this.#J);let $=f.map((J)=>{if(!X.inTransaction)throw new K("The transaction has been rolled back","TRANSACTION_CLOSED");return I(X,J,this.#J)});return I(X,"COMMIT",this.#J),$}finally{if(X.inTransaction)I(X,"ROLLBACK",this.#J);I(X,"PRAGMA foreign_keys=on",this.#J)}}async transaction(f="write"){let X=this.#A();return I(X,u(f),this.#J),this.#$=null,new df(X,this.#J)}async executeMultiple(f){this.#R();let X=this.#A();try{return nf(X,f)}finally{if(X.inTransaction)I(X,"ROLLBACK",this.#J)}}async sync(){this.#R();let f=await this.#A().sync();return{frames_synced:f.frames_synced,frame_no:f.frame_no}}async reconnect(){try{if(!this.closed&&this.#$!==null)this.#$.close()}finally{this.#$=new j2.default(this.#f,this.#X),this.closed=!1}}close(){if(this.closed=!0,this.#$!==null)this.#$.close(),this.#$=null}#R(){if(this.closed)throw new K("The client is closed","CLIENT_CLOSED")}#A(){if(this.#$===null)this.#$=new j2.default(this.#f,this.#X);return this.#$}}class df{#f;#X;constructor(f,X){this.#f=f,this.#X=X}async execute(f,X){let $;if(typeof f==="string")$={sql:f,args:X||[]};else $=f;return this.#$(),I(this.#f,$,this.#X)}async batch(f){return f.map((X)=>{this.#$();let $=Array.isArray(X)?{sql:X[0],args:X[1]||[]}:X;return I(this.#f,$,this.#X)})}async executeMultiple(f){return this.#$(),nf(this.#f,f)}async rollback(){if(!this.#f.open)return;this.#$(),I(this.#f,"ROLLBACK",this.#X)}async commit(){this.#$(),I(this.#f,"COMMIT",this.#X)}close(){if(this.#f.inTransaction)I(this.#f,"ROLLBACK",this.#X)}get closed(){return!this.#f.inTransaction}#$(){if(this.closed)throw new K("The transaction is closed","TRANSACTION_CLOSED")}}function I(f,X,$){let J,R;if(typeof X==="string")J=X,R=[];else if(J=X.sql,Array.isArray(X.args))R=X.args.map((A)=>vf(A,$));else{R={};for(let A in X.args){let Z=A[0]==="@"||A[0]==="$"||A[0]===":"?A.substring(1):A;R[Z]=vf(X.args[A],$)}}try{let A=f.prepare(J);A.safeIntegers(!0);let Z=!0;try{A.raw(!0)}catch{Z=!1}if(Z){let Y=Array.from(A.columns().map((E)=>E.name)),_=Array.from(A.columns().map((E)=>E.type??"")),N=A.all(R).map((E)=>{return l6(E,Y,$)}),y=0,C=void 0;return new G2(Y,_,N,0,void 0)}else{let Y=A.run(R),_=Y.changes,N=BigInt(Y.lastInsertRowid);return new G2([],[],[],_,N)}}catch(A){throw mf(A)}}function l6(f,X,$){let J={};Object.defineProperty(J,"length",{value:f.length});for(let R=0;R<f.length;++R){let A=t6(f[R],$);Object.defineProperty(J,R,{value:A});let Z=X[R];if(!Object.hasOwn(J,Z))Object.defineProperty(J,Z,{value:A,enumerable:!0,configurable:!0,writable:!0})}return J}function t6(f,X){if(typeof f==="bigint")if(X==="number"){if(f<s6||f>a6)throw RangeError("Received integer which cannot be safely represented as a JavaScript number");return Number(f)}else if(X==="bigint")return f;else if(X==="string")return""+f;else throw Error("Invalid value for IntMode");else if(f instanceof Sf)return f.buffer;return f}var s6=-9007199254740991n,a6=9007199254740991n;function vf(f,X){if(typeof f==="number"){if(!Number.isFinite(f))throw RangeError("Only finite numbers (not Infinity or NaN) can be passed as arguments");return f}else if(typeof f==="bigint"){if(f<o6||f>r6)throw RangeError("bigint is too large to be represented as a 64-bit integer and passed as argument");return f}else if(typeof f==="boolean")switch(X){case"bigint":return f?1n:0n;case"string":return f?"1":"0";default:return f?1:0}else if(f instanceof ArrayBuffer)return Sf.from(f);else if(f instanceof Date)return f.valueOf();else if(f===void 0)throw TypeError("undefined cannot be passed as argument to the database");else return f}var o6=-9223372036854775808n,r6=9223372036854775807n;function nf(f,X){try{f.exec(X)}catch($){throw mf($)}}function mf(f){if(f instanceof j2.default.SqliteError)return new K(f.message,f.code,f.rawCode,f);return f}class O2{constructor(){this.intMode="number"}intMode}class O extends Error{constructor(f){super(f);this.name="ClientError"}}class G extends O{constructor(f){super(f);this.name="ProtoError"}}class h2 extends O{code;proto;constructor(f,X){super(f);this.name="ResponseError",this.code=X.code,this.proto=X,this.stack=void 0}}class x extends O{constructor(f,X){if(X!==void 0){super(`${f}: ${X}`);this.cause=X}else super(f);this.name="ClosedError"}}class P2 extends O{constructor(f){super(f);this.name="WebSocketUnsupportedError"}}class W2 extends O{constructor(f){super(f);this.name="WebSocketError"}}class X2 extends O{status;constructor(f,X){super(f);this.status=X,this.name="HttpServerError"}}class w extends O{constructor(f){super(f);this.name="ProtocolVersionError"}}class V extends O{constructor(f){super(f);this.name="InternalError"}}class q extends O{constructor(f){super(f);this.name="MisuseError"}}function H(f){if(typeof f==="string")return f;throw D2(f,"string")}function L(f){if(f===null||f===void 0)return;else if(typeof f==="string")return f;throw D2(f,"string or null")}function v(f){if(typeof f==="number")return f;throw D2(f,"number")}function m(f){if(typeof f==="boolean")return f;throw D2(f,"boolean")}function k2(f){if(Array.isArray(f))return f;throw D2(f,"array")}function Q(f){if(f!==null&&typeof f==="object"&&!Array.isArray(f))return f;throw D2(f,"object")}function j(f,X){return k2(f).map(($)=>X(Q($)))}function D2(f,X){if(f===void 0)return new G(`Expected ${X}, but the property was missing`);let $=typeof f;if(f===null)$="null";else if(Array.isArray(f))$="array";return new G(`Expected ${X}, received ${$}`)}function $2(f,X){return X(Q(f))}class cf{#f;#X;constructor(f){this.#f=f,this.#X=!1}begin(){this.#f.push("{"),this.#X=!0}end(){this.#f.push("}"),this.#X=!1}#$(f){if(this.#X)this.#f.push('"'),this.#X=!1;else this.#f.push(',"');this.#f.push(f),this.#f.push('":')}string(f,X){this.#$(f),this.#f.push(JSON.stringify(X))}stringRaw(f,X){this.#$(f),this.#f.push('"'),this.#f.push(X),this.#f.push('"')}number(f,X){this.#$(f),this.#f.push(""+X)}boolean(f,X){this.#$(f),this.#f.push(X?"true":"false")}object(f,X,$){this.#$(f),this.begin(),$(this,X),this.end()}arrayObjects(f,X,$){this.#$(f),this.#f.push("[");for(let J=0;J<X.length;++J){if(J!==0)this.#f.push(",");this.begin(),$(this,X[J]),this.end()}this.#f.push("]")}}function q2(f,X){let $=[],J=new cf($);return J.begin(),X(J,f),J.end(),$.join("")}var J2=0,C2=1,b2=2;var lf=5;class tf{#f;#X;#$;constructor(f){this.#f=f,this.#X=new DataView(f.buffer,f.byteOffset,f.byteLength),this.#$=0}varint(){let f=0;for(let X=0;;X+=7){let $=this.#f[this.#$++];if(f|=($&127)<<X,!($&128))break}return f}varintBig(){let f=0n;for(let X=0n;;X+=7n){let $=this.#f[this.#$++];if(f|=BigInt($&127)<<X,!($&128))break}return f}bytes(f){let X=new Uint8Array(this.#f.buffer,this.#f.byteOffset+this.#$,f);return this.#$+=f,X}double(){let f=this.#X.getFloat64(this.#$,!0);return this.#$+=8,f}skipVarint(){for(;;)if(!(this.#f[this.#$++]&128))break}skip(f){this.#$+=f}eof(){return this.#$>=this.#f.byteLength}}class sf{#f;#X;constructor(f){this.#f=f,this.#X=-1}setup(f){this.#X=f}#$(f){if(this.#X!==f)throw new G(`Expected wire type ${f}, got ${this.#X}`);this.#X=-1}bytes(){this.#$(b2);let f=this.#f.varint();return this.#f.bytes(f)}string(){return new TextDecoder().decode(this.bytes())}message(f){return c(this.bytes(),f)}int32(){return this.#$(J2),this.#f.varint()}uint32(){return this.int32()}bool(){return this.int32()!==0}uint64(){return this.#$(J2),this.#f.varintBig()}sint64(){let f=this.uint64();return f>>1n^-(f&1n)}double(){return this.#$(C2),this.#f.double()}maybeSkip(){if(this.#X<0)return;else if(this.#X===J2)this.#f.skipVarint();else if(this.#X===C2)this.#f.skip(8);else if(this.#X===b2){let f=this.#f.varint();this.#f.skip(f)}else if(this.#X===lf)this.#f.skip(4);else throw new G(`Unexpected wire type ${this.#X}`);this.#X=-1}}function c(f,X){let $=new tf(f),J=new sf($),R=X.default();while(!$.eof()){let A=$.varint(),Z=A>>3,Y=A&7;J.setup(Y);let _=X[Z];if(_!==void 0){let N=_(J,R);if(N!==void 0)R=N}J.maybeSkip()}return R}class I1{#f;#X;#$;#J;constructor(){this.#f=new ArrayBuffer(256),this.#X=new Uint8Array(this.#f),this.#$=new DataView(this.#f),this.#J=0}#R(f){if(this.#J+f<=this.#f.byteLength)return;let X=this.#f.byteLength;while(X<this.#J+f)X*=2;let $=new ArrayBuffer(X),J=new Uint8Array($),R=new DataView($);J.set(new Uint8Array(this.#f,0,this.#J)),this.#f=$,this.#X=J,this.#$=R}#A(f){this.#R(5),f=0|f;do{let X=f&127;f>>>=7,X|=f?128:0,this.#X[this.#J++]=X}while(f)}#Y(f){this.#R(10),f=f&0xffffffffffffffffn;do{let X=Number(f&0x7fn);f>>=7n,X|=f?128:0,this.#X[this.#J++]=X}while(f)}#Z(f,X){this.#A(f<<3|X)}bytes(f,X){this.#Z(f,b2),this.#A(X.byteLength),this.#R(X.byteLength),this.#X.set(X,this.#J),this.#J+=X.byteLength}string(f,X){this.bytes(f,new TextEncoder().encode(X))}message(f,X,$){let J=new I1;$(J,X),this.bytes(f,J.data())}int32(f,X){this.#Z(f,J2),this.#A(X)}uint32(f,X){this.int32(f,X)}bool(f,X){this.int32(f,X?1:0)}sint64(f,X){this.#Z(f,J2),this.#Y(X<<1n^X>>63n)}double(f,X){this.#Z(f,C2),this.#R(8),this.#$.setFloat64(this.#J,X,!0),this.#J+=8}data(){return new Uint8Array(this.#f,0,this.#J)}}function p2(f,X){let $=new I1;return X($,f),$.data()}class l{#f;#X;constructor(){this.#f=new Set,this.#X=new Set}alloc(){for(let X of this.#X){if(this.#X.delete(X),this.#f.add(X),!this.#f.has(this.#f.size-1))this.#X.add(this.#f.size-1);return X}let f=this.#f.size;return this.#f.add(f),f}free(f){if(!this.#f.delete(f))throw new V("Freeing an id that is not allocated");if(this.#X.delete(this.#f.size),f<this.#f.size)this.#X.add(f)}}function z(f,X){throw new V(X)}function x2(f){if(f===null)return null;else if(typeof f==="string")return f;else if(typeof f==="number"){if(!Number.isFinite(f))throw RangeError("Only finite numbers (not Infinity or NaN) can be passed as arguments");return f}else if(typeof f==="bigint"){if(f<f3||f>X3)throw RangeError("This bigint value is too large to be represented as a 64-bit integer and passed as argument");return f}else if(typeof f==="boolean")return f?1n:0n;else if(f instanceof ArrayBuffer)return new Uint8Array(f);else if(f instanceof Uint8Array)return f;else if(f instanceof Date)return+f.valueOf();else if(typeof f==="object")return""+f.toString();else throw TypeError("Unsupported type of value")}var f3=-9223372036854775808n,X3=9223372036854775807n;function B1(f,X){if(f===null)return null;else if(typeof f==="number")return f;else if(typeof f==="string")return f;else if(typeof f==="bigint")if(X==="number"){let $=Number(f);if(!Number.isSafeInteger($))throw RangeError("Received integer which is too large to be safely represented as a JavaScript number");return $}else if(X==="bigint")return f;else if(X==="string")return""+f;else throw new q("Invalid value for IntMode");else if(f instanceof Uint8Array)return f.slice().buffer;else if(f===void 0)throw new G("Received unrecognized type of Value");else throw z(f,"Impossible type of Value")}function R2(f){return{affectedRowCount:f.affectedRowCount,lastInsertRowid:f.lastInsertRowid,columnNames:f.cols.map((X)=>X.name),columnDecltypes:f.cols.map((X)=>X.decltype)}}function r2(f,X){let $=R2(f),J=f.rows.map((R)=>af($.columnNames,R,X));return{...$,rows:J}}function e2(f,X){let $=R2(f),J;if(f.rows.length>0)J=af($.columnNames,f.rows[0],X);return{...$,row:J}}function f1(f,X){let $=R2(f),J;if(f.rows.length>0&&$.columnNames.length>0)J=B1(f.rows[0][0],X);return{...$,value:J}}function af(f,X,$){let J={};Object.defineProperty(J,"length",{value:X.length});for(let R=0;R<X.length;++R){let A=B1(X[R],$);Object.defineProperty(J,R,{value:A});let Z=f[R];if(Z!==void 0&&!Object.hasOwn(J,Z))Object.defineProperty(J,Z,{value:A,enumerable:!0,configurable:!0,writable:!0})}return J}function S(f){return new h2(f.message,f)}class A2{#f;#X;#$;constructor(f,X){this.#f=f,this.#X=X,this.#$=void 0}_getSqlId(f){if(this.#f!==f)throw new q("Attempted to use SQL text opened with other object");else if(this.#$!==void 0)throw new x("SQL text is closed",this.#$);return this.#X}close(){this._setClosed(new O("SQL text was manually closed"))}_setClosed(f){if(this.#$===void 0)this.#$=f,this.#f._closeSql(this.#X)}get closed(){return this.#$!==void 0}}function v2(f,X){if(X instanceof A2)return{sqlId:X._getSqlId(f)};else return{sql:""+X}}class t{#f;#X;constructor(){this.#f=[],this.#X=[]}get length(){return this.#f.length+this.#X.length}push(f){this.#f.push(f)}shift(){if(this.#X.length===0&&this.#f.length>0)this.#X=this.#f.reverse(),this.#f=[];return this.#X.pop()}first(){return this.#X.length!==0?this.#X[this.#X.length-1]:this.#f[0]}}class S2{sql;_args;_namedArgs;constructor(f){this.sql=f,this._args=[],this._namedArgs=new Map}bindIndexes(f){this._args.length=0;for(let X of f)this._args.push(x2(X));return this}bindIndex(f,X){if(f!==(f|0)||f<=0)throw RangeError("Index of a positional argument must be positive integer");while(this._args.length<f)this._args.push(null);return this._args[f-1]=x2(X),this}bindName(f,X){return this._namedArgs.set(f,x2(X)),this}unbindAll(){return this._args.length=0,this._namedArgs.clear(),this}}function X1(f,X,$){let J,R=[],A=[];if(X instanceof S2){J=X.sql,R=X._args;for(let[_,N]of X._namedArgs.entries())A.push({name:_,value:N})}else if(Array.isArray(X))if(J=X[0],Array.isArray(X[1]))R=X[1].map((_)=>x2(_));else A=Object.entries(X[1]).map(([_,N])=>{return{name:_,value:x2(N)}});else J=X;let{sql:Z,sqlId:Y}=v2(f,J);return{sql:Z,sqlId:Y,args:R,namedArgs:A,wantRows:$}}class $1{_stream;#f;_steps;#X;constructor(f,X){this._stream=f,this.#f=X,this._steps=[],this.#X=!1}step(){return new U1(this)}execute(){if(this.#X)throw new q("This batch has already been executed");this.#X=!0;let f={steps:this._steps.map((X)=>X.proto)};if(this.#f)return J3(this._stream,this._steps,f);else return $3(this._stream,this._steps,f)}}function $3(f,X,$){return f._batch($).then((J)=>{for(let R=0;R<X.length;++R){let A=J.stepResults.get(R),Z=J.stepErrors.get(R);X[R].callback(A,Z)}})}async function J3(f,X,$){let J=await f._openCursor($);try{let R=0,A=void 0,Z=[];for(;;){let Y=await J.next();if(Y===void 0)break;if(Y.type==="step_begin"){if(Y.step<R||Y.step>=X.length)throw new G("Server produced StepBeginEntry for unexpected step");else if(A!==void 0)throw new G("Server produced StepBeginEntry before terminating previous step");for(let _=R;_<Y.step;++_)X[_].callback(void 0,void 0);R=Y.step+1,A=Y,Z=[]}else if(Y.type==="step_end"){if(A===void 0)throw new G("Server produced StepEndEntry but no step is active");let _={cols:A.cols,rows:Z,affectedRowCount:Y.affectedRowCount,lastInsertRowid:Y.lastInsertRowid};X[A.step].callback(_,void 0),A=void 0,Z=[]}else if(Y.type==="step_error"){if(A===void 0){if(Y.step>=X.length)throw new G("Server produced StepErrorEntry for unexpected step");for(let _=R;_<Y.step;++_)X[_].callback(void 0,void 0)}else{if(Y.step!==A.step)throw new G("Server produced StepErrorEntry for unexpected step");A=void 0,Z=[]}X[Y.step].callback(void 0,Y.error),R=Y.step+1}else if(Y.type==="row"){if(A===void 0)throw new G("Server produced RowEntry but no step is active");Z.push(Y.row)}else if(Y.type==="error")throw S(Y.error);else if(Y.type==="none")throw new G("Server produced unrecognized CursorEntry");else throw z(Y,"Impossible CursorEntry")}if(A!==void 0)throw new G("Server closed Cursor before terminating active step");for(let Y=R;Y<X.length;++Y)X[Y].callback(void 0,void 0)}finally{J.close()}}class U1{_batch;#f;_index;constructor(f){this._batch=f,this.#f=[],this._index=void 0}condition(f){return this.#f.push(f._proto),this}query(f){return this.#X(f,!0,r2)}queryRow(f){return this.#X(f,!0,e2)}queryValue(f){return this.#X(f,!0,f1)}run(f){return this.#X(f,!1,R2)}#X(f,X,$){if(this._index!==void 0)throw new q("This BatchStep has already been added to the batch");let J=X1(this._batch._stream._sqlOwner(),f,X),R;if(this.#f.length===0)R=void 0;else if(this.#f.length===1)R=this.#f[0];else R={type:"and",conds:this.#f.slice()};let A={stmt:J,condition:R};return new Promise((Z,Y)=>{let _=(N,y)=>{if(N!==void 0&&y!==void 0)Y(new G("Server returned both result and error"));else if(y!==void 0)Y(S(y));else if(N!==void 0)Z($(N,this._batch._stream.intMode));else Z(void 0)};this._index=this._batch._steps.length,this._batch._steps.push({proto:A,callback:_})})}}class W{_batch;_proto;constructor(f,X){this._batch=f,this._proto=X}static ok(f){return new W(f._batch,{type:"ok",step:of(f)})}static error(f){return new W(f._batch,{type:"error",step:of(f)})}static not(f){return new W(f._batch,{type:"not",cond:f._proto})}static and(f,X){for(let $ of X)rf(f,$);return new W(f,{type:"and",conds:X.map(($)=>$._proto)})}static or(f,X){for(let $ of X)rf(f,$);return new W(f,{type:"or",conds:X.map(($)=>$._proto)})}static isAutocommit(f){return f._stream.client()._ensureVersion(3,"BatchCond.isAutocommit()"),new W(f,{type:"is_autocommit"})}}function of(f){if(f._index===void 0)throw new q("Cannot add a condition referencing a step that has not been added to the batch");return f._index}function rf(f,X){if(X._batch!==f)throw new q("Cannot mix BatchCond objects for different Batch objects")}function ef(f){return{paramNames:f.params.map((X)=>X.name),columns:f.cols,isExplain:f.isExplain,isReadonly:f.isReadonly}}class Q2{constructor(f){this.intMode=f}query(f){return this.#f(f,!0,r2)}queryRow(f){return this.#f(f,!0,e2)}queryValue(f){return this.#f(f,!0,f1)}run(f){return this.#f(f,!1,R2)}#f(f,X,$){let J=X1(this._sqlOwner(),f,X);return this._execute(J).then((R)=>$(R,this.intMode))}batch(f=!1){return new $1(this,f)}describe(f){let X=v2(this._sqlOwner(),f);return this._describe(X).then(ef)}sequence(f){let X=v2(this._sqlOwner(),f);return this._sequence(X)}intMode}class g2{}var R3=1000,A3=10;class V1 extends g2{#f;#X;#$;#J;#R;#A;#Y;constructor(f,X,$){super();this.#f=f,this.#X=X,this.#$=$,this.#J=new t,this.#R=new t,this.#A=void 0,this.#Y=!1}async next(){for(;;){if(this.#A!==void 0)throw new x("Cursor is closed",this.#A);while(!this.#Y&&this.#R.length<A3)this.#R.push(this.#Z());let f=this.#J.shift();if(this.#Y||f!==void 0)return f;await this.#R.shift().then((X)=>{if(X===void 0)return;for(let $ of X.entries)this.#J.push($);this.#Y||=X.done})}}#Z(){return this.#X._sendCursorRequest(this,{type:"fetch_cursor",cursorId:this.#$,maxCount:R3}).then((f)=>f,(f)=>{this._setClosed(f);return})}_setClosed(f){if(this.#A!==void 0)return;this.#A=f,this.#X._sendCursorRequest(this,{type:"close_cursor",cursorId:this.#$}).catch(()=>{return}),this.#X._cursorClosed(this)}close(){this._setClosed(new O("Cursor was manually closed"))}get closed(){return this.#A!==void 0}}class u2 extends Q2{#f;#X;#$;#J;#R;#A;static open(f){let X=f._streamIdAlloc.alloc(),$=new u2(f,X),J=()=>{return},R=(Z)=>$.#N(Z),A={type:"open_stream",streamId:X};return f._sendRequest(A,{responseCallback:J,errorCallback:R}),$}constructor(f,X){super(f.intMode);this.#f=f,this.#X=X,this.#$=new t,this.#J=void 0,this.#R=!1,this.#A=void 0}client(){return this.#f}_sqlOwner(){return this.#f}_execute(f){return this.#Y({type:"execute",streamId:this.#X,stmt:f}).then((X)=>{return X.result})}_batch(f){return this.#Y({type:"batch",streamId:this.#X,batch:f}).then((X)=>{return X.result})}_describe(f){return this.#f._ensureVersion(2,"describe()"),this.#Y({type:"describe",streamId:this.#X,sql:f.sql,sqlId:f.sqlId}).then((X)=>{return X.result})}_sequence(f){return this.#f._ensureVersion(2,"sequence()"),this.#Y({type:"sequence",streamId:this.#X,sql:f.sql,sqlId:f.sqlId}).then((X)=>{return})}getAutocommit(){return this.#f._ensureVersion(3,"getAutocommit()"),this.#Y({type:"get_autocommit",streamId:this.#X}).then((f)=>{return f.isAutocommit})}#Y(f){return new Promise((X,$)=>{this.#Z({type:"request",request:f,responseCallback:X,errorCallback:$})})}_openCursor(f){return this.#f._ensureVersion(3,"cursor"),new Promise((X,$)=>{this.#Z({type:"cursor",batch:f,cursorCallback:X,errorCallback:$})})}_sendCursorRequest(f,X){if(f!==this.#J)throw new V("Cursor not associated with the stream attempted to execute a request");return new Promise(($,J)=>{if(this.#A!==void 0)J(new x("Stream is closed",this.#A));else this.#f._sendRequest(X,{responseCallback:$,errorCallback:J})})}_cursorClosed(f){if(f!==this.#J)throw new V("Cursor was closed, but it was not associated with the stream");this.#J=void 0,this.#_()}#Z(f){if(this.#A!==void 0)f.errorCallback(new x("Stream is closed",this.#A));else if(this.#R)f.errorCallback(new x("Stream is closing",void 0));else this.#$.push(f),this.#_()}#_(){for(;;){let f=this.#$.first();if(f===void 0&&this.#J===void 0&&this.#R){this.#N(new O("Stream was gracefully closed"));break}else if(f?.type==="request"&&this.#J===void 0){let{request:X,responseCallback:$,errorCallback:J}=f;this.#$.shift(),this.#f._sendRequest(X,{responseCallback:$,errorCallback:J})}else if(f?.type==="cursor"&&this.#J===void 0){let{batch:X,cursorCallback:$}=f;this.#$.shift();let J=this.#f._cursorIdAlloc.alloc(),R=new V1(this.#f,this,J),A={type:"open_cursor",streamId:this.#X,cursorId:J,batch:X},Z=()=>{return},Y=(_)=>R._setClosed(_);this.#f._sendRequest(A,{responseCallback:Z,errorCallback:Y}),this.#J=R,$(R)}else break}}#N(f){if(this.#A!==void 0)return;if(this.#A=f,this.#J!==void 0)this.#J._setClosed(f);for(;;){let R=this.#$.shift();if(R!==void 0)R.errorCallback(f);else break}let X={type:"close_stream",streamId:this.#X},$=()=>this.#f._streamIdAlloc.free(this.#X),J=()=>{return};this.#f._sendRequest(X,{responseCallback:$,errorCallback:J})}close(){this.#N(new O("Stream was manually closed"))}closeGracefully(){this.#R=!0,this.#_()}get closed(){return this.#A!==void 0||this.#R}}function i2(f,X){if(X.sql!==void 0)f.string("sql",X.sql);if(X.sqlId!==void 0)f.number("sql_id",X.sqlId);f.arrayObjects("args",X.args,f0),f.arrayObjects("named_args",X.namedArgs,Z3),f.boolean("want_rows",X.wantRows)}function Z3(f,X){f.string("name",X.name),f.object("value",X.value,f0)}function I2(f,X){f.arrayObjects("steps",X.steps,Y3)}function Y3(f,X){if(X.condition!==void 0)f.object("condition",X.condition,y1);f.object("stmt",X.stmt,i2)}function y1(f,X){if(f.stringRaw("type",X.type),X.type==="ok"||X.type==="error")f.number("step",X.step);else if(X.type==="not")f.object("cond",X.cond,y1);else if(X.type==="and"||X.type==="or")f.arrayObjects("conds",X.conds,y1);else if(X.type==="is_autocommit");else throw z(X,"Impossible type of BatchCond")}function f0(f,X){if(X===null)f.stringRaw("type","null");else if(typeof X==="bigint")f.stringRaw("type","integer"),f.stringRaw("value",""+X);else if(typeof X==="number")f.stringRaw("type","float"),f.number("value",X);else if(typeof X==="string")f.stringRaw("type","text"),f.string("value",X);else if(X instanceof Uint8Array)f.stringRaw("type","blob"),f.stringRaw("base64",N2.fromUint8Array(X));else if(X===void 0);else throw z(X,"Impossible type of Value")}function X0(f,X){if(f.stringRaw("type",X.type),X.type==="hello"){if(X.jwt!==void 0)f.string("jwt",X.jwt)}else if(X.type==="request")f.number("request_id",X.requestId),f.object("request",X.request,_3);else throw z(X,"Impossible type of ClientMsg")}function _3(f,X){if(f.stringRaw("type",X.type),X.type==="open_stream")f.number("stream_id",X.streamId);else if(X.type==="close_stream")f.number("stream_id",X.streamId);else if(X.type==="execute")f.number("stream_id",X.streamId),f.object("stmt",X.stmt,i2);else if(X.type==="batch")f.number("stream_id",X.streamId),f.object("batch",X.batch,I2);else if(X.type==="open_cursor")f.number("stream_id",X.streamId),f.number("cursor_id",X.cursorId),f.object("batch",X.batch,I2);else if(X.type==="close_cursor")f.number("cursor_id",X.cursorId);else if(X.type==="fetch_cursor")f.number("cursor_id",X.cursorId),f.number("max_count",X.maxCount);else if(X.type==="sequence"){if(f.number("stream_id",X.streamId),X.sql!==void 0)f.string("sql",X.sql);if(X.sqlId!==void 0)f.number("sql_id",X.sqlId)}else if(X.type==="describe"){if(f.number("stream_id",X.streamId),X.sql!==void 0)f.string("sql",X.sql);if(X.sqlId!==void 0)f.number("sql_id",X.sqlId)}else if(X.type==="store_sql")f.number("sql_id",X.sqlId),f.string("sql",X.sql);else if(X.type==="close_sql")f.number("sql_id",X.sqlId);else if(X.type==="get_autocommit")f.number("stream_id",X.streamId);else throw z(X,"Impossible type of Request")}function d2(f,X){if(X.sql!==void 0)f.string(1,X.sql);if(X.sqlId!==void 0)f.int32(2,X.sqlId);for(let $ of X.args)f.message(3,$,J0);for(let $ of X.namedArgs)f.message(4,$,N3);f.bool(5,X.wantRows)}function N3(f,X){f.string(1,X.name),f.message(2,X.value,J0)}function B2(f,X){for(let $ of X.steps)f.message(1,$,G3)}function G3(f,X){if(X.condition!==void 0)f.message(1,X.condition,H1);f.message(2,X.stmt,d2)}function H1(f,X){if(X.type==="ok")f.uint32(1,X.step);else if(X.type==="error")f.uint32(2,X.step);else if(X.type==="not")f.message(3,X.cond,H1);else if(X.type==="and")f.message(4,X.conds,$0);else if(X.type==="or")f.message(5,X.conds,$0);else if(X.type==="is_autocommit")f.message(6,void 0,R0);else throw z(X,"Impossible type of BatchCond")}function $0(f,X){for(let $ of X)f.message(1,$,H1)}function J0(f,X){if(X===null)f.message(1,void 0,R0);else if(typeof X==="bigint")f.sint64(2,X);else if(typeof X==="number")f.double(3,X);else if(typeof X==="string")f.string(4,X);else if(X instanceof Uint8Array)f.bytes(5,X);else if(X===void 0);else throw z(X,"Impossible type of Value")}function R0(f,X){}function A0(f,X){if(X.type==="hello")f.message(1,X,K3);else if(X.type==="request")f.message(2,X,z3);else throw z(X,"Impossible type of ClientMsg")}function K3(f,X){if(X.jwt!==void 0)f.string(1,X.jwt)}function z3(f,X){f.int32(1,X.requestId);let $=X.request;if($.type==="open_stream")f.message(2,$,O3);else if($.type==="close_stream")f.message(3,$,W3);else if($.type==="execute")f.message(4,$,D3);else if($.type==="batch")f.message(5,$,x3);else if($.type==="open_cursor")f.message(6,$,Q3);else if($.type==="close_cursor")f.message(7,$,I3);else if($.type==="fetch_cursor")f.message(8,$,B3);else if($.type==="sequence")f.message(9,$,U3);else if($.type==="describe")f.message(10,$,V3);else if($.type==="store_sql")f.message(11,$,y3);else if($.type==="close_sql")f.message(12,$,H3);else if($.type==="get_autocommit")f.message(13,$,L3);else throw z($,"Impossible type of Request")}function O3(f,X){f.int32(1,X.streamId)}function W3(f,X){f.int32(1,X.streamId)}function D3(f,X){f.int32(1,X.streamId),f.message(2,X.stmt,d2)}function x3(f,X){f.int32(1,X.streamId),f.message(2,X.batch,B2)}function Q3(f,X){f.int32(1,X.streamId),f.int32(2,X.cursorId),f.message(3,X.batch,B2)}function I3(f,X){f.int32(1,X.cursorId)}function B3(f,X){f.int32(1,X.cursorId),f.uint32(2,X.maxCount)}function U3(f,X){if(f.int32(1,X.streamId),X.sql!==void 0)f.string(2,X.sql);if(X.sqlId!==void 0)f.int32(3,X.sqlId)}function V3(f,X){if(f.int32(1,X.streamId),X.sql!==void 0)f.string(2,X.sql);if(X.sqlId!==void 0)f.int32(3,X.sqlId)}function y3(f,X){f.int32(1,X.sqlId),f.string(2,X.sql)}function H3(f,X){f.int32(1,X.sqlId)}function L3(f,X){f.int32(1,X.streamId)}function s(f){let X=H(f.message),$=L(f.code);return{message:X,code:$}}function n2(f){let X=j(f.cols,Z0),$=k2(f.rows).map((Z)=>j(Z,Y0)),J=v(f.affected_row_count),R=L(f.last_insert_rowid),A=R!==void 0?BigInt(R):void 0;return{cols:X,rows:$,affectedRowCount:J,lastInsertRowid:A}}function Z0(f){let X=L(f.name),$=L(f.decltype);return{name:X,decltype:$}}function J1(f){let X=new Map;k2(f.step_results).forEach((J,R)=>{if(J!==null)X.set(R,n2(Q(J)))});let $=new Map;return k2(f.step_errors).forEach((J,R)=>{if(J!==null)$.set(R,s(Q(J)))}),{stepResults:X,stepErrors:$}}function R1(f){let X=H(f.type);if(X==="step_begin"){let $=v(f.step),J=j(f.cols,Z0);return{type:"step_begin",step:$,cols:J}}else if(X==="step_end"){let $=v(f.affected_row_count),J=L(f.last_insert_rowid),R=J!==void 0?BigInt(J):void 0;return{type:"step_end",affectedRowCount:$,lastInsertRowid:R}}else if(X==="step_error"){let $=v(f.step),J=s(Q(f.error));return{type:"step_error",step:$,error:J}}else if(X==="row")return{type:"row",row:j(f.row,Y0)};else if(X==="error")return{type:"error",error:s(Q(f.error))};else throw new G("Unexpected type of CursorEntry")}function A1(f){let X=j(f.params,T3),$=j(f.cols,F3),J=m(f.is_explain),R=m(f.is_readonly);return{params:X,cols:$,isExplain:J,isReadonly:R}}function T3(f){return{name:L(f.name)}}function F3(f){let X=H(f.name),$=L(f.decltype);return{name:X,decltype:$}}function Y0(f){let X=H(f.type);if(X==="null")return null;else if(X==="integer"){let $=H(f.value);return BigInt($)}else if(X==="float")return v(f.value);else if(X==="text")return H(f.value);else if(X==="blob")return N2.toUint8Array(H(f.base64));else throw new G("Unexpected type of Value")}function _0(f){let X=H(f.type);if(X==="hello_ok")return{type:"hello_ok"};else if(X==="hello_error")return{type:"hello_error",error:s(Q(f.error))};else if(X==="response_ok"){let $=v(f.request_id),J=M3(Q(f.response));return{type:"response_ok",requestId:$,response:J}}else if(X==="response_error"){let $=v(f.request_id),J=s(Q(f.error));return{type:"response_error",requestId:$,error:J}}else throw new G("Unexpected type of ServerMsg")}function M3(f){let X=H(f.type);if(X==="open_stream")return{type:"open_stream"};else if(X==="close_stream")return{type:"close_stream"};else if(X==="execute")return{type:"execute",result:n2(Q(f.result))};else if(X==="batch")return{type:"batch",result:J1(Q(f.result))};else if(X==="open_cursor")return{type:"open_cursor"};else if(X==="close_cursor")return{type:"close_cursor"};else if(X==="fetch_cursor"){let $=j(f.entries,R1),J=m(f.done);return{type:"fetch_cursor",entries:$,done:J}}else if(X==="sequence")return{type:"sequence"};else if(X==="describe")return{type:"describe",result:A1(Q(f.result))};else if(X==="store_sql")return{type:"store_sql"};else if(X==="close_sql")return{type:"close_sql"};else if(X==="get_autocommit")return{type:"get_autocommit",isAutocommit:m(f.is_autocommit)};else throw new G("Unexpected type of Response")}var F={default(){return{message:"",code:void 0}},1(f,X){X.message=f.string()},2(f,X){X.code=f.string()}},a={default(){return{cols:[],rows:[],affectedRowCount:0,lastInsertRowid:void 0}},1(f,X){X.cols.push(f.message(N0))},2(f,X){X.rows.push(f.message(G0))},3(f,X){X.affectedRowCount=Number(f.uint64())},4(f,X){X.lastInsertRowid=f.sint64()}},N0={default(){return{name:void 0,decltype:void 0}},1(f,X){X.name=f.string()},2(f,X){X.decltype=f.string()}},G0={default(){return[]},1(f,X){X.push(f.message(C3))}},U2={default(){return{stepResults:new Map,stepErrors:new Map}},1(f,X){let[$,J]=f.message(w3);X.stepResults.set($,J)},2(f,X){let[$,J]=f.message(j3);X.stepErrors.set($,J)}},w3={default(){return[0,a.default()]},1(f,X){X[0]=f.uint32()},2(f,X){X[1]=f.message(a)}},j3={default(){return[0,F.default()]},1(f,X){X[0]=f.uint32()},2(f,X){X[1]=f.message(F)}},Z1={default(){return{type:"none"}},1(f){return f.message(E3)},2(f){return f.message(h3)},3(f){return f.message(P3)},4(f){return{type:"row",row:f.message(G0)}},5(f){return{type:"error",error:f.message(F)}}},E3={default(){return{type:"step_begin",step:0,cols:[]}},1(f,X){X.step=f.uint32()},2(f,X){X.cols.push(f.message(N0))}},h3={default(){return{type:"step_end",affectedRowCount:0,lastInsertRowid:void 0}},1(f,X){X.affectedRowCount=f.uint32()},2(f,X){X.lastInsertRowid=f.uint64()}},P3={default(){return{type:"step_error",step:0,error:F.default()}},1(f,X){X.step=f.uint32()},2(f,X){X.error=f.message(F)}},V2={default(){return{params:[],cols:[],isExplain:!1,isReadonly:!1}},1(f,X){X.params.push(f.message(k3))},2(f,X){X.cols.push(f.message(q3))},3(f,X){X.isExplain=f.bool()},4(f,X){X.isReadonly=f.bool()}},k3={default(){return{name:void 0}},1(f,X){X.name=f.string()}},q3={default(){return{name:"",decltype:void 0}},1(f,X){X.name=f.string()},2(f,X){X.decltype=f.string()}},C3={default(){return},1(f){return null},2(f){return f.sint64()},3(f){return f.double()},4(f){return f.string()},5(f){return f.bytes()}};var K0={default(){return{type:"none"}},1(f){return{type:"hello_ok"}},2(f){return f.message(b3)},3(f){return f.message(v3)},4(f){return f.message(p3)}},b3={default(){return{type:"hello_error",error:F.default()}},1(f,X){X.error=f.message(F)}},p3={default(){return{type:"response_error",requestId:0,error:F.default()}},1(f,X){X.requestId=f.int32()},2(f,X){X.error=f.message(F)}},v3={default(){return{type:"response_ok",requestId:0,response:{type:"none"}}},1(f,X){X.requestId=f.int32()},2(f,X){X.response={type:"open_stream"}},3(f,X){X.response={type:"close_stream"}},4(f,X){X.response=f.message(S3)},5(f,X){X.response=f.message(g3)},6(f,X){X.response={type:"open_cursor"}},7(f,X){X.response={type:"close_cursor"}},8(f,X){X.response=f.message(u3)},9(f,X){X.response={type:"sequence"}},10(f,X){X.response=f.message(i3)},11(f,X){X.response={type:"store_sql"}},12(f,X){X.response={type:"close_sql"}},13(f,X){X.response=f.message(d3)}},S3={default(){return{type:"execute",result:a.default()}},1(f,X){X.result=f.message(a)}},g3={default(){return{type:"batch",result:U2.default()}},1(f,X){X.result=f.message(U2)}},u3={default(){return{type:"fetch_cursor",entries:[],done:!1}},1(f,X){X.entries.push(f.message(Z1))},2(f,X){X.done=f.bool()}},i3={default(){return{type:"describe",result:V2.default()}},1(f,X){X.result=f.message(V2)}},d3={default(){return{type:"get_autocommit",isAutocommit:!1}},1(f,X){X.isAutocommit=f.bool()}};var z0=new Map([["hrana2",{version:2,encoding:"json"}],["hrana1",{version:1,encoding:"json"}]]),L1=new Map([["hrana3-protobuf",{version:3,encoding:"protobuf"}],["hrana3",{version:3,encoding:"json"}],["hrana2",{version:2,encoding:"json"}],["hrana1",{version:1,encoding:"json"}]]);class Y1 extends O2{#f;#X;#$;#J;#R;#A;#Y;#Z;#_;_streamIdAlloc;_cursorIdAlloc;#N;constructor(f,X){super();this.#f=f,this.#X=[],this.#$=!1,this.#J=void 0,this.#R=!1,this.#A=void 0,this.#Y=!1,this.#Z=new Map,this.#_=new l,this._streamIdAlloc=new l,this._cursorIdAlloc=new l,this.#N=new l,this.#f.binaryType="arraybuffer",this.#f.addEventListener("open",()=>this.#W()),this.#f.addEventListener("close",($)=>this.#O($)),this.#f.addEventListener("error",($)=>this.#D($)),this.#f.addEventListener("message",($)=>this.#Q($)),this.#K({type:"hello",jwt:X})}#K(f){if(this.#J!==void 0)throw new V("Trying to send a message on a closed client");if(this.#$)this.#z(f);else{let X=()=>this.#z(f),$=()=>{return};this.#X.push({openCallback:X,errorCallback:$})}}#W(){let f=this.#f.protocol;if(f===void 0){this.#G(new O("The `WebSocket.protocol` property is undefined. This most likely means that the WebSocket implementation provided by the environment is broken. If you are using Miniflare 2, please update to Miniflare 3, which fixes this problem."));return}else if(f==="")this.#A={version:1,encoding:"json"};else if(this.#A=L1.get(f),this.#A===void 0){this.#G(new G(`Unrecognized WebSocket subprotocol: ${JSON.stringify(f)}`));return}for(let X of this.#X)X.openCallback();this.#X.length=0,this.#$=!0}#z(f){let X=this.#A.encoding;if(X==="json"){let $=q2(f,X0);this.#f.send($)}else if(X==="protobuf"){let $=p2(f,A0);this.#f.send($)}else throw z(X,"Impossible encoding")}getVersion(){return new Promise((f,X)=>{if(this.#Y=!0,this.#J!==void 0)X(this.#J);else if(!this.#$){let $=()=>f(this.#A.version);this.#X.push({openCallback:$,errorCallback:X})}else f(this.#A.version)})}_ensureVersion(f,X){if(this.#A===void 0||!this.#Y)throw new w(`${X} is supported only on protocol version ${f} and higher, but the version supported by the WebSocket server is not yet known. Use Client.getVersion() to wait until the version is available.`);else if(this.#A.version<f)throw new w(`${X} is supported on protocol version ${f} and higher, but the WebSocket server only supports version ${this.#A.version}`)}_sendRequest(f,X){if(this.#J!==void 0){X.errorCallback(new x("Client is closed",this.#J));return}let $=this.#_.alloc();this.#Z.set($,{...X,type:f.type}),this.#K({type:"request",requestId:$,request:f})}#D(f){let $=f.message??"WebSocket was closed due to an error";this.#G(new W2($))}#O(f){let X=`WebSocket was closed with code ${f.code}`;if(f.reason)X+=`: ${f.reason}`;this.#G(new W2(X))}#G(f){if(this.#J!==void 0)return;this.#J=f;for(let X of this.#X)X.errorCallback(f);this.#X.length=0;for(let[X,$]of this.#Z.entries())$.errorCallback(f),this.#_.free(X);this.#Z.clear(),this.#f.close()}#Q(f){if(this.#J!==void 0)return;try{let X,$=this.#A.encoding;if($==="json"){if(typeof f.data!=="string"){this.#f.close(3003,"Only text messages are accepted with JSON encoding"),this.#G(new G("Received non-text message from server with JSON encoding"));return}X=$2(JSON.parse(f.data),_0)}else if($==="protobuf"){if(!(f.data instanceof ArrayBuffer)){this.#f.close(3003,"Only binary messages are accepted with Protobuf encoding"),this.#G(new G("Received non-binary message from server with Protobuf encoding"));return}X=c(new Uint8Array(f.data),K0)}else throw z($,"Impossible encoding");this.#x(X)}catch(X){this.#f.close(3007,"Could not handle message"),this.#G(X)}}#x(f){if(f.type==="none")throw new G("Received an unrecognized ServerMsg");else if(f.type==="hello_ok"||f.type==="hello_error"){if(this.#R)throw new G("Received a duplicated hello response");if(this.#R=!0,f.type==="hello_error")throw S(f.error);return}else if(!this.#R)throw new G("Received a non-hello message before a hello response");if(f.type==="response_ok"){let X=f.requestId,$=this.#Z.get(X);if(this.#Z.delete(X),$===void 0)throw new G("Received unexpected OK response");this.#_.free(X);try{if($.type!==f.response.type)throw console.dir({responseState:$,msg:f}),new G("Received unexpected type of response");$.responseCallback(f.response)}catch(J){throw $.errorCallback(J),J}}else if(f.type==="response_error"){let X=f.requestId,$=this.#Z.get(X);if(this.#Z.delete(X),$===void 0)throw new G("Received unexpected error response");this.#_.free(X),$.errorCallback(S(f.error))}else throw z(f,"Impossible ServerMsg type")}openStream(){return u2.open(this)}storeSql(f){this._ensureVersion(2,"storeSql()");let X=this.#N.alloc(),$=new A2(this,X),J=()=>{return},R=(Z)=>$._setClosed(Z),A={type:"store_sql",sqlId:X,sql:f};return this._sendRequest(A,{responseCallback:J,errorCallback:R}),$}_closeSql(f){if(this.#J!==void 0)return;let X=()=>this.#N.free(f),$=(R)=>this.#G(R),J={type:"close_sql",sqlId:f};this._sendRequest(J,{responseCallback:X,errorCallback:$})}close(){this.#G(new O("Client was manually closed"))}get closed(){return this.#J!==void 0}}var m2=Request,T1=Headers,F1=fetch;var Z2;if(typeof queueMicrotask<"u")Z2=queueMicrotask;else{let f=Promise.resolve();Z2=(X)=>{f.then(X)}}class M1{#f;#X;#$;constructor(f){this.#f=new Uint8Array(new ArrayBuffer(f)),this.#X=0,this.#$=0}get length(){return this.#$-this.#X}data(){return this.#f.slice(this.#X,this.#$)}push(f){this.#J(f.byteLength),this.#f.set(f,this.#$),this.#$+=f.byteLength}#J(f){if(this.#$+f<=this.#f.byteLength)return;let X=this.#$-this.#X;if(X+f<=this.#f.byteLength&&2*this.#$>=this.#f.byteLength)this.#f.copyWithin(0,this.#X,this.#$);else{let $=this.#f.byteLength;do $*=2;while(X+f>$);let J=new Uint8Array(new ArrayBuffer($));J.set(this.#f.slice(this.#X,this.#$),0),this.#f=J}this.#$=X,this.#X=0}shift(f){this.#X+=f}}function O0(f){let X=L(f.baton),$=L(f.base_url),J=j(f.results,n3);return{baton:X,baseUrl:$,results:J}}function n3(f){let X=H(f.type);if(X==="ok")return{type:"ok",response:m3(Q(f.response))};else if(X==="error")return{type:"error",error:s(Q(f.error))};else throw new G("Unexpected type of StreamResult")}function m3(f){let X=H(f.type);if(X==="close")return{type:"close"};else if(X==="execute")return{type:"execute",result:n2(Q(f.result))};else if(X==="batch")return{type:"batch",result:J1(Q(f.result))};else if(X==="sequence")return{type:"sequence"};else if(X==="describe")return{type:"describe",result:A1(Q(f.result))};else if(X==="store_sql")return{type:"store_sql"};else if(X==="close_sql")return{type:"close_sql"};else if(X==="get_autocommit")return{type:"get_autocommit",isAutocommit:m(f.is_autocommit)};else throw new G("Unexpected type of StreamResponse")}function W0(f){let X=L(f.baton),$=L(f.base_url);return{baton:X,baseUrl:$}}var D0={default(){return{baton:void 0,baseUrl:void 0,results:[]}},1(f,X){X.baton=f.string()},2(f,X){X.baseUrl=f.string()},3(f,X){X.results.push(f.message(c3))}},c3={default(){return{type:"none"}},1(f){return{type:"ok",response:f.message(l3)}},2(f){return{type:"error",error:f.message(F)}}},l3={default(){return{type:"none"}},1(f){return{type:"close"}},2(f){return f.message(t3)},3(f){return f.message(s3)},4(f){return{type:"sequence"}},5(f){return f.message(a3)},6(f){return{type:"store_sql"}},7(f){return{type:"close_sql"}},8(f){return f.message(o3)}},t3={default(){return{type:"execute",result:a.default()}},1(f,X){X.result=f.message(a)}},s3={default(){return{type:"batch",result:U2.default()}},1(f,X){X.result=f.message(U2)}},a3={default(){return{type:"describe",result:V2.default()}},1(f,X){X.result=f.message(V2)}},o3={default(){return{type:"get_autocommit",isAutocommit:!1}},1(f,X){X.isAutocommit=f.bool()}},x0={default(){return{baton:void 0,baseUrl:void 0}},1(f,X){X.baton=f.string()},2(f,X){X.baseUrl=f.string()}};class w1 extends g2{#f;#X;#$;#J;#R;#A;constructor(f,X){super();this.#f=f,this.#X=X,this.#$=void 0,this.#J=new M1(16384),this.#R=void 0,this.#A=!1}async open(f){if(f.body===null)throw new G("No response body for cursor request");this.#$=f.body.getReader();let X=await this.#Y(W0,x0);if(X===void 0)throw new G("Empty response to cursor request");return X}next(){return this.#Y(R1,Z1)}close(){this._setClosed(new O("Cursor was manually closed"))}_setClosed(f){if(this.#R!==void 0)return;if(this.#R=f,this.#f._cursorClosed(this),this.#$!==void 0)this.#$.cancel()}get closed(){return this.#R!==void 0}async#Y(f,X){for(;;){if(this.#A)return;else if(this.#R!==void 0)throw new x("Cursor is closed",this.#R);if(this.#X==="json"){let R=this.#Z();if(R!==void 0){let A=new TextDecoder().decode(R),Z=JSON.parse(A);return $2(Z,f)}}else if(this.#X==="protobuf"){let R=this.#_();if(R!==void 0)return c(R,X)}else throw z(this.#X,"Impossible encoding");if(this.#$===void 0)throw new V("Attempted to read from HTTP cursor before it was opened");let{value:$,done:J}=await this.#$.read();if(J&&this.#J.length===0)this.#A=!0;else if(J)throw new G("Unexpected end of cursor stream");else this.#J.push($)}}#Z(){let f=this.#J.data(),X=10,$=f.indexOf(10);if($<0)return;let J=f.slice(0,$);return this.#J.shift($+1),J}#_(){let f=this.#J.data(),X=0,$=0;for(;;){if($>=f.byteLength)return;let R=f[$];if(X|=(R&127)<<7*$,$+=1,!(R&128))break}if(f.byteLength<$+X)return;let J=f.slice($,$+X);return this.#J.shift($+X),J}}function Q0(f,X){if(X.baton!==void 0)f.string("baton",X.baton);f.arrayObjects("requests",X.requests,r3)}function r3(f,X){if(f.stringRaw("type",X.type),X.type==="close");else if(X.type==="execute")f.object("stmt",X.stmt,i2);else if(X.type==="batch")f.object("batch",X.batch,I2);else if(X.type==="sequence"){if(X.sql!==void 0)f.string("sql",X.sql);if(X.sqlId!==void 0)f.number("sql_id",X.sqlId)}else if(X.type==="describe"){if(X.sql!==void 0)f.string("sql",X.sql);if(X.sqlId!==void 0)f.number("sql_id",X.sqlId)}else if(X.type==="store_sql")f.number("sql_id",X.sqlId),f.string("sql",X.sql);else if(X.type==="close_sql")f.number("sql_id",X.sqlId);else if(X.type==="get_autocommit");else throw z(X,"Impossible type of StreamRequest")}function I0(f,X){if(X.baton!==void 0)f.string("baton",X.baton);f.object("batch",X.batch,I2)}function B0(f,X){if(X.baton!==void 0)f.string(1,X.baton);for(let $ of X.requests)f.message(2,$,e3)}function e3(f,X){if(X.type==="close")f.message(1,X,f4);else if(X.type==="execute")f.message(2,X,X4);else if(X.type==="batch")f.message(3,X,$4);else if(X.type==="sequence")f.message(4,X,J4);else if(X.type==="describe")f.message(5,X,R4);else if(X.type==="store_sql")f.message(6,X,A4);else if(X.type==="close_sql")f.message(7,X,Z4);else if(X.type==="get_autocommit")f.message(8,X,Y4);else throw z(X,"Impossible type of StreamRequest")}function f4(f,X){}function X4(f,X){f.message(1,X.stmt,d2)}function $4(f,X){f.message(1,X.batch,B2)}function J4(f,X){if(X.sql!==void 0)f.string(1,X.sql);if(X.sqlId!==void 0)f.int32(2,X.sqlId)}function R4(f,X){if(X.sql!==void 0)f.string(1,X.sql);if(X.sqlId!==void 0)f.int32(2,X.sqlId)}function A4(f,X){f.int32(1,X.sqlId),f.string(2,X.sql)}function Z4(f,X){f.int32(1,X.sqlId)}function Y4(f,X){}function U0(f,X){if(X.baton!==void 0)f.string(1,X.baton);f.message(2,X.batch,B2)}class _1 extends Q2{#f;#X;#$;#J;#R;#A;#Y;#Z;#_;#N;#K;#W;constructor(f,X,$,J){super(f.intMode);this.#f=f,this.#X=X.toString(),this.#$=$,this.#J=J,this.#R=void 0,this.#A=new t,this.#Y=!1,this.#_=!1,this.#N=!1,this.#K=void 0,this.#W=new l}client(){return this.#f}_sqlOwner(){return this}storeSql(f){let X=this.#W.alloc();return this.#z({type:"store_sql",sqlId:X,sql:f}).then(()=>{return},($)=>this._setClosed($)),new A2(this,X)}_closeSql(f){if(this.#K!==void 0)return;this.#z({type:"close_sql",sqlId:f}).then(()=>this.#W.free(f),(X)=>this._setClosed(X))}_execute(f){return this.#z({type:"execute",stmt:f}).then((X)=>{return X.result})}_batch(f){return this.#z({type:"batch",batch:f}).then((X)=>{return X.result})}_describe(f){return this.#z({type:"describe",sql:f.sql,sqlId:f.sqlId}).then((X)=>{return X.result})}_sequence(f){return this.#z({type:"sequence",sql:f.sql,sqlId:f.sqlId}).then((X)=>{return})}getAutocommit(){return this.#f._ensureVersion(3,"getAutocommit()"),this.#z({type:"get_autocommit"}).then((f)=>{return f.isAutocommit})}#z(f){return new Promise((X,$)=>{this.#D({type:"pipeline",request:f,responseCallback:X,errorCallback:$})})}_openCursor(f){return new Promise((X,$)=>{this.#D({type:"cursor",batch:f,cursorCallback:X,errorCallback:$})})}_cursorClosed(f){if(f!==this.#Z)throw new V("Cursor was closed, but it was not associated with the stream");this.#Z=void 0,Z2(()=>this.#O())}close(){this._setClosed(new O("Stream was manually closed"))}closeGracefully(){this.#_=!0,Z2(()=>this.#O())}get closed(){return this.#K!==void 0||this.#_}_setClosed(f){if(this.#K!==void 0)return;if(this.#K=f,this.#Z!==void 0)this.#Z._setClosed(f);this.#f._streamClosed(this);for(;;){let X=this.#A.shift();if(X!==void 0)X.errorCallback(f);else break}if((this.#R!==void 0||this.#Y)&&!this.#N)this.#A.push({type:"pipeline",request:{type:"close"},responseCallback:()=>{return},errorCallback:()=>{return}}),this.#N=!0,Z2(()=>this.#O())}#D(f){if(this.#K!==void 0)throw new x("Stream is closed",this.#K);else if(this.#_)throw new x("Stream is closing",void 0);else this.#A.push(f),Z2(()=>this.#O())}#O(){if(this.#Y||this.#Z!==void 0)return;if(this.#_&&this.#A.length===0){this._setClosed(new O("Stream was gracefully closed"));return}let f=this.#f._endpoint;if(f===void 0){this.#f._endpointPromise.then(()=>this.#O(),($)=>this._setClosed($));return}let X=this.#A.shift();if(X===void 0)return;else if(X.type==="pipeline"){let $=[X];for(;;){let J=this.#A.first();if(J!==void 0&&J.type==="pipeline")$.push(J),this.#A.shift();else if(J===void 0&&this.#_&&!this.#N){$.push({type:"pipeline",request:{type:"close"},responseCallback:()=>{return},errorCallback:()=>{return}}),this.#N=!0;break}else break}this.#G(f,$)}else if(X.type==="cursor")this.#Q(f,X);else throw z(X,"Impossible type of QueueEntry")}#G(f,X){this.#x(()=>this.#B(X,f),($)=>N4($,f.encoding),($)=>$.baton,($)=>$.baseUrl,($)=>_4(X,$),($)=>X.forEach((J)=>J.errorCallback($)))}#Q(f,X){let $=new w1(this,f.encoding);this.#Z=$,this.#x(()=>this.#U(X,f),(J)=>$.open(J),(J)=>J.baton,(J)=>J.baseUrl,(J)=>X.cursorCallback($),(J)=>X.errorCallback(J))}#x(f,X,$,J,R,A){let Z;try{let Y=f(),_=this.#J;Z=_(Y)}catch(Y){Z=Promise.reject(Y)}this.#Y=!0,Z.then((Y)=>{if(!Y.ok)return G4(Y).then((_)=>{throw _});return X(Y)}).then((Y)=>{this.#R=$(Y),this.#X=J(Y)??this.#X,R(Y)}).catch((Y)=>{this._setClosed(Y),A(Y)}).finally(()=>{this.#Y=!1,this.#O()})}#B(f,X){return this.#I(new URL(X.pipelinePath,this.#X),{baton:this.#R,requests:f.map(($)=>$.request)},X.encoding,Q0,B0)}#U(f,X){if(X.cursorPath===void 0)throw new w(`Cursors are supported only on protocol version 3 and higher, but the HTTP server only supports version ${X.version}.`);return this.#I(new URL(X.cursorPath,this.#X),{baton:this.#R,batch:f.batch},X.encoding,I0,U0)}#I(f,X,$,J,R){let A,Z;if($==="json")A=q2(X,J),Z="application/json";else if($==="protobuf")A=p2(X,R),Z="application/x-protobuf";else throw z($,"Impossible encoding");let Y=new T1;if(Y.set("content-type",Z),this.#$!==void 0)Y.set("authorization",`Bearer ${this.#$}`);return new m2(f.toString(),{method:"POST",headers:Y,body:A})}}function _4(f,X){if(X.results.length!==f.length)throw new G("Server returned unexpected number of pipeline results");for(let $=0;$<f.length;++$){let J=X.results[$],R=f[$];if(J.type==="ok"){if(J.response.type!==R.request.type)throw new G("Received unexpected type of response");R.responseCallback(J.response)}else if(J.type==="error")R.errorCallback(S(J.error));else if(J.type==="none")throw new G("Received unrecognized type of StreamResult");else throw z(J,"Received impossible type of StreamResult")}}async function N4(f,X){if(X==="json"){let $=await f.json();return $2($,O0)}if(X==="protobuf"){let $=await f.arrayBuffer();return c(new Uint8Array($),D0)}throw await f.body?.cancel(),z(X,"Impossible encoding")}async function G4(f){let X=f.headers.get("content-type")??"text/plain",$=`Server returned HTTP status ${f.status}`;if(X==="application/json"){let J=await f.json();if("message"in J)return S(J);return new X2($,f.status)}if(X==="text/plain"){let J=(await f.text()).trim();if(J!=="")$+=`: ${J}`;return new X2($,f.status)}return await f.body?.cancel(),new X2($,f.status)}var K4=[{versionPath:"v3-protobuf",pipelinePath:"v3-protobuf/pipeline",cursorPath:"v3-protobuf/cursor",version:3,encoding:"protobuf"}],j1={versionPath:"v2",pipelinePath:"v2/pipeline",cursorPath:void 0,version:2,encoding:"json"};class N1 extends O2{#f;#X;#$;#J;#R;_endpointPromise;_endpoint;constructor(f,X,$,J=2){super();if(this.#f=f,this.#X=X,this.#$=$??F1,this.#J=void 0,this.#R=new Set,J==3)this._endpointPromise=z4(this.#$,this.#f),this._endpointPromise.then((R)=>this._endpoint=R,(R)=>this.#A(R));else this._endpointPromise=Promise.resolve(j1),this._endpointPromise.then((R)=>this._endpoint=R,(R)=>this.#A(R))}async getVersion(){if(this._endpoint!==void 0)return this._endpoint.version;return(await this._endpointPromise).version}_ensureVersion(f,X){if(f<=j1.version)return;else if(this._endpoint===void 0)throw new w(`${X} is supported only on protocol version ${f} and higher, but the version supported by the HTTP server is not yet known. Use Client.getVersion() to wait until the version is available.`);else if(this._endpoint.version<f)throw new w(`${X} is supported only on protocol version ${f} and higher, but the HTTP server only supports version ${this._endpoint.version}.`)}openStream(){if(this.#J!==void 0)throw new x("Client is closed",this.#J);let f=new _1(this,this.#f,this.#X,this.#$);return this.#R.add(f),f}_streamClosed(f){this.#R.delete(f)}close(){this.#A(new O("Client was manually closed"))}get closed(){return this.#J!==void 0}#A(f){if(this.#J!==void 0)return;this.#J=f;for(let X of Array.from(this.#R))X._setClosed(new x("Client was closed",f))}}async function z4(f,X){let $=f;for(let J of K4){let R=new URL(J.versionPath,X),A=new m2(R.toString(),{method:"GET"}),Z=await $(A);if(await Z.arrayBuffer(),Z.ok)return J}return j1}function E1(f,X,$=2){if(typeof E2.default>"u")throw new P2("WebSockets are not supported in this environment");var J=void 0;if($==3)J=Array.from(L1.keys());else J=Array.from(z0.keys());let R=new E2.default(f,J);return new Y1(R,X)}function h1(f,X,$,J=2){return new N1(f instanceof URL?f:new URL(f),X,$,J)}class c2{#f;#X;#$;constructor(f,X){this.#f=f,this.#X=X,this.#$=void 0}execute(f){return this.batch([f]).then((X)=>X[0])}async batch(f){let X=this._getStream();if(X.closed)throw new K("Cannot execute statements because the transaction is closed","TRANSACTION_CLOSED");try{let $=f.map(g),J;if(this.#$===void 0){this._getSqlCache().apply($);let A=X.batch(this.#X>=3),Z=A.step(),Y=Z.run(u(this.#f)),_=Z;J=$.map((N)=>{let y=A.step().condition(W.ok(_));if(this.#X>=3)y.condition(W.not(W.isAutocommit(A)));let C=y.query(N);return C.catch(()=>{return}),_=y,C}),this.#$=A.execute().then(()=>Y).then(()=>{return});try{await this.#$}catch(N){throw this.close(),N}}else{if(this.#X<3)await this.#$;this._getSqlCache().apply($);let A=X.batch(this.#X>=3),Z=void 0;J=$.map((Y)=>{let _=A.step();if(Z!==void 0)_.condition(W.ok(Z));if(this.#X>=3)_.condition(W.not(W.isAutocommit(A)));let N=_.query(Y);return N.catch(()=>{return}),Z=_,N}),await A.execute()}let R=[];for(let A of J){let Z=await A;if(Z===void 0)throw new K("Statement in a transaction was not executed, probably because the transaction has been rolled back","TRANSACTION_CLOSED");R.push(H2(Z))}return R}catch($){throw D($)}}async executeMultiple(f){let X=this._getStream();if(X.closed)throw new K("Cannot execute statements because the transaction is closed","TRANSACTION_CLOSED");try{if(this.#$===void 0){this.#$=X.run(u(this.#f)).then(()=>{return});try{await this.#$}catch($){throw this.close(),$}}else await this.#$;await X.sequence(f)}catch($){throw D($)}}async rollback(){try{let f=this._getStream();if(f.closed)return;if(this.#$!==void 0);else return;let X=f.run("ROLLBACK").catch(($)=>{throw D($)});f.closeGracefully(),await X}catch(f){throw D(f)}finally{this.close()}}async commit(){try{let f=this._getStream();if(f.closed)throw new K("Cannot commit the transaction because it is already closed","TRANSACTION_CLOSED");if(this.#$!==void 0)await this.#$;else return;let X=f.run("COMMIT").catch(($)=>{throw D($)});f.closeGracefully(),await X}catch(f){throw D(f)}finally{this.close()}}}async function y2(f,X,$,J,R=!1){if(R)$.step().run("PRAGMA foreign_keys=off");let A=$.step(),Z=A.run(u(f)),Y=A,_=J.map((o)=>{let B=$.step().condition(W.ok(Y));if(X>=3)B.condition(W.not(W.isAutocommit($)));let M=B.query(o);return Y=B,M}),N=$.step().condition(W.ok(Y));if(X>=3)N.condition(W.not(W.isAutocommit($)));let y=N.run("COMMIT");if($.step().condition(W.not(W.ok(N))).run("ROLLBACK").catch((o)=>{return}),R)$.step().run("PRAGMA foreign_keys=on");await $.execute();let E=[];await Z;for(let o of _){let B=await o;if(B===void 0)throw new K("Statement in a batch was not executed, probably because the transaction has been rolled back","TRANSACTION_CLOSED");E.push(H2(B))}return await y,E}function g(f){let X,$;if(Array.isArray(f))[X,$]=f;else if(typeof f==="string")X=f;else X=f.sql,$=f.args;let J=new S2(X);if($)if(Array.isArray($))J.bindIndexes($);else for(let[R,A]of Object.entries($))J.bindName(R,A);return J}function H2(f){let X=f.columnNames.map((Z)=>Z??""),$=f.columnDecltypes.map((Z)=>Z??""),J=f.rows,R=f.affectedRowCount,A=f.lastInsertRowid!==void 0?f.lastInsertRowid:void 0;return new G2(X,$,J,R,A)}function D(f){if(f instanceof O){let X=V0(f);return new K(f.message,X,void 0,f)}return f}function V0(f){if(f instanceof h2&&f.code!==void 0)return f.code;else if(f instanceof G)return"HRANA_PROTO_ERROR";else if(f instanceof x)return f.cause instanceof O?V0(f.cause):"HRANA_CLOSED_ERROR";else if(f instanceof W2)return"HRANA_WEBSOCKET_ERROR";else if(f instanceof X2)return"SERVER_ERROR";else if(f instanceof w)return"PROTOCOL_VERSION_ERROR";else if(f instanceof V)return"INTERNAL_ERROR";else return"UNKNOWN"}class L2{#f;#X;capacity;constructor(f,X){this.#f=f,this.#X=new y0,this.capacity=X}apply(f){if(this.capacity<=0)return;let X=new Set;for(let $ of f){if(typeof $.sql!=="string")continue;let J=$.sql;if(J.length>=5000)continue;let R=this.#X.get(J);if(R===void 0){while(this.#X.size+1>this.capacity){let[A,Z]=this.#X.peekLru();if(X.has(Z))break;Z.close(),this.#X.delete(A)}if(this.#X.size+1<=this.capacity)R=this.#f.storeSql(J),this.#X.set(J,R)}if(R!==void 0)$.sql=R,X.add(R)}}}class y0{#f;constructor(){this.#f=new Map}get(f){let X=this.#f.get(f);if(X!==void 0)this.#f.delete(f),this.#f.set(f,X);return X}set(f,X){this.#f.set(f,X)}peekLru(){for(let f of this.#f.entries())return f;return}delete(f){this.#f.delete(f)}get size(){return this.#f.size}}var F0=Q1(k1(),1);function M0(f){if(f.scheme!=="wss"&&f.scheme!=="ws")throw new K(`The WebSocket client supports only "libsql:", "wss:" and "ws:" URLs, got ${JSON.stringify(f.scheme+":")}. For more information, please read ${h}`,"URL_SCHEME_NOT_SUPPORTED");if(f.encryptionKey!==void 0)throw new K("Encryption key is not supported by the remote client.","ENCRYPTION_KEY_NOT_SUPPORTED");if(f.scheme==="ws"&&f.tls)throw new K('A "ws:" URL cannot opt into TLS by using ?tls=1',"URL_INVALID");else if(f.scheme==="wss"&&!f.tls)throw new K('A "wss:" URL cannot opt out of TLS by using ?tls=0',"URL_INVALID");let X=F2(f.scheme,f.authority,f.path),$;try{$=E1(X,f.authToken)}catch(J){if(J instanceof P2){let R=f.scheme==="wss"?"https":"http",A=F2(R,f.authority,f.path);throw new K(`This environment does not support WebSockets, please switch to the HTTP client by using a "${R}:" URL (${JSON.stringify(A)}). For more information, please read ${h}`,"WEBSOCKETS_NOT_SUPPORTED")}throw D(J)}return new w0($,X,f.authToken,f.intMode,f.concurrency)}var D4=60000,T0=100;class w0{#f;#X;#$;#J;#R;closed;protocol;#A;#Y;constructor(f,X,$,J,R){this.#f=X,this.#X=$,this.#$=J,this.#J=this.#_(f),this.#R=void 0,this.closed=!1,this.protocol="ws",this.#Y=F0.default(R)}async limit(f){return this.#Y(f)}async execute(f,X){let $;if(typeof f==="string")$={sql:f,args:X||[]};else $=f;return this.limit(async()=>{let J=await this.#Z();try{let R=g($);J.conn.sqlCache.apply([R]);let A=J.stream.query(R);J.stream.closeGracefully();let Z=await A;return H2(Z)}catch(R){throw D(R)}finally{this._closeStream(J)}})}async batch(f,X="deferred"){return this.limit(async()=>{let $=await this.#Z();try{let R=f.map((N)=>{if(Array.isArray(N))return{sql:N[0],args:N[1]||[]};return N}).map(g),A=await $.conn.client.getVersion();$.conn.sqlCache.apply(R);let Z=$.stream.batch(A>=3);return await y2(X,A,Z,R)}catch(J){throw D(J)}finally{this._closeStream($)}})}async migrate(f){return this.limit(async()=>{let X=await this.#Z();try{let $=f.map(g),J=await X.conn.client.getVersion(),R=X.stream.batch(J>=3);return await y2("deferred",J,R,$,!0)}catch($){throw D($)}finally{this._closeStream(X)}})}async transaction(f="write"){return this.limit(async()=>{let X=await this.#Z();try{let $=await X.conn.client.getVersion();return new j0(this,X,f,$)}catch($){throw this._closeStream(X),D($)}})}async executeMultiple(f){return this.limit(async()=>{let X=await this.#Z();try{let $=X.stream.sequence(f);X.stream.closeGracefully(),await $}catch($){throw D($)}finally{this._closeStream(X)}})}sync(){throw new K("sync not supported in ws mode","SYNC_NOT_SUPPORTED")}async#Z(){if(this.closed)throw new K("The client is closed","CLIENT_CLOSED");if(new Date().valueOf()-this.#J.openTime.valueOf()>D4&&this.#R===void 0){let J=this.#_();this.#R=J,J.client.getVersion().then((R)=>{if(this.#J!==J){if(this.#J.streamStates.size===0)this.#J.client.close()}this.#J=J,this.#R=void 0},(R)=>{this.#R=void 0})}if(this.#J.client.closed)try{if(this.#R!==void 0)this.#J=this.#R;else this.#J=this.#_()}catch(J){throw D(J)}let $=this.#J;try{if($.useSqlCache===void 0){if($.useSqlCache=await $.client.getVersion()>=2,$.useSqlCache)$.sqlCache.capacity=T0}let J=$.client.openStream();J.intMode=this.#$;let R={conn:$,stream:J};return $.streamStates.add(R),R}catch(J){throw D(J)}}#_(f){try{return f??=E1(this.#f,this.#X),{client:f,useSqlCache:void 0,sqlCache:new L2(f,0),openTime:new Date,streamStates:new Set}}catch(X){throw D(X)}}async reconnect(){try{for(let $ of Array.from(this.#J.streamStates))try{$.stream.close()}catch{}this.#J.client.close()}catch{}if(this.#R){try{this.#R.client.close()}catch{}this.#R=void 0}let f=this.#_(),X=await f.client.getVersion();if(f.useSqlCache=X>=2,f.useSqlCache)f.sqlCache.capacity=T0;this.#J=f,this.closed=!1}_closeStream(f){f.stream.close();let X=f.conn;if(X.streamStates.delete(f),X.streamStates.size===0&&X!==this.#J)X.client.close()}close(){if(this.#J.client.close(),this.closed=!0,this.#R){try{this.#R.client.close()}catch{}this.#R=void 0}this.closed=!0}}class j0 extends c2{#f;#X;constructor(f,X,$,J){super($,J);this.#f=f,this.#X=X}_getStream(){return this.#X.stream}_getSqlCache(){return this.#X.conn.sqlCache}close(){this.#f._closeStream(this.#X)}get closed(){return this.#X.stream.closed}}var E0=Q1(k1(),1);function h0(f){if(f.scheme!=="https"&&f.scheme!=="http")throw new K(`The HTTP client supports only "libsql:", "https:" and "http:" URLs, got ${JSON.stringify(f.scheme+":")}. For more information, please read ${h}`,"URL_SCHEME_NOT_SUPPORTED");if(f.encryptionKey!==void 0)throw new K("Encryption key is not supported by the remote client.","ENCRYPTION_KEY_NOT_SUPPORTED");if(f.scheme==="http"&&f.tls)throw new K('A "http:" URL cannot opt into TLS by using ?tls=1',"URL_INVALID");else if(f.scheme==="https"&&!f.tls)throw new K('A "https:" URL cannot opt out of TLS by using ?tls=0',"URL_INVALID");let X=F2(f.scheme,f.authority,f.path);return new k0(X,f.authToken,f.intMode,f.fetch,f.concurrency)}var P0=30;class k0{#f;protocol;#X;#$;#J;#R;#A;#Y;constructor(f,X,$,J,R){this.#X=f,this.#A=X,this.#$=$,this.#J=J,this.#R=R,this.#f=h1(this.#X,this.#A,this.#J),this.#f.intMode=this.#$,this.protocol="http",this.#Y=E0.default(this.#R)}async limit(f){return this.#Y(f)}async execute(f,X){let $;if(typeof f==="string")$={sql:f,args:X||[]};else $=f;return this.limit(async()=>{try{let J=g($),R,A=this.#f.openStream();try{R=A.query(J)}finally{A.closeGracefully()}let Z=await R;return H2(Z)}catch(J){throw D(J)}})}async batch(f,X="deferred"){return this.limit(async()=>{try{let J=f.map((_)=>{if(Array.isArray(_))return{sql:_[0],args:_[1]||[]};return _}).map(g),R=await this.#f.getVersion(),A,Z=this.#f.openStream();try{new L2(Z,P0).apply(J);let N=Z.batch(!1);A=y2(X,R,N,J)}finally{Z.closeGracefully()}return await A}catch($){throw D($)}})}async migrate(f){return this.limit(async()=>{try{let X=f.map(g),$=await this.#f.getVersion(),J,R=this.#f.openStream();try{let Z=R.batch(!1);J=y2("deferred",$,Z,X,!0)}finally{R.closeGracefully()}return await J}catch(X){throw D(X)}})}async transaction(f="write"){return this.limit(async()=>{try{let X=await this.#f.getVersion();return new q0(this.#f.openStream(),f,X)}catch(X){throw D(X)}})}async executeMultiple(f){return this.limit(async()=>{try{let X,$=this.#f.openStream();try{X=$.sequence(f)}finally{$.closeGracefully()}await X}catch(X){throw D(X)}})}sync(){throw new K("sync not supported in http mode","SYNC_NOT_SUPPORTED")}close(){this.#f.close()}async reconnect(){try{if(!this.closed)this.#f.close()}finally{this.#f=h1(this.#X,this.#A,this.#J),this.#f.intMode=this.#$}}get closed(){return this.#f.closed}}class q0 extends c2{#f;#X;constructor(f,X,$){super(X,$);this.#f=f,this.#X=new L2(f,P0)}_getStream(){return this.#f}_getSqlCache(){return this.#X}close(){this.#f.close()}get closed(){return this.#f.closed}}function C0(f){return x4(w2(f,!0))}function x4(f){if(f.scheme==="wss"||f.scheme==="ws")return M0(f);else if(f.scheme==="https"||f.scheme==="http")return h0(f);else return gf(f)}class Q4{client;dbPath;constructor(){let f=q1.join(process.cwd(),".sylphx-flow");if(!G1.existsSync(f))G1.mkdirSync(f,{recursive:!0});this.dbPath=q1.join(f,"memory.db"),this.client=C0({url:`file:${this.dbPath}`}),this.initializeTables()}async initializeTables(){await this.client.execute(`
      CREATE TABLE IF NOT EXISTS memory (
        key TEXT NOT NULL,
        namespace TEXT NOT NULL DEFAULT 'default',
        value TEXT NOT NULL,
        timestamp INTEGER NOT NULL,
        created_at TEXT NOT NULL,
        updated_at TEXT NOT NULL,
        PRIMARY KEY (key, namespace)
      )
    `),await this.client.execute(`
      CREATE INDEX IF NOT EXISTS idx_memory_namespace ON memory(namespace);
    `),await this.client.execute(`
      CREATE INDEX IF NOT EXISTS idx_memory_timestamp ON memory(timestamp);
    `),await this.client.execute(`
      CREATE INDEX IF NOT EXISTS idx_memory_key ON memory(key);
    `)}serializeValue(f){return JSON.stringify(f)}deserializeValue(f){try{return JSON.parse(f)}catch{return f}}async set(f,X,$="default"){let J=new Date,R=J.getTime(),A=J.toISOString(),Z=A,Y=this.serializeValue(X);if(await this.get(f,$))await this.client.execute({sql:`
        UPDATE memory 
        SET value = ?, timestamp = ?, updated_at = ?
        WHERE key = ? AND namespace = ?
      `,args:[Y,R,Z,f,$]});else await this.client.execute({sql:`
        INSERT INTO memory (key, namespace, value, timestamp, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?, ?)
      `,args:[f,$,Y,R,A,Z]})}async get(f,X="default"){let J=await this.client.execute({sql:`
      SELECT key, namespace, value, timestamp, created_at, updated_at
      FROM memory
      WHERE key = ? AND namespace = ?
    `,args:[f,X]});if(J.rows.length===0)return null;let R=J.rows[0];return{key:R.key,namespace:R.namespace,value:this.deserializeValue(R.value),timestamp:R.timestamp,created_at:R.created_at,updated_at:R.updated_at}}async getAll(){return(await this.client.execute(`
      SELECT key, namespace, value, timestamp, created_at, updated_at
      FROM memory
      ORDER BY timestamp DESC
    `)).rows.map(($)=>({key:$.key,namespace:$.namespace,value:this.deserializeValue($.value),timestamp:$.timestamp,created_at:$.created_at,updated_at:$.updated_at}))}async search(f,X){let $=f.replace(/\*/g,"%"),J=`
      SELECT key, namespace, value, timestamp, created_at, updated_at
      FROM memory
      WHERE key LIKE ? OR value LIKE ?
    `,R=[$,$];if(X&&X!=="all")J+=" AND namespace = ?",R.push(X);return J+=" ORDER BY timestamp DESC",(await this.client.execute({sql:J,args:R})).rows.map((Z)=>({key:Z.key,namespace:Z.namespace,value:this.deserializeValue(Z.value),timestamp:Z.timestamp,created_at:Z.created_at,updated_at:Z.updated_at}))}async delete(f,X="default"){return(await this.client.execute({sql:`
      DELETE FROM memory
      WHERE key = ? AND namespace = ?
    `,args:[f,X]})).rowsAffected>0}async clear(f){if(f&&f!=="all")await this.client.execute({sql:"DELETE FROM memory WHERE namespace = ?",args:[f]});else await this.client.execute("DELETE FROM memory")}async getStats(){let X=(await this.client.execute("SELECT COUNT(*) as count FROM memory")).rows[0].count,$=await this.client.execute(`
      SELECT namespace, COUNT(*) as count
      FROM memory
      GROUP BY namespace
      ORDER BY namespace
    `),J=$.rows.map((N)=>N.namespace),R={};$.rows.forEach((N)=>{R[N.namespace]=N.count});let Z=(await this.client.execute(`
      SELECT 
        MIN(created_at) as oldest,
        MAX(created_at) as newest
      FROM memory
    `)).rows[0],Y=Z.oldest,_=Z.newest;return{totalEntries:X,namespaces:J,namespaceCounts:R,oldestEntry:Y,newestEntry:_}}async load(){let f=await this.getAll(),X={};return f.forEach(($)=>{if(!X[$.namespace])X[$.namespace]={};X[$.namespace][$.key]=$.value}),{namespaces:X}}async close(){}getDatabasePath(){return this.dbPath}}
export{Q4 as c};
