import{k as B,n as W}from"./index-3xwx41er.js";import{o as Z,r as $}from"./index-163pjayt.js";var z={"sylphx-flow":{id:"sylphx-flow",name:"sylphx-flow",description:"Sylphx Flow MCP server for agent coordination and memory management",config:{type:"local",command:["npx","-y","github:sylphxltd/flow","mcp","start"],environment:{OPENAI_API_KEY:"",OPENAI_BASE_URL:"https://api.openai.com/v1",EMBEDDING_MODEL:"text-embedding-3-small"}},command:{baseCommand:["npx","-y","github:sylphxltd/flow","mcp","start"],updateCommand:async(k,q)=>{let w=[...k],{MCP_SERVER_REGISTRY:L}=await Promise.resolve().then(() => require_servers()),H=L["sylphx-flow"];if(H?.flags){let F=[];for(let[O,Q]of Object.entries(H.flags)){let X=Q.shouldEnable;if(X){if(await X())F.push(`--${O}`)}else if(Q.enabled!==void 0){if(Q.enabled)F.push(`--${O}`)}}w.push(...F)}return w}},envVars:{OPENAI_API_KEY:{description:"OpenAI API key for vector search embeddings",required:!1,secret:!0},OPENAI_BASE_URL:{description:"Base URL for OpenAI-compatible embedding API",required:!1,default:"https://api.openai.com/v1"},EMBEDDING_MODEL:{description:"Embedding model to use for vector search",required:!1,default:"text-embedding-3-small",dependsOn:["OPENAI_API_KEY","OPENAI_BASE_URL"],fetchChoices:async()=>{let k=W.getEnvVar("OPENAI_BASE_URL","https://api.openai.com/v1"),q=W.getEnvVar("OPENAI_API_KEY");if(!q)throw Error("OPENAI_API_KEY is required to fetch embedding models");try{B.apiKey.parse(q)}catch(F){throw Error("Invalid OPENAI_API_KEY format")}let w=await fetch(`${k}/models`,{headers:{Authorization:`Bearer ${q}`},timeout:1e4});if(!w.ok)throw Error(`Failed to fetch models: ${w.statusText}`);let H=(await w.json()).data.filter((F)=>F.id.includes("embedding")).map((F)=>F.id).sort();if(H.length===0)throw Error("No embedding models found");return H}}},flags:{"disable-memory":{description:"Disable memory functionality",shouldEnable:async()=>{try{let k=await import("node:fs/promises"),q=await import("node:path"),w=q.join(process.cwd(),".mcp.json"),L=q.join(process.cwd(),".claude","settings.local.json"),[H,F]=await Promise.allSettled([k.access(w).then(()=>!0).catch(()=>!1),k.access(L).then(()=>!0).catch(()=>!1)]);if(H.success||F.success)return!0;let O=q.join(process.cwd(),"opencode.jsonc");if(await k.access(O).then(()=>!0).catch(()=>!1))return!1}catch{}return!1}}},category:"core",defaultInInit:!0,required:!0},"gpt-image":{id:"gpt-image",name:"gpt-image-1-mcp",description:"GPT Image generation MCP server",config:{type:"local",command:["npx","@napolab/gpt-image-1-mcp"],environment:{OPENAI_API_KEY:""}},envVars:{OPENAI_API_KEY:{description:"OpenAI API key for image generation",required:!0,secret:!0}},category:"ai",defaultInInit:!1},perplexity:{id:"perplexity",name:"perplexity-ask",description:"Perplexity Ask MCP server for search and queries",config:{type:"local",command:["npx","-y","server-perplexity-ask"],environment:{PERPLEXITY_API_KEY:""}},envVars:{PERPLEXITY_API_KEY:{description:"Perplexity API key for search and queries",required:!0,secret:!0}},category:"ai",defaultInInit:!1},context7:{id:"context7",name:"context7",description:"Context7 HTTP MCP server for documentation retrieval",config:{type:"remote",url:"https://mcp.context7.com/mcp"},envVars:{CONTEXT7_API_KEY:{description:"Context7 API key for enhanced documentation access",required:!1,secret:!0}},category:"external",defaultInInit:!0},"gemini-search":{id:"gemini-search",name:"gemini-google-search",description:"Gemini Google Search MCP server",config:{type:"local",command:["npx","-y","mcp-gemini-google-search"],environment:{GEMINI_API_KEY:"",GEMINI_MODEL:"gemini-2.5-flash"}},envVars:{GEMINI_API_KEY:{description:"Google Gemini API key for search functionality",required:!0,secret:!0},GEMINI_MODEL:{description:"Gemini model to use for search",required:!1,default:"gemini-2.5-flash"}},category:"ai",defaultInInit:!1},grep:{id:"grep",name:"grep",description:"GitHub grep MCP server for searching GitHub repositories",config:{type:"remote",url:"https://mcp.grep.app"},category:"external",defaultInInit:!0}};function j(){return Object.keys(z)}function x(k){return Object.entries(z).filter(([,q])=>q.category===k).map(([q])=>q)}function D(){return Object.entries(z).filter(([,k])=>k.defaultInInit).map(([k])=>k)}function N(){return Object.entries(z).filter(([,k])=>k.envVars&&Object.values(k.envVars).some((q)=>q.required)).map(([k])=>k)}function K(){return Object.entries(z).filter(([,k])=>k.envVars&&Object.values(k.envVars).some((q)=>!q.required)).map(([k])=>k)}function b(){return Object.entries(z).filter(([,k])=>k.envVars&&Object.keys(k.envVars).length>0).map(([k])=>k)}function A(k){let q=z[k];if(!q?.envVars)return[];return Object.entries(q.envVars).filter(([,w])=>w.required).map(([w])=>w)}function u(k){let q=z[k];if(!q?.envVars)return[];return Object.entries(q.envVars).filter(([,w])=>!w.required).map(([w])=>w)}function y(k){let q=z[k];if(!q?.envVars)return[];return Object.keys(q.envVars)}function h(k){let q=z[k];if(!q?.envVars)return[];return Object.entries(q.envVars).filter(([,w])=>w.secret).map(([w])=>w)}function p(k){let q=z[k];if(!q?.envVars)return[];return Object.entries(q.envVars).filter(([,w])=>!w.secret).map(([w])=>w)}function Y(k){return k in z}function G(k){let q=z[k];if(!q)throw Error(`Unknown MCP server: ${k}`);return q}export{Y as isValidServerID,K as getServersWithOptionalAPIKeys,b as getServersWithAnyAPIKeys,N as getServersRequiringAPIKeys,x as getServersByCategory,G as getServerDefinition,h as getSecretEnvVars,A as getRequiredEnvVars,u as getOptionalEnvVars,p as getNonSecretEnvVars,D as getDefaultServers,j as getAllServerIDs,y as getAllEnvVars,z as MCP_SERVER_REGISTRY};
export{z as d,j as e};
