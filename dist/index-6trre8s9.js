import{d as J1,e as M,g as U}from"./index-vkz1hhmk.js";var V6=M((v)=>{var I8=v&&v.__createBinding||(Object.create?function(X,$,J,Z){if(Z===void 0)Z=J;var K=Object.getOwnPropertyDescriptor($,J);if(!K||("get"in K?!$.__esModule:K.writable||K.configurable))K={enumerable:!0,get:function(){return $[J]}};Object.defineProperty(X,Z,K)}:function(X,$,J,Z){if(Z===void 0)Z=J;X[Z]=$[J]}),V8=v&&v.__setModuleDefault||(Object.create?function(X,$){Object.defineProperty(X,"default",{enumerable:!0,value:$})}:function(X,$){X.default=$}),I6=v&&v.__importStar||function(X){if(X&&X.__esModule)return X;var $={};if(X!=null){for(var J in X)if(J!=="default"&&Object.prototype.hasOwnProperty.call(X,J))I8($,X,J)}return V8($,X),$};Object.defineProperty(v,"__esModule",{value:!0});v.load=v.currentTarget=void 0;var O8=I6(U("path")),D8=I6(U("fs"));function H8(){let X=null;switch(process.platform){case"android":switch(process.arch){case"arm":return"android-arm-eabi";case"arm64":return"android-arm64"}X="Android";break;case"win32":switch(process.arch){case"x64":return"win32-x64-msvc";case"arm64":return"win32-arm64-msvc";case"ia32":return"win32-ia32-msvc"}X="Windows";break;case"darwin":switch(process.arch){case"x64":return"darwin-x64";case"arm64":return"darwin-arm64"}X="macOS";break;case"linux":switch(process.arch){case"x64":case"arm64":return x8()?`linux-${process.arch}-gnu`:`linux-${process.arch}-musl`;case"arm":return"linux-arm-gnueabihf"}X="Linux";break;case"freebsd":if(process.arch==="x64")return"freebsd-x64";X="FreeBSD";break}if(X)throw Error(`Neon: unsupported ${X} architecture: ${process.arch}`);throw Error(`Neon: unsupported system: ${process.platform}`)}v.currentTarget=H8;function x8(){let X=process.report?.getReport();if(typeof X!=="object"||!X||!("header"in X))return!1;let $=X.header;return typeof $==="object"&&!!$&&"glibcVersionRuntime"in $}function B8(X){let $=O8.join(X,"index.node");return D8.existsSync($)?U($):null}v.load=B8});var H6=M((NZ,D6)=>{var O6=()=>process.platform==="linux",A0=null,U8=()=>{if(!A0)A0=O6()&&process.report?process.report.getReport():{};return A0};D6.exports={isLinux:O6,getReport:U8}});var U6=M((AZ,B6)=>{var x6=U("fs"),W8=(X)=>x6.readFileSync(X,"utf-8"),j8=(X)=>new Promise(($,J)=>{x6.readFile(X,"utf-8",(Z,K)=>{if(Z)J(Z);else $(K)})});B6.exports={LDD_PATH:"/usr/bin/ldd",readFileSync:W8,readFile:j8}});var g6=M((QZ,v6)=>{var j6=U("child_process"),{isLinux:C1,getReport:F6}=H6(),{LDD_PATH:f2,readFile:T6,readFileSync:M6}=U6(),m,d,$1="",L6=()=>{if(!$1)return new Promise((X)=>{j6.exec("getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true",($,J)=>{$1=$?" ":J,X($1)})});return $1},y6=()=>{if(!$1)try{$1=j6.execSync("getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true",{encoding:"utf8"})}catch(X){$1=" "}return $1},c="glibc",P6=/GLIBC\s(\d+\.\d+)/,O1="musl",F8=c.toUpperCase(),T8=O1.toLowerCase(),M8=(X)=>X.includes("libc.musl-")||X.includes("ld-musl-"),E6=()=>{let X=F6();if(X.header&&X.header.glibcVersionRuntime)return c;if(Array.isArray(X.sharedObjects)){if(X.sharedObjects.some(M8))return O1}return null},q6=(X)=>{let[$,J]=X.split(/[\r\n]+/);if($&&$.includes(c))return c;if(J&&J.includes(O1))return O1;return null},f6=(X)=>{if(X.includes(T8))return O1;if(X.includes(F8))return c;return null},L8=async()=>{if(m!==void 0)return m;m=null;try{let X=await T6(f2);m=f6(X)}catch(X){}return m},y8=()=>{if(m!==void 0)return m;m=null;try{let X=M6(f2);m=f6(X)}catch(X){}return m},C6=async()=>{let X=null;if(C1()){if(X=await L8(),!X)X=E6();if(!X){let $=await L6();X=q6($)}}return X},w6=()=>{let X=null;if(C1()){if(X=y8(),!X)X=E6();if(!X){let $=y6();X=q6($)}}return X},P8=async()=>C1()&&await C6()!==c,E8=()=>C1()&&w6()!==c,q8=async()=>{if(d!==void 0)return d;d=null;try{let $=(await T6(f2)).match(P6);if($)d=$[1]}catch(X){}return d},f8=()=>{if(d!==void 0)return d;d=null;try{let $=M6(f2).match(P6);if($)d=$[1]}catch(X){}return d},h6=()=>{let X=F6();if(X.header&&X.header.glibcVersionRuntime)return X.header.glibcVersionRuntime;return null},W6=(X)=>X.trim().split(/\s+/)[1],S6=(X)=>{let[$,J,Z]=X.split(/[\r\n]+/);if($&&$.includes(c))return W6($);if(J&&Z&&J.includes(O1))return W6(Z);return null},C8=async()=>{let X=null;if(C1()){if(X=await q8(),!X)X=h6();if(!X){let $=await L6();X=S6($)}}return X},w8=()=>{let X=null;if(C1()){if(X=f8(),!X)X=h6();if(!X){let $=y6();X=S6($)}}return X};v6.exports={GLIBC:c,MUSL:O1,family:C6,familySync:w6,isNonGlibcLinux:P8,isNonGlibcLinuxSync:E8,version:C8,versionSync:w8}});var k6=M((IZ,u6)=>{var h8={ALLOW:0,DENY:1};u6.exports=h8});var b6=M((VZ,p6)=>{var Q0={value:"SqliteError",writable:!0,enumerable:!1,configurable:!0};function D1(X,$,J){if(new.target!==D1)return new D1(X,$);if(typeof $!=="string")throw TypeError("Expected second argument to be a string");Error.call(this,X),Q0.value=""+X,Object.defineProperty(this,"message",Q0),Error.captureStackTrace(this,D1),this.code=$,this.rawCode=J}Object.setPrototypeOf(D1,Error);Object.setPrototypeOf(D1.prototype,Error.prototype);Object.defineProperty(D1.prototype,"name",Q0);p6.exports=D1});var r6=M((OZ,C2)=>{var __dirname="/Users/kyle/rules/node_modules/libsql",{load:S8,currentTarget:v8}=V6(),{familySync:i6,GLIBC:g8,MUSL:u8}=g6();function k8(){if(process.env.LIBSQL_JS_DEV)return S8(__dirname);let X=v8();if(i6()==g8)switch(X){case"linux-x64-musl":X="linux-x64-gnu";break;case"linux-arm64-musl":X="linux-arm64-gnu";break}if(X==="linux-arm-gnueabihf"&&i6()==u8)X="linux-arm-musleabihf";return U(`@libsql/${X}`)}var{databaseOpen:p8,databaseOpenWithSync:b8,databaseInTransaction:i8,databaseInterrupt:m8,databaseClose:d8,databaseSyncSync:l8,databaseSyncUntilSync:n8,databaseExecSync:c8,databasePrepareSync:s8,databaseDefaultSafeIntegers:r8,databaseAuthorizer:a8,databaseLoadExtension:t8,databaseMaxWriteReplicationIndex:o8,statementRaw:e8,statementIsReader:XX,statementGet:m6,statementRun:d6,statementInterrupt:$X,statementRowsSync:l6,statementColumns:JX,statementSafeIntegers:ZX,rowsNext:KX}=k8(),GX=k6(),n6=b6();function w1(X){if(X.libsqlError)return new n6(X.message,X.code,X.rawCode);return X}class c6{constructor(X,$){let J=$?.encryptionCipher??"aes256cbc";if($&&$.syncUrl){var Z="";if($.syncAuth)console.warn("Warning: The `syncAuth` option is deprecated, please use `authToken` option instead."),Z=$.syncAuth;else if($.authToken)Z=$.authToken;let G=$?.encryptionKey??"",Y=$?.syncPeriod??0,_=$?.readYourWrites??!0,z=$?.offline??!1,R=$?.remoteEncryptionKey??"";this.db=b8(X,$.syncUrl,Z,J,G,Y,_,z,R)}else{let G=$?.authToken??"",Y=$?.encryptionKey??"",_=$?.timeout??0,z=$?.remoteEncryptionKey??"";this.db=p8(X,G,J,Y,_,z)}this.memory=X===":memory:",this.readonly=!1,this.name="",this.open=!0;let K=this.db;Object.defineProperties(this,{inTransaction:{get(){return i8(K)}}})}sync(){return l8.call(this.db)}syncUntil(X){return n8.call(this.db,X)}prepare(X){try{let $=s8.call(this.db,X);return new s6($)}catch($){throw w1($)}}transaction(X){if(typeof X!=="function")throw TypeError("Expected first argument to be a function");let $=this,J=(K)=>{return(...G)=>{$.exec("BEGIN "+K);try{let Y=X(...G);return $.exec("COMMIT"),Y}catch(Y){throw $.exec("ROLLBACK"),Y}}},Z={default:{value:J("")},deferred:{value:J("DEFERRED")},immediate:{value:J("IMMEDIATE")},exclusive:{value:J("EXCLUSIVE")},database:{value:this,enumerable:!0}};return Object.defineProperties(Z.default.value,Z),Object.defineProperties(Z.deferred.value,Z),Object.defineProperties(Z.immediate.value,Z),Object.defineProperties(Z.exclusive.value,Z),Z.default.value}pragma(X,$){if($==null)$={};if(typeof X!=="string")throw TypeError("Expected first argument to be a string");if(typeof $!=="object")throw TypeError("Expected second argument to be an options object");let J=$.simple,Z=this.prepare(`PRAGMA ${X}`,this,!0);return J?Z.pluck().get():Z.all()}backup(X,$){throw Error("not implemented")}serialize(X){throw Error("not implemented")}function(X,$,J){if($==null)$={};if(typeof $==="function")J=$,$={};if(typeof X!=="string")throw TypeError("Expected first argument to be a string");if(typeof J!=="function")throw TypeError("Expected last argument to be a function");if(typeof $!=="object")throw TypeError("Expected second argument to be an options object");if(!X)throw TypeError("User-defined function name cannot be an empty string");throw Error("not implemented")}aggregate(X,$){if(typeof X!=="string")throw TypeError("Expected first argument to be a string");if(typeof $!=="object"||$===null)throw TypeError("Expected second argument to be an options object");if(!X)throw TypeError("User-defined function name cannot be an empty string");throw Error("not implemented")}table(X,$){if(typeof X!=="string")throw TypeError("Expected first argument to be a string");if(!X)throw TypeError("Virtual table module name cannot be an empty string");throw Error("not implemented")}authorizer(X){a8.call(this.db,X)}loadExtension(...X){t8.call(this.db,...X)}maxWriteReplicationIndex(){return o8.call(this.db)}exec(X){try{c8.call(this.db,X)}catch($){throw w1($)}}interrupt(){m8.call(this.db)}close(){d8.call(this.db),this.open=!1}defaultSafeIntegers(X){return r8.call(this.db,X??!0),this}unsafeMode(...X){throw Error("not implemented")}}class s6{constructor(X){this.stmt=X,this.pluckMode=!1}raw(X){return e8.call(this.stmt,X??!0),this}pluck(X){return this.pluckMode=X??!0,this}get reader(){return XX.call(this.stmt)}run(...X){try{if(X.length==1&&typeof X[0]==="object")return d6.call(this.stmt,X[0]);else return d6.call(this.stmt,X.flat())}catch($){throw w1($)}}get(...X){try{if(X.length==1&&typeof X[0]==="object")return m6.call(this.stmt,X[0]);else return m6.call(this.stmt,X.flat())}catch($){throw w1($)}}iterate(...X){var $=void 0;if(X.length==1&&typeof X[0]==="object")$=l6.call(this.stmt,X[0]);else $=l6.call(this.stmt,X.flat());return{nextRows:Array(100),nextRowIndex:100,next(){try{if(this.nextRowIndex===100)KX.call($,this.nextRows),this.nextRowIndex=0;let Z=this.nextRows[this.nextRowIndex];if(this.nextRows[this.nextRowIndex]=void 0,!Z)return{done:!0};return this.nextRowIndex++,{value:Z,done:!1}}catch(Z){throw w1(Z)}},[Symbol.iterator](){return this}}}all(...X){try{let $=[];for(let J of this.iterate(...X))if(this.pluckMode)$.push(J[Object.keys(J)[0]]);else $.push(J);return $}catch($){throw w1($)}}interrupt(){$X.call(this.stmt)}columns(){return JX.call(this.stmt)}safeIntegers(X){return ZX.call(this.stmt,X??!0),this}}C2.exports=c6;C2.exports.Authorization=GX;C2.exports.SqliteError=n6});var s=M((FZ,G3)=>{var Z3=["nodebuffer","arraybuffer","fragments"],K3=typeof Blob<"u";if(K3)Z3.push("blob");G3.exports={BINARY_TYPES:Z3,EMPTY_BUFFER:Buffer.alloc(0),GUID:"258EAFA5-E914-47DA-95CA-C5AB0DC85B11",hasBlob:K3,kForOnEventAttribute:Symbol("kIsForOnEventAttribute"),kListener:Symbol("kListener"),kStatusCode:Symbol("status-code"),kWebSocket:Symbol("websocket"),NOOP:()=>{}}});var G2=M((TZ,w2)=>{var{EMPTY_BUFFER:QX}=s(),I0=Buffer[Symbol.species];function IX(X,$){if(X.length===0)return QX;if(X.length===1)return X[0];let J=Buffer.allocUnsafe($),Z=0;for(let K=0;K<X.length;K++){let G=X[K];J.set(G,Z),Z+=G.length}if(Z<$)return new I0(J.buffer,J.byteOffset,Z);return J}function Y3(X,$,J,Z,K){for(let G=0;G<K;G++)J[Z+G]=X[G]^$[G&3]}function z3(X,$){for(let J=0;J<X.length;J++)X[J]^=$[J&3]}function VX(X){if(X.length===X.buffer.byteLength)return X.buffer;return X.buffer.slice(X.byteOffset,X.byteOffset+X.length)}function V0(X){if(V0.readOnly=!0,Buffer.isBuffer(X))return X;let $;if(X instanceof ArrayBuffer)$=new I0(X);else if(ArrayBuffer.isView(X))$=new I0(X.buffer,X.byteOffset,X.byteLength);else $=Buffer.from(X),V0.readOnly=!1;return $}w2.exports={concat:IX,mask:Y3,toArrayBuffer:VX,toBuffer:V0,unmask:z3};if(!process.env.WS_NO_BUFFER_UTIL)try{let X=(()=>{throw new Error("Cannot require module "+"bufferutil");})();w2.exports.mask=function($,J,Z,K,G){if(G<48)Y3($,J,Z,K,G);else X.mask($,J,Z,K,G)},w2.exports.unmask=function($,J){if($.length<32)z3($,J);else X.unmask($,J)}}catch(X){}});var A3=M((MZ,N3)=>{var _3=Symbol("kDone"),O0=Symbol("kRun");class R3{constructor(X){this[_3]=()=>{this.pending--,this[O0]()},this.concurrency=X||1/0,this.jobs=[],this.pending=0}add(X){this.jobs.push(X),this[O0]()}[O0](){if(this.pending===this.concurrency)return;if(this.jobs.length){let X=this.jobs.shift();this.pending++,X(this[_3])}}}N3.exports=R3});var z2=M((LZ,D3)=>{var Y2=U("zlib"),Q3=G2(),OX=A3(),{kStatusCode:I3}=s(),DX=Buffer[Symbol.species],HX=Buffer.from([0,0,255,255]),S2=Symbol("permessage-deflate"),r=Symbol("total-length"),h1=Symbol("callback"),Z1=Symbol("buffers"),S1=Symbol("error"),h2;class V3{constructor(X,$,J){if(this._maxPayload=J|0,this._options=X||{},this._threshold=this._options.threshold!==void 0?this._options.threshold:1024,this._isServer=!!$,this._deflate=null,this._inflate=null,this.params=null,!h2){let Z=this._options.concurrencyLimit!==void 0?this._options.concurrencyLimit:10;h2=new OX(Z)}}static get extensionName(){return"permessage-deflate"}offer(){let X={};if(this._options.serverNoContextTakeover)X.server_no_context_takeover=!0;if(this._options.clientNoContextTakeover)X.client_no_context_takeover=!0;if(this._options.serverMaxWindowBits)X.server_max_window_bits=this._options.serverMaxWindowBits;if(this._options.clientMaxWindowBits)X.client_max_window_bits=this._options.clientMaxWindowBits;else if(this._options.clientMaxWindowBits==null)X.client_max_window_bits=!0;return X}accept(X){return X=this.normalizeParams(X),this.params=this._isServer?this.acceptAsServer(X):this.acceptAsClient(X),this.params}cleanup(){if(this._inflate)this._inflate.close(),this._inflate=null;if(this._deflate){let X=this._deflate[h1];if(this._deflate.close(),this._deflate=null,X)X(Error("The deflate stream was closed while data was being processed"))}}acceptAsServer(X){let $=this._options,J=X.find((Z)=>{if($.serverNoContextTakeover===!1&&Z.server_no_context_takeover||Z.server_max_window_bits&&($.serverMaxWindowBits===!1||typeof $.serverMaxWindowBits==="number"&&$.serverMaxWindowBits>Z.server_max_window_bits)||typeof $.clientMaxWindowBits==="number"&&!Z.client_max_window_bits)return!1;return!0});if(!J)throw Error("None of the extension offers can be accepted");if($.serverNoContextTakeover)J.server_no_context_takeover=!0;if($.clientNoContextTakeover)J.client_no_context_takeover=!0;if(typeof $.serverMaxWindowBits==="number")J.server_max_window_bits=$.serverMaxWindowBits;if(typeof $.clientMaxWindowBits==="number")J.client_max_window_bits=$.clientMaxWindowBits;else if(J.client_max_window_bits===!0||$.clientMaxWindowBits===!1)delete J.client_max_window_bits;return J}acceptAsClient(X){let $=X[0];if(this._options.clientNoContextTakeover===!1&&$.client_no_context_takeover)throw Error('Unexpected parameter "client_no_context_takeover"');if(!$.client_max_window_bits){if(typeof this._options.clientMaxWindowBits==="number")$.client_max_window_bits=this._options.clientMaxWindowBits}else if(this._options.clientMaxWindowBits===!1||typeof this._options.clientMaxWindowBits==="number"&&$.client_max_window_bits>this._options.clientMaxWindowBits)throw Error('Unexpected or invalid parameter "client_max_window_bits"');return $}normalizeParams(X){return X.forEach(($)=>{Object.keys($).forEach((J)=>{let Z=$[J];if(Z.length>1)throw Error(`Parameter "${J}" must have only a single value`);if(Z=Z[0],J==="client_max_window_bits"){if(Z!==!0){let K=+Z;if(!Number.isInteger(K)||K<8||K>15)throw TypeError(`Invalid value for parameter "${J}": ${Z}`);Z=K}else if(!this._isServer)throw TypeError(`Invalid value for parameter "${J}": ${Z}`)}else if(J==="server_max_window_bits"){let K=+Z;if(!Number.isInteger(K)||K<8||K>15)throw TypeError(`Invalid value for parameter "${J}": ${Z}`);Z=K}else if(J==="client_no_context_takeover"||J==="server_no_context_takeover"){if(Z!==!0)throw TypeError(`Invalid value for parameter "${J}": ${Z}`)}else throw Error(`Unknown parameter "${J}"`);$[J]=Z})}),X}decompress(X,$,J){h2.add((Z)=>{this._decompress(X,$,(K,G)=>{Z(),J(K,G)})})}compress(X,$,J){h2.add((Z)=>{this._compress(X,$,(K,G)=>{Z(),J(K,G)})})}_decompress(X,$,J){let Z=this._isServer?"client":"server";if(!this._inflate){let K=`${Z}_max_window_bits`,G=typeof this.params[K]!=="number"?Y2.Z_DEFAULT_WINDOWBITS:this.params[K];this._inflate=Y2.createInflateRaw({...this._options.zlibInflateOptions,windowBits:G}),this._inflate[S2]=this,this._inflate[r]=0,this._inflate[Z1]=[],this._inflate.on("error",BX),this._inflate.on("data",O3)}if(this._inflate[h1]=J,this._inflate.write(X),$)this._inflate.write(HX);this._inflate.flush(()=>{let K=this._inflate[S1];if(K){this._inflate.close(),this._inflate=null,J(K);return}let G=Q3.concat(this._inflate[Z1],this._inflate[r]);if(this._inflate._readableState.endEmitted)this._inflate.close(),this._inflate=null;else if(this._inflate[r]=0,this._inflate[Z1]=[],$&&this.params[`${Z}_no_context_takeover`])this._inflate.reset();J(null,G)})}_compress(X,$,J){let Z=this._isServer?"server":"client";if(!this._deflate){let K=`${Z}_max_window_bits`,G=typeof this.params[K]!=="number"?Y2.Z_DEFAULT_WINDOWBITS:this.params[K];this._deflate=Y2.createDeflateRaw({...this._options.zlibDeflateOptions,windowBits:G}),this._deflate[r]=0,this._deflate[Z1]=[],this._deflate.on("data",xX)}this._deflate[h1]=J,this._deflate.write(X),this._deflate.flush(Y2.Z_SYNC_FLUSH,()=>{if(!this._deflate)return;let K=Q3.concat(this._deflate[Z1],this._deflate[r]);if($)K=new DX(K.buffer,K.byteOffset,K.length-4);if(this._deflate[h1]=null,this._deflate[r]=0,this._deflate[Z1]=[],$&&this.params[`${Z}_no_context_takeover`])this._deflate.reset();J(null,K)})}}D3.exports=V3;function xX(X){this[Z1].push(X),this[r]+=X.length}function O3(X){if(this[r]+=X.length,this[S2]._maxPayload<1||this[r]<=this[S2]._maxPayload){this[Z1].push(X);return}this[S1]=RangeError("Max payload size exceeded"),this[S1].code="WS_ERR_UNSUPPORTED_MESSAGE_LENGTH",this[S1][I3]=1009,this.removeListener("data",O3),this.reset()}function BX(X){if(this[S2]._inflate=null,this[S1]){this[h1](this[S1]);return}X[I3]=1007,this[h1](X)}});var v1=M((yZ,v2)=>{var{isUtf8:H3}=U("buffer"),{hasBlob:UX}=s(),WX=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,0];function jX(X){return X>=1000&&X<=1014&&X!==1004&&X!==1005&&X!==1006||X>=3000&&X<=4999}function D0(X){let $=X.length,J=0;while(J<$)if((X[J]&128)===0)J++;else if((X[J]&224)===192){if(J+1===$||(X[J+1]&192)!==128||(X[J]&254)===192)return!1;J+=2}else if((X[J]&240)===224){if(J+2>=$||(X[J+1]&192)!==128||(X[J+2]&192)!==128||X[J]===224&&(X[J+1]&224)===128||X[J]===237&&(X[J+1]&224)===160)return!1;J+=3}else if((X[J]&248)===240){if(J+3>=$||(X[J+1]&192)!==128||(X[J+2]&192)!==128||(X[J+3]&192)!==128||X[J]===240&&(X[J+1]&240)===128||X[J]===244&&X[J+1]>143||X[J]>244)return!1;J+=4}else return!1;return!0}function FX(X){return UX&&typeof X==="object"&&typeof X.arrayBuffer==="function"&&typeof X.type==="string"&&typeof X.stream==="function"&&(X[Symbol.toStringTag]==="Blob"||X[Symbol.toStringTag]==="File")}v2.exports={isBlob:FX,isValidStatusCode:jX,isValidUTF8:D0,tokenChars:WX};if(H3)v2.exports.isValidUTF8=function(X){return X.length<24?D0(X):H3(X)};else if(!process.env.WS_NO_UTF_8_VALIDATE)try{let X=(()=>{throw new Error("Cannot require module "+"utf-8-validate");})();v2.exports.isValidUTF8=function($){return $.length<32?D0($):X($)}}catch(X){}});var x0=M((PZ,j3)=>{var{Writable:TX}=U("stream"),x3=z2(),{BINARY_TYPES:MX,EMPTY_BUFFER:B3,kStatusCode:LX,kWebSocket:yX}=s(),{concat:H0,toArrayBuffer:PX,unmask:EX}=G2(),{isValidStatusCode:qX,isValidUTF8:U3}=v1(),g2=Buffer[Symbol.species];class W3 extends TX{constructor(X={}){super();this._allowSynchronousEvents=X.allowSynchronousEvents!==void 0?X.allowSynchronousEvents:!0,this._binaryType=X.binaryType||MX[0],this._extensions=X.extensions||{},this._isServer=!!X.isServer,this._maxPayload=X.maxPayload|0,this._skipUTF8Validation=!!X.skipUTF8Validation,this[yX]=void 0,this._bufferedBytes=0,this._buffers=[],this._compressed=!1,this._payloadLength=0,this._mask=void 0,this._fragmented=0,this._masked=!1,this._fin=!1,this._opcode=0,this._totalPayloadLength=0,this._messageLength=0,this._fragments=[],this._errored=!1,this._loop=!1,this._state=0}_write(X,$,J){if(this._opcode===8&&this._state==0)return J();this._bufferedBytes+=X.length,this._buffers.push(X),this.startLoop(J)}consume(X){if(this._bufferedBytes-=X,X===this._buffers[0].length)return this._buffers.shift();if(X<this._buffers[0].length){let J=this._buffers[0];return this._buffers[0]=new g2(J.buffer,J.byteOffset+X,J.length-X),new g2(J.buffer,J.byteOffset,X)}let $=Buffer.allocUnsafe(X);do{let J=this._buffers[0],Z=$.length-X;if(X>=J.length)$.set(this._buffers.shift(),Z);else $.set(new Uint8Array(J.buffer,J.byteOffset,X),Z),this._buffers[0]=new g2(J.buffer,J.byteOffset+X,J.length-X);X-=J.length}while(X>0);return $}startLoop(X){this._loop=!0;do switch(this._state){case 0:this.getInfo(X);break;case 1:this.getPayloadLength16(X);break;case 2:this.getPayloadLength64(X);break;case 3:this.getMask();break;case 4:this.getData(X);break;case 5:case 6:this._loop=!1;return}while(this._loop);if(!this._errored)X()}getInfo(X){if(this._bufferedBytes<2){this._loop=!1;return}let $=this.consume(2);if(($[0]&48)!==0){let Z=this.createError(RangeError,"RSV2 and RSV3 must be clear",!0,1002,"WS_ERR_UNEXPECTED_RSV_2_3");X(Z);return}let J=($[0]&64)===64;if(J&&!this._extensions[x3.extensionName]){let Z=this.createError(RangeError,"RSV1 must be clear",!0,1002,"WS_ERR_UNEXPECTED_RSV_1");X(Z);return}if(this._fin=($[0]&128)===128,this._opcode=$[0]&15,this._payloadLength=$[1]&127,this._opcode===0){if(J){let Z=this.createError(RangeError,"RSV1 must be clear",!0,1002,"WS_ERR_UNEXPECTED_RSV_1");X(Z);return}if(!this._fragmented){let Z=this.createError(RangeError,"invalid opcode 0",!0,1002,"WS_ERR_INVALID_OPCODE");X(Z);return}this._opcode=this._fragmented}else if(this._opcode===1||this._opcode===2){if(this._fragmented){let Z=this.createError(RangeError,`invalid opcode ${this._opcode}`,!0,1002,"WS_ERR_INVALID_OPCODE");X(Z);return}this._compressed=J}else if(this._opcode>7&&this._opcode<11){if(!this._fin){let Z=this.createError(RangeError,"FIN must be set",!0,1002,"WS_ERR_EXPECTED_FIN");X(Z);return}if(J){let Z=this.createError(RangeError,"RSV1 must be clear",!0,1002,"WS_ERR_UNEXPECTED_RSV_1");X(Z);return}if(this._payloadLength>125||this._opcode===8&&this._payloadLength===1){let Z=this.createError(RangeError,`invalid payload length ${this._payloadLength}`,!0,1002,"WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");X(Z);return}}else{let Z=this.createError(RangeError,`invalid opcode ${this._opcode}`,!0,1002,"WS_ERR_INVALID_OPCODE");X(Z);return}if(!this._fin&&!this._fragmented)this._fragmented=this._opcode;if(this._masked=($[1]&128)===128,this._isServer){if(!this._masked){let Z=this.createError(RangeError,"MASK must be set",!0,1002,"WS_ERR_EXPECTED_MASK");X(Z);return}}else if(this._masked){let Z=this.createError(RangeError,"MASK must be clear",!0,1002,"WS_ERR_UNEXPECTED_MASK");X(Z);return}if(this._payloadLength===126)this._state=1;else if(this._payloadLength===127)this._state=2;else this.haveLength(X)}getPayloadLength16(X){if(this._bufferedBytes<2){this._loop=!1;return}this._payloadLength=this.consume(2).readUInt16BE(0),this.haveLength(X)}getPayloadLength64(X){if(this._bufferedBytes<8){this._loop=!1;return}let $=this.consume(8),J=$.readUInt32BE(0);if(J>Math.pow(2,21)-1){let Z=this.createError(RangeError,"Unsupported WebSocket frame: payload length > 2^53 - 1",!1,1009,"WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");X(Z);return}this._payloadLength=J*Math.pow(2,32)+$.readUInt32BE(4),this.haveLength(X)}haveLength(X){if(this._payloadLength&&this._opcode<8){if(this._totalPayloadLength+=this._payloadLength,this._totalPayloadLength>this._maxPayload&&this._maxPayload>0){let $=this.createError(RangeError,"Max payload size exceeded",!1,1009,"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");X($);return}}if(this._masked)this._state=3;else this._state=4}getMask(){if(this._bufferedBytes<4){this._loop=!1;return}this._mask=this.consume(4),this._state=4}getData(X){let $=B3;if(this._payloadLength){if(this._bufferedBytes<this._payloadLength){this._loop=!1;return}if($=this.consume(this._payloadLength),this._masked&&(this._mask[0]|this._mask[1]|this._mask[2]|this._mask[3])!==0)EX($,this._mask)}if(this._opcode>7){this.controlMessage($,X);return}if(this._compressed){this._state=5,this.decompress($,X);return}if($.length)this._messageLength=this._totalPayloadLength,this._fragments.push($);this.dataMessage(X)}decompress(X,$){this._extensions[x3.extensionName].decompress(X,this._fin,(Z,K)=>{if(Z)return $(Z);if(K.length){if(this._messageLength+=K.length,this._messageLength>this._maxPayload&&this._maxPayload>0){let G=this.createError(RangeError,"Max payload size exceeded",!1,1009,"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");$(G);return}this._fragments.push(K)}if(this.dataMessage($),this._state===0)this.startLoop($)})}dataMessage(X){if(!this._fin){this._state=0;return}let $=this._messageLength,J=this._fragments;if(this._totalPayloadLength=0,this._messageLength=0,this._fragmented=0,this._fragments=[],this._opcode===2){let Z;if(this._binaryType==="nodebuffer")Z=H0(J,$);else if(this._binaryType==="arraybuffer")Z=PX(H0(J,$));else if(this._binaryType==="blob")Z=new Blob(J);else Z=J;if(this._allowSynchronousEvents)this.emit("message",Z,!0),this._state=0;else this._state=6,setImmediate(()=>{this.emit("message",Z,!0),this._state=0,this.startLoop(X)})}else{let Z=H0(J,$);if(!this._skipUTF8Validation&&!U3(Z)){let K=this.createError(Error,"invalid UTF-8 sequence",!0,1007,"WS_ERR_INVALID_UTF8");X(K);return}if(this._state===5||this._allowSynchronousEvents)this.emit("message",Z,!1),this._state=0;else this._state=6,setImmediate(()=>{this.emit("message",Z,!1),this._state=0,this.startLoop(X)})}}controlMessage(X,$){if(this._opcode===8){if(X.length===0)this._loop=!1,this.emit("conclude",1005,B3),this.end();else{let J=X.readUInt16BE(0);if(!qX(J)){let K=this.createError(RangeError,`invalid status code ${J}`,!0,1002,"WS_ERR_INVALID_CLOSE_CODE");$(K);return}let Z=new g2(X.buffer,X.byteOffset+2,X.length-2);if(!this._skipUTF8Validation&&!U3(Z)){let K=this.createError(Error,"invalid UTF-8 sequence",!0,1007,"WS_ERR_INVALID_UTF8");$(K);return}this._loop=!1,this.emit("conclude",J,Z),this.end()}this._state=0;return}if(this._allowSynchronousEvents)this.emit(this._opcode===9?"ping":"pong",X),this._state=0;else this._state=6,setImmediate(()=>{this.emit(this._opcode===9?"ping":"pong",X),this._state=0,this.startLoop($)})}createError(X,$,J,Z,K){this._loop=!1,this._errored=!0;let G=new X(J?`Invalid WebSocket frame: ${$}`:$);return Error.captureStackTrace(G,this.createError),G.code=K,G[LX]=Z,G}}j3.exports=W3});var U0=M((qZ,M3)=>{var{Duplex:EZ}=U("stream"),{randomFillSync:fX}=U("crypto"),F3=z2(),{EMPTY_BUFFER:CX,kWebSocket:wX,NOOP:hX}=s(),{isBlob:g1,isValidStatusCode:SX}=v1(),{mask:T3,toBuffer:H1}=G2(),g=Symbol("kByteLength"),vX=Buffer.alloc(4),x1,u1=8192,k=0,gX=1,uX=2;class K1{constructor(X,$,J){if(this._extensions=$||{},J)this._generateMask=J,this._maskBuffer=Buffer.alloc(4);this._socket=X,this._firstFragment=!0,this._compress=!1,this._bufferedBytes=0,this._queue=[],this._state=k,this.onerror=hX,this[wX]=void 0}static frame(X,$){let J,Z=!1,K=2,G=!1;if($.mask){if(J=$.maskBuffer||vX,$.generateMask)$.generateMask(J);else{if(u1===8192){if(x1===void 0)x1=Buffer.alloc(8192);fX(x1,0,8192),u1=0}J[0]=x1[u1++],J[1]=x1[u1++],J[2]=x1[u1++],J[3]=x1[u1++]}G=(J[0]|J[1]|J[2]|J[3])===0,K=6}let Y;if(typeof X==="string")if((!$.mask||G)&&$[g]!==void 0)Y=$[g];else X=Buffer.from(X),Y=X.length;else Y=X.length,Z=$.mask&&$.readOnly&&!G;let _=Y;if(Y>=65536)K+=8,_=127;else if(Y>125)K+=2,_=126;let z=Buffer.allocUnsafe(Z?Y+K:K);if(z[0]=$.fin?$.opcode|128:$.opcode,$.rsv1)z[0]|=64;if(z[1]=_,_===126)z.writeUInt16BE(Y,2);else if(_===127)z[2]=z[3]=0,z.writeUIntBE(Y,4,6);if(!$.mask)return[z,X];if(z[1]|=128,z[K-4]=J[0],z[K-3]=J[1],z[K-2]=J[2],z[K-1]=J[3],G)return[z,X];if(Z)return T3(X,J,z,K,Y),[z];return T3(X,J,X,0,Y),[z,X]}close(X,$,J,Z){let K;if(X===void 0)K=CX;else if(typeof X!=="number"||!SX(X))throw TypeError("First argument must be a valid error code number");else if($===void 0||!$.length)K=Buffer.allocUnsafe(2),K.writeUInt16BE(X,0);else{let Y=Buffer.byteLength($);if(Y>123)throw RangeError("The message must not be greater than 123 bytes");if(K=Buffer.allocUnsafe(2+Y),K.writeUInt16BE(X,0),typeof $==="string")K.write($,2);else K.set($,2)}let G={[g]:K.length,fin:!0,generateMask:this._generateMask,mask:J,maskBuffer:this._maskBuffer,opcode:8,readOnly:!1,rsv1:!1};if(this._state!==k)this.enqueue([this.dispatch,K,!1,G,Z]);else this.sendFrame(K1.frame(K,G),Z)}ping(X,$,J){let Z,K;if(typeof X==="string")Z=Buffer.byteLength(X),K=!1;else if(g1(X))Z=X.size,K=!1;else X=H1(X),Z=X.length,K=H1.readOnly;if(Z>125)throw RangeError("The data size must not be greater than 125 bytes");let G={[g]:Z,fin:!0,generateMask:this._generateMask,mask:$,maskBuffer:this._maskBuffer,opcode:9,readOnly:K,rsv1:!1};if(g1(X))if(this._state!==k)this.enqueue([this.getBlobData,X,!1,G,J]);else this.getBlobData(X,!1,G,J);else if(this._state!==k)this.enqueue([this.dispatch,X,!1,G,J]);else this.sendFrame(K1.frame(X,G),J)}pong(X,$,J){let Z,K;if(typeof X==="string")Z=Buffer.byteLength(X),K=!1;else if(g1(X))Z=X.size,K=!1;else X=H1(X),Z=X.length,K=H1.readOnly;if(Z>125)throw RangeError("The data size must not be greater than 125 bytes");let G={[g]:Z,fin:!0,generateMask:this._generateMask,mask:$,maskBuffer:this._maskBuffer,opcode:10,readOnly:K,rsv1:!1};if(g1(X))if(this._state!==k)this.enqueue([this.getBlobData,X,!1,G,J]);else this.getBlobData(X,!1,G,J);else if(this._state!==k)this.enqueue([this.dispatch,X,!1,G,J]);else this.sendFrame(K1.frame(X,G),J)}send(X,$,J){let Z=this._extensions[F3.extensionName],K=$.binary?2:1,G=$.compress,Y,_;if(typeof X==="string")Y=Buffer.byteLength(X),_=!1;else if(g1(X))Y=X.size,_=!1;else X=H1(X),Y=X.length,_=H1.readOnly;if(this._firstFragment){if(this._firstFragment=!1,G&&Z&&Z.params[Z._isServer?"server_no_context_takeover":"client_no_context_takeover"])G=Y>=Z._threshold;this._compress=G}else G=!1,K=0;if($.fin)this._firstFragment=!0;let z={[g]:Y,fin:$.fin,generateMask:this._generateMask,mask:$.mask,maskBuffer:this._maskBuffer,opcode:K,readOnly:_,rsv1:G};if(g1(X))if(this._state!==k)this.enqueue([this.getBlobData,X,this._compress,z,J]);else this.getBlobData(X,this._compress,z,J);else if(this._state!==k)this.enqueue([this.dispatch,X,this._compress,z,J]);else this.dispatch(X,this._compress,z,J)}getBlobData(X,$,J,Z){this._bufferedBytes+=J[g],this._state=uX,X.arrayBuffer().then((K)=>{if(this._socket.destroyed){let Y=Error("The socket was closed while the blob was being read");process.nextTick(B0,this,Y,Z);return}this._bufferedBytes-=J[g];let G=H1(K);if(!$)this._state=k,this.sendFrame(K1.frame(G,J),Z),this.dequeue();else this.dispatch(G,$,J,Z)}).catch((K)=>{process.nextTick(kX,this,K,Z)})}dispatch(X,$,J,Z){if(!$){this.sendFrame(K1.frame(X,J),Z);return}let K=this._extensions[F3.extensionName];this._bufferedBytes+=J[g],this._state=gX,K.compress(X,J.fin,(G,Y)=>{if(this._socket.destroyed){let _=Error("The socket was closed while data was being compressed");B0(this,_,Z);return}this._bufferedBytes-=J[g],this._state=k,J.readOnly=!1,this.sendFrame(K1.frame(Y,J),Z),this.dequeue()})}dequeue(){while(this._state===k&&this._queue.length){let X=this._queue.shift();this._bufferedBytes-=X[3][g],Reflect.apply(X[0],this,X.slice(1))}}enqueue(X){this._bufferedBytes+=X[3][g],this._queue.push(X)}sendFrame(X,$){if(X.length===2)this._socket.cork(),this._socket.write(X[0]),this._socket.write(X[1],$),this._socket.uncork();else this._socket.write(X[0],$)}}M3.exports=K1;function B0(X,$,J){if(typeof J==="function")J($);for(let Z=0;Z<X._queue.length;Z++){let K=X._queue[Z],G=K[K.length-1];if(typeof G==="function")G($)}}function kX(X,$,J){B0(X,$,J),X.onerror($)}});var h3=M((fZ,w3)=>{var{kForOnEventAttribute:_2,kListener:W0}=s(),L3=Symbol("kCode"),y3=Symbol("kData"),P3=Symbol("kError"),E3=Symbol("kMessage"),q3=Symbol("kReason"),k1=Symbol("kTarget"),f3=Symbol("kType"),C3=Symbol("kWasClean");class G1{constructor(X){this[k1]=null,this[f3]=X}get target(){return this[k1]}get type(){return this[f3]}}Object.defineProperty(G1.prototype,"target",{enumerable:!0});Object.defineProperty(G1.prototype,"type",{enumerable:!0});class p1 extends G1{constructor(X,$={}){super(X);this[L3]=$.code===void 0?0:$.code,this[q3]=$.reason===void 0?"":$.reason,this[C3]=$.wasClean===void 0?!1:$.wasClean}get code(){return this[L3]}get reason(){return this[q3]}get wasClean(){return this[C3]}}Object.defineProperty(p1.prototype,"code",{enumerable:!0});Object.defineProperty(p1.prototype,"reason",{enumerable:!0});Object.defineProperty(p1.prototype,"wasClean",{enumerable:!0});class R2 extends G1{constructor(X,$={}){super(X);this[P3]=$.error===void 0?null:$.error,this[E3]=$.message===void 0?"":$.message}get error(){return this[P3]}get message(){return this[E3]}}Object.defineProperty(R2.prototype,"error",{enumerable:!0});Object.defineProperty(R2.prototype,"message",{enumerable:!0});class k2 extends G1{constructor(X,$={}){super(X);this[y3]=$.data===void 0?null:$.data}get data(){return this[y3]}}Object.defineProperty(k2.prototype,"data",{enumerable:!0});var pX={addEventListener(X,$,J={}){for(let K of this.listeners(X))if(!J[_2]&&K[W0]===$&&!K[_2])return;let Z;if(X==="message")Z=function(G,Y){let _=new k2("message",{data:Y?G:G.toString()});_[k1]=this,u2($,this,_)};else if(X==="close")Z=function(G,Y){let _=new p1("close",{code:G,reason:Y.toString(),wasClean:this._closeFrameReceived&&this._closeFrameSent});_[k1]=this,u2($,this,_)};else if(X==="error")Z=function(G){let Y=new R2("error",{error:G,message:G.message});Y[k1]=this,u2($,this,Y)};else if(X==="open")Z=function(){let G=new G1("open");G[k1]=this,u2($,this,G)};else return;if(Z[_2]=!!J[_2],Z[W0]=$,J.once)this.once(X,Z);else this.on(X,Z)},removeEventListener(X,$){for(let J of this.listeners(X))if(J[W0]===$&&!J[_2]){this.removeListener(X,J);break}}};w3.exports={CloseEvent:p1,ErrorEvent:R2,Event:G1,EventTarget:pX,MessageEvent:k2};function u2(X,$,J){if(typeof X==="object"&&X.handleEvent)X.handleEvent.call(X,J);else X.call($,J)}});var j0=M((CZ,S3)=>{var{tokenChars:N2}=v1();function l(X,$,J){if(X[$]===void 0)X[$]=[J];else X[$].push(J)}function bX(X){let $=Object.create(null),J=Object.create(null),Z=!1,K=!1,G=!1,Y,_,z=-1,R=-1,N=-1,A=0;for(;A<X.length;A++)if(R=X.charCodeAt(A),Y===void 0)if(N===-1&&N2[R]===1){if(z===-1)z=A}else if(A!==0&&(R===32||R===9)){if(N===-1&&z!==-1)N=A}else if(R===59||R===44){if(z===-1)throw SyntaxError(`Unexpected character at index ${A}`);if(N===-1)N=A;let j=X.slice(z,N);if(R===44)l($,j,J),J=Object.create(null);else Y=j;z=N=-1}else throw SyntaxError(`Unexpected character at index ${A}`);else if(_===void 0)if(N===-1&&N2[R]===1){if(z===-1)z=A}else if(R===32||R===9){if(N===-1&&z!==-1)N=A}else if(R===59||R===44){if(z===-1)throw SyntaxError(`Unexpected character at index ${A}`);if(N===-1)N=A;if(l(J,X.slice(z,N),!0),R===44)l($,Y,J),J=Object.create(null),Y=void 0;z=N=-1}else if(R===61&&z!==-1&&N===-1)_=X.slice(z,A),z=N=-1;else throw SyntaxError(`Unexpected character at index ${A}`);else if(K){if(N2[R]!==1)throw SyntaxError(`Unexpected character at index ${A}`);if(z===-1)z=A;else if(!Z)Z=!0;K=!1}else if(G)if(N2[R]===1){if(z===-1)z=A}else if(R===34&&z!==-1)G=!1,N=A;else if(R===92)K=!0;else throw SyntaxError(`Unexpected character at index ${A}`);else if(R===34&&X.charCodeAt(A-1)===61)G=!0;else if(N===-1&&N2[R]===1){if(z===-1)z=A}else if(z!==-1&&(R===32||R===9)){if(N===-1)N=A}else if(R===59||R===44){if(z===-1)throw SyntaxError(`Unexpected character at index ${A}`);if(N===-1)N=A;let j=X.slice(z,N);if(Z)j=j.replace(/\\/g,""),Z=!1;if(l(J,_,j),R===44)l($,Y,J),J=Object.create(null),Y=void 0;_=void 0,z=N=-1}else throw SyntaxError(`Unexpected character at index ${A}`);if(z===-1||G||R===32||R===9)throw SyntaxError("Unexpected end of input");if(N===-1)N=A;let B=X.slice(z,N);if(Y===void 0)l($,B,J);else{if(_===void 0)l(J,B,!0);else if(Z)l(J,_,B.replace(/\\/g,""));else l(J,_,B);l($,Y,J)}return $}function iX(X){return Object.keys(X).map(($)=>{let J=X[$];if(!Array.isArray(J))J=[J];return J.map((Z)=>{return[$].concat(Object.keys(Z).map((K)=>{let G=Z[K];if(!Array.isArray(G))G=[G];return G.map((Y)=>Y===!0?K:`${K}=${Y}`).join("; ")})).join("; ")}).join(", ")}).join(", ")}S3.exports={format:iX,parse:bX}});var m2=M((SZ,c3)=>{var mX=U("events"),dX=U("https"),lX=U("http"),u3=U("net"),nX=U("tls"),{randomBytes:cX,createHash:sX}=U("crypto"),{Duplex:wZ,Readable:hZ}=U("stream"),{URL:F0}=U("url"),Y1=z2(),rX=x0(),aX=U0(),{isBlob:tX}=v1(),{BINARY_TYPES:v3,EMPTY_BUFFER:p2,GUID:oX,kForOnEventAttribute:T0,kListener:eX,kStatusCode:X$,kWebSocket:E,NOOP:k3}=s(),{EventTarget:{addEventListener:$$,removeEventListener:J$}}=h3(),{format:Z$,parse:K$}=j0(),{toBuffer:G$}=G2(),p3=Symbol("kAborted"),M0=[8,13],a=["CONNECTING","OPEN","CLOSING","CLOSED"],Y$=/^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;class O extends mX{constructor(X,$,J){super();if(this._binaryType=v3[0],this._closeCode=1006,this._closeFrameReceived=!1,this._closeFrameSent=!1,this._closeMessage=p2,this._closeTimer=null,this._errorEmitted=!1,this._extensions={},this._paused=!1,this._protocol="",this._readyState=O.CONNECTING,this._receiver=null,this._sender=null,this._socket=null,X!==null){if(this._bufferedAmount=0,this._isServer=!1,this._redirects=0,$===void 0)$=[];else if(!Array.isArray($))if(typeof $==="object"&&$!==null)J=$,$=[];else $=[$];b3(this,X,$,J)}else this._autoPong=J.autoPong,this._isServer=!0}get binaryType(){return this._binaryType}set binaryType(X){if(!v3.includes(X))return;if(this._binaryType=X,this._receiver)this._receiver._binaryType=X}get bufferedAmount(){if(!this._socket)return this._bufferedAmount;return this._socket._writableState.length+this._sender._bufferedBytes}get extensions(){return Object.keys(this._extensions).join()}get isPaused(){return this._paused}get onclose(){return null}get onerror(){return null}get onopen(){return null}get onmessage(){return null}get protocol(){return this._protocol}get readyState(){return this._readyState}get url(){return this._url}setSocket(X,$,J){let Z=new rX({allowSynchronousEvents:J.allowSynchronousEvents,binaryType:this.binaryType,extensions:this._extensions,isServer:this._isServer,maxPayload:J.maxPayload,skipUTF8Validation:J.skipUTF8Validation}),K=new aX(X,this._extensions,J.generateMask);if(this._receiver=Z,this._sender=K,this._socket=X,Z[E]=this,K[E]=this,X[E]=this,Z.on("conclude",R$),Z.on("drain",N$),Z.on("error",A$),Z.on("message",Q$),Z.on("ping",I$),Z.on("pong",V$),K.onerror=O$,X.setTimeout)X.setTimeout(0);if(X.setNoDelay)X.setNoDelay();if($.length>0)X.unshift($);X.on("close",d3),X.on("data",i2),X.on("end",l3),X.on("error",n3),this._readyState=O.OPEN,this.emit("open")}emitClose(){if(!this._socket){this._readyState=O.CLOSED,this.emit("close",this._closeCode,this._closeMessage);return}if(this._extensions[Y1.extensionName])this._extensions[Y1.extensionName].cleanup();this._receiver.removeAllListeners(),this._readyState=O.CLOSED,this.emit("close",this._closeCode,this._closeMessage)}close(X,$){if(this.readyState===O.CLOSED)return;if(this.readyState===O.CONNECTING){w(this,this._req,"WebSocket was closed before the connection was established");return}if(this.readyState===O.CLOSING){if(this._closeFrameSent&&(this._closeFrameReceived||this._receiver._writableState.errorEmitted))this._socket.end();return}this._readyState=O.CLOSING,this._sender.close(X,$,!this._isServer,(J)=>{if(J)return;if(this._closeFrameSent=!0,this._closeFrameReceived||this._receiver._writableState.errorEmitted)this._socket.end()}),m3(this)}pause(){if(this.readyState===O.CONNECTING||this.readyState===O.CLOSED)return;this._paused=!0,this._socket.pause()}ping(X,$,J){if(this.readyState===O.CONNECTING)throw Error("WebSocket is not open: readyState 0 (CONNECTING)");if(typeof X==="function")J=X,X=$=void 0;else if(typeof $==="function")J=$,$=void 0;if(typeof X==="number")X=X.toString();if(this.readyState!==O.OPEN){L0(this,X,J);return}if($===void 0)$=!this._isServer;this._sender.ping(X||p2,$,J)}pong(X,$,J){if(this.readyState===O.CONNECTING)throw Error("WebSocket is not open: readyState 0 (CONNECTING)");if(typeof X==="function")J=X,X=$=void 0;else if(typeof $==="function")J=$,$=void 0;if(typeof X==="number")X=X.toString();if(this.readyState!==O.OPEN){L0(this,X,J);return}if($===void 0)$=!this._isServer;this._sender.pong(X||p2,$,J)}resume(){if(this.readyState===O.CONNECTING||this.readyState===O.CLOSED)return;if(this._paused=!1,!this._receiver._writableState.needDrain)this._socket.resume()}send(X,$,J){if(this.readyState===O.CONNECTING)throw Error("WebSocket is not open: readyState 0 (CONNECTING)");if(typeof $==="function")J=$,$={};if(typeof X==="number")X=X.toString();if(this.readyState!==O.OPEN){L0(this,X,J);return}let Z={binary:typeof X!=="string",mask:!this._isServer,compress:!0,fin:!0,...$};if(!this._extensions[Y1.extensionName])Z.compress=!1;this._sender.send(X||p2,Z,J)}terminate(){if(this.readyState===O.CLOSED)return;if(this.readyState===O.CONNECTING){w(this,this._req,"WebSocket was closed before the connection was established");return}if(this._socket)this._readyState=O.CLOSING,this._socket.destroy()}}Object.defineProperty(O,"CONNECTING",{enumerable:!0,value:a.indexOf("CONNECTING")});Object.defineProperty(O.prototype,"CONNECTING",{enumerable:!0,value:a.indexOf("CONNECTING")});Object.defineProperty(O,"OPEN",{enumerable:!0,value:a.indexOf("OPEN")});Object.defineProperty(O.prototype,"OPEN",{enumerable:!0,value:a.indexOf("OPEN")});Object.defineProperty(O,"CLOSING",{enumerable:!0,value:a.indexOf("CLOSING")});Object.defineProperty(O.prototype,"CLOSING",{enumerable:!0,value:a.indexOf("CLOSING")});Object.defineProperty(O,"CLOSED",{enumerable:!0,value:a.indexOf("CLOSED")});Object.defineProperty(O.prototype,"CLOSED",{enumerable:!0,value:a.indexOf("CLOSED")});["binaryType","bufferedAmount","extensions","isPaused","protocol","readyState","url"].forEach((X)=>{Object.defineProperty(O.prototype,X,{enumerable:!0})});["open","error","close","message"].forEach((X)=>{Object.defineProperty(O.prototype,`on${X}`,{enumerable:!0,get(){for(let $ of this.listeners(X))if($[T0])return $[eX];return null},set($){for(let J of this.listeners(X))if(J[T0]){this.removeListener(X,J);break}if(typeof $!=="function")return;this.addEventListener(X,$,{[T0]:!0})}})});O.prototype.addEventListener=$$;O.prototype.removeEventListener=J$;c3.exports=O;function b3(X,$,J,Z){let K={allowSynchronousEvents:!0,autoPong:!0,protocolVersion:M0[1],maxPayload:104857600,skipUTF8Validation:!1,perMessageDeflate:!0,followRedirects:!1,maxRedirects:10,...Z,socketPath:void 0,hostname:void 0,protocol:void 0,timeout:void 0,method:"GET",host:void 0,path:void 0,port:void 0};if(X._autoPong=K.autoPong,!M0.includes(K.protocolVersion))throw RangeError(`Unsupported protocol version: ${K.protocolVersion} (supported versions: ${M0.join(", ")})`);let G;if($ instanceof F0)G=$;else try{G=new F0($)}catch(I){throw SyntaxError(`Invalid URL: ${$}`)}if(G.protocol==="http:")G.protocol="ws:";else if(G.protocol==="https:")G.protocol="wss:";X._url=G.href;let Y=G.protocol==="wss:",_=G.protocol==="ws+unix:",z;if(G.protocol!=="ws:"&&!Y&&!_)z=`The URL's protocol must be one of "ws:", "wss:", "http:", "https:", or "ws+unix:"`;else if(_&&!G.pathname)z="The URL's pathname is empty";else if(G.hash)z="The URL contains a fragment identifier";if(z){let I=SyntaxError(z);if(X._redirects===0)throw I;else{b2(X,I);return}}let R=Y?443:80,N=cX(16).toString("base64"),A=Y?dX.request:lX.request,B=new Set,j;if(K.createConnection=K.createConnection||(Y?_$:z$),K.defaultPort=K.defaultPort||R,K.port=G.port||R,K.host=G.hostname.startsWith("[")?G.hostname.slice(1,-1):G.hostname,K.headers={...K.headers,"Sec-WebSocket-Version":K.protocolVersion,"Sec-WebSocket-Key":N,Connection:"Upgrade",Upgrade:"websocket"},K.path=G.pathname+G.search,K.timeout=K.handshakeTimeout,K.perMessageDeflate)j=new Y1(K.perMessageDeflate!==!0?K.perMessageDeflate:{},!1,K.maxPayload),K.headers["Sec-WebSocket-Extensions"]=Z$({[Y1.extensionName]:j.offer()});if(J.length){for(let I of J){if(typeof I!=="string"||!Y$.test(I)||B.has(I))throw SyntaxError("An invalid or duplicated subprotocol was specified");B.add(I)}K.headers["Sec-WebSocket-Protocol"]=J.join(",")}if(K.origin)if(K.protocolVersion<13)K.headers["Sec-WebSocket-Origin"]=K.origin;else K.headers.Origin=K.origin;if(G.username||G.password)K.auth=`${G.username}:${G.password}`;if(_){let I=K.path.split(":");K.socketPath=I[0],K.path=I[1]}let D;if(K.followRedirects){if(X._redirects===0){X._originalIpc=_,X._originalSecure=Y,X._originalHostOrSocketPath=_?K.socketPath:G.host;let I=Z&&Z.headers;if(Z={...Z,headers:{}},I)for(let[W,S]of Object.entries(I))Z.headers[W.toLowerCase()]=S}else if(X.listenerCount("redirect")===0){let I=_?X._originalIpc?K.socketPath===X._originalHostOrSocketPath:!1:X._originalIpc?!1:G.host===X._originalHostOrSocketPath;if(!I||X._originalSecure&&!Y){if(delete K.headers.authorization,delete K.headers.cookie,!I)delete K.headers.host;K.auth=void 0}}if(K.auth&&!Z.headers.authorization)Z.headers.authorization="Basic "+Buffer.from(K.auth).toString("base64");if(D=X._req=A(K),X._redirects)X.emit("redirect",X.url,D)}else D=X._req=A(K);if(K.timeout)D.on("timeout",()=>{w(X,D,"Opening handshake has timed out")});if(D.on("error",(I)=>{if(D===null||D[p3])return;D=X._req=null,b2(X,I)}),D.on("response",(I)=>{let W=I.headers.location,S=I.statusCode;if(W&&K.followRedirects&&S>=300&&S<400){if(++X._redirects>K.maxRedirects){w(X,D,"Maximum redirects exceeded");return}D.abort();let I1;try{I1=new F0(W,$)}catch(d0){let y1=SyntaxError(`Invalid URL: ${W}`);b2(X,y1);return}b3(X,I1,J,Z)}else if(!X.emit("unexpected-response",D,I))w(X,D,`Unexpected server response: ${I.statusCode}`)}),D.on("upgrade",(I,W,S)=>{if(X.emit("upgrade",I),X.readyState!==O.CONNECTING)return;D=X._req=null;let I1=I.headers.upgrade;if(I1===void 0||I1.toLowerCase()!=="websocket"){w(X,W,"Invalid Upgrade header");return}let d0=sX("sha1").update(N+oX).digest("base64");if(I.headers["sec-websocket-accept"]!==d0){w(X,W,"Invalid Sec-WebSocket-Accept header");return}let y1=I.headers["sec-websocket-protocol"],X2;if(y1!==void 0){if(!B.size)X2="Server sent a subprotocol but none was requested";else if(!B.has(y1))X2="Server sent an invalid subprotocol"}else if(B.size)X2="Server sent no subprotocol";if(X2){w(X,W,X2);return}if(y1)X._protocol=y1;let l0=I.headers["sec-websocket-extensions"];if(l0!==void 0){if(!j){w(X,W,"Server sent a Sec-WebSocket-Extensions header but no extension was requested");return}let G0;try{G0=K$(l0)}catch(Y0){w(X,W,"Invalid Sec-WebSocket-Extensions header");return}let n0=Object.keys(G0);if(n0.length!==1||n0[0]!==Y1.extensionName){w(X,W,"Server indicated an extension that was not requested");return}try{j.accept(G0[Y1.extensionName])}catch(Y0){w(X,W,"Invalid Sec-WebSocket-Extensions header");return}X._extensions[Y1.extensionName]=j}X.setSocket(W,S,{allowSynchronousEvents:K.allowSynchronousEvents,generateMask:K.generateMask,maxPayload:K.maxPayload,skipUTF8Validation:K.skipUTF8Validation})}),K.finishRequest)K.finishRequest(D,X);else D.end()}function b2(X,$){X._readyState=O.CLOSING,X._errorEmitted=!0,X.emit("error",$),X.emitClose()}function z$(X){return X.path=X.socketPath,u3.connect(X)}function _$(X){if(X.path=void 0,!X.servername&&X.servername!=="")X.servername=u3.isIP(X.host)?"":X.host;return nX.connect(X)}function w(X,$,J){X._readyState=O.CLOSING;let Z=Error(J);if(Error.captureStackTrace(Z,w),$.setHeader){if($[p3]=!0,$.abort(),$.socket&&!$.socket.destroyed)$.socket.destroy();process.nextTick(b2,X,Z)}else $.destroy(Z),$.once("error",X.emit.bind(X,"error")),$.once("close",X.emitClose.bind(X))}function L0(X,$,J){if($){let Z=tX($)?$.size:G$($).length;if(X._socket)X._sender._bufferedBytes+=Z;else X._bufferedAmount+=Z}if(J){let Z=Error(`WebSocket is not open: readyState ${X.readyState} (${a[X.readyState]})`);process.nextTick(J,Z)}}function R$(X,$){let J=this[E];if(J._closeFrameReceived=!0,J._closeMessage=$,J._closeCode=X,J._socket[E]===void 0)return;if(J._socket.removeListener("data",i2),process.nextTick(i3,J._socket),X===1005)J.close();else J.close(X,$)}function N$(){let X=this[E];if(!X.isPaused)X._socket.resume()}function A$(X){let $=this[E];if($._socket[E]!==void 0)$._socket.removeListener("data",i2),process.nextTick(i3,$._socket),$.close(X[X$]);if(!$._errorEmitted)$._errorEmitted=!0,$.emit("error",X)}function g3(){this[E].emitClose()}function Q$(X,$){this[E].emit("message",X,$)}function I$(X){let $=this[E];if($._autoPong)$.pong(X,!this._isServer,k3);$.emit("ping",X)}function V$(X){this[E].emit("pong",X)}function i3(X){X.resume()}function O$(X){let $=this[E];if($.readyState===O.CLOSED)return;if($.readyState===O.OPEN)$._readyState=O.CLOSING,m3($);if(this._socket.end(),!$._errorEmitted)$._errorEmitted=!0,$.emit("error",X)}function m3(X){X._closeTimer=setTimeout(X._socket.destroy.bind(X._socket),30000)}function d3(){let X=this[E];this.removeListener("close",d3),this.removeListener("data",i2),this.removeListener("end",l3),X._readyState=O.CLOSING;let $;if(!this._readableState.endEmitted&&!X._closeFrameReceived&&!X._receiver._writableState.errorEmitted&&($=X._socket.read())!==null)X._receiver.write($);if(X._receiver.end(),this[E]=void 0,clearTimeout(X._closeTimer),X._receiver._writableState.finished||X._receiver._writableState.errorEmitted)X.emitClose();else X._receiver.on("error",g3),X._receiver.on("finish",g3)}function i2(X){if(!this[E]._receiver.write(X))this.pause()}function l3(){let X=this[E];X._readyState=O.CLOSING,X._receiver.end(),this.end()}function n3(){let X=this[E];if(this.removeListener("error",n3),this.on("error",k3),X)X._readyState=O.CLOSING,this.destroy()}});var t3=M((gZ,a3)=>{var vZ=m2(),{Duplex:D$}=U("stream");function s3(X){X.emit("close")}function H$(){if(!this.destroyed&&this._writableState.finished)this.destroy()}function r3(X){if(this.removeListener("error",r3),this.destroy(),this.listenerCount("error")===0)this.emit("error",X)}function x$(X,$){let J=!0,Z=new D$({...$,autoDestroy:!1,emitClose:!1,objectMode:!1,writableObjectMode:!1});return X.on("message",function(G,Y){let _=!Y&&Z._readableState.objectMode?G.toString():G;if(!Z.push(_))X.pause()}),X.once("error",function(G){if(Z.destroyed)return;J=!1,Z.destroy(G)}),X.once("close",function(){if(Z.destroyed)return;Z.push(null)}),Z._destroy=function(K,G){if(X.readyState===X.CLOSED){G(K),process.nextTick(s3,Z);return}let Y=!1;if(X.once("error",function(z){Y=!0,G(z)}),X.once("close",function(){if(!Y)G(K);process.nextTick(s3,Z)}),J)X.terminate()},Z._final=function(K){if(X.readyState===X.CONNECTING){X.once("open",function(){Z._final(K)});return}if(X._socket===null)return;if(X._socket._writableState.finished){if(K(),Z._readableState.endEmitted)Z.destroy()}else X._socket.once("finish",function(){K()}),X.close()},Z._read=function(){if(X.isPaused)X.resume()},Z._write=function(K,G,Y){if(X.readyState===X.CONNECTING){X.once("open",function(){Z._write(K,G,Y)});return}X.send(K,Y)},Z.on("end",H$),Z.on("error",r3),Z}a3.exports=x$});var e3=M((uZ,o3)=>{var{tokenChars:B$}=v1();function U$(X){let $=new Set,J=-1,Z=-1,K=0;for(K;K<X.length;K++){let Y=X.charCodeAt(K);if(Z===-1&&B$[Y]===1){if(J===-1)J=K}else if(K!==0&&(Y===32||Y===9)){if(Z===-1&&J!==-1)Z=K}else if(Y===44){if(J===-1)throw SyntaxError(`Unexpected character at index ${K}`);if(Z===-1)Z=K;let _=X.slice(J,Z);if($.has(_))throw SyntaxError(`The "${_}" subprotocol is duplicated`);$.add(_),J=Z=-1}else throw SyntaxError(`Unexpected character at index ${K}`)}if(J===-1||Z!==-1)throw SyntaxError("Unexpected end of input");let G=X.slice(J,K);if($.has(G))throw SyntaxError(`The "${G}" subprotocol is duplicated`);return $.add(G),$}o3.exports={parse:U$}});var K4=M((pZ,Z4)=>{var W$=U("events"),d2=U("http"),{Duplex:kZ}=U("stream"),{createHash:j$}=U("crypto"),X4=j0(),B1=z2(),F$=e3(),T$=m2(),{GUID:M$,kWebSocket:L$}=s(),y$=/^[+/0-9A-Za-z]{22}==$/;class J4 extends W${constructor(X,$){super();if(X={allowSynchronousEvents:!0,autoPong:!0,maxPayload:104857600,skipUTF8Validation:!1,perMessageDeflate:!1,handleProtocols:null,clientTracking:!0,verifyClient:null,noServer:!1,backlog:null,server:null,host:null,path:null,port:null,WebSocket:T$,...X},X.port==null&&!X.server&&!X.noServer||X.port!=null&&(X.server||X.noServer)||X.server&&X.noServer)throw TypeError('One and only one of the "port", "server", or "noServer" options must be specified');if(X.port!=null)this._server=d2.createServer((J,Z)=>{let K=d2.STATUS_CODES[426];Z.writeHead(426,{"Content-Length":K.length,"Content-Type":"text/plain"}),Z.end(K)}),this._server.listen(X.port,X.host,X.backlog,$);else if(X.server)this._server=X.server;if(this._server){let J=this.emit.bind(this,"connection");this._removeListeners=P$(this._server,{listening:this.emit.bind(this,"listening"),error:this.emit.bind(this,"error"),upgrade:(Z,K,G)=>{this.handleUpgrade(Z,K,G,J)}})}if(X.perMessageDeflate===!0)X.perMessageDeflate={};if(X.clientTracking)this.clients=new Set,this._shouldEmitClose=!1;this.options=X,this._state=0}address(){if(this.options.noServer)throw Error('The server is operating in "noServer" mode');if(!this._server)return null;return this._server.address()}close(X){if(this._state===2){if(X)this.once("close",()=>{X(Error("The server is not running"))});process.nextTick(A2,this);return}if(X)this.once("close",X);if(this._state===1)return;if(this._state=1,this.options.noServer||this.options.server){if(this._server)this._removeListeners(),this._removeListeners=this._server=null;if(this.clients)if(!this.clients.size)process.nextTick(A2,this);else this._shouldEmitClose=!0;else process.nextTick(A2,this)}else{let $=this._server;this._removeListeners(),this._removeListeners=this._server=null,$.close(()=>{A2(this)})}}shouldHandle(X){if(this.options.path){let $=X.url.indexOf("?");if(($!==-1?X.url.slice(0,$):X.url)!==this.options.path)return!1}return!0}handleUpgrade(X,$,J,Z){$.on("error",$4);let K=X.headers["sec-websocket-key"],G=X.headers.upgrade,Y=+X.headers["sec-websocket-version"];if(X.method!=="GET"){U1(this,X,$,405,"Invalid HTTP method");return}if(G===void 0||G.toLowerCase()!=="websocket"){U1(this,X,$,400,"Invalid Upgrade header");return}if(K===void 0||!y$.test(K)){U1(this,X,$,400,"Missing or invalid Sec-WebSocket-Key header");return}if(Y!==13&&Y!==8){U1(this,X,$,400,"Missing or invalid Sec-WebSocket-Version header",{"Sec-WebSocket-Version":"13, 8"});return}if(!this.shouldHandle(X)){Q2($,400);return}let _=X.headers["sec-websocket-protocol"],z=new Set;if(_!==void 0)try{z=F$.parse(_)}catch(A){U1(this,X,$,400,"Invalid Sec-WebSocket-Protocol header");return}let R=X.headers["sec-websocket-extensions"],N={};if(this.options.perMessageDeflate&&R!==void 0){let A=new B1(this.options.perMessageDeflate,!0,this.options.maxPayload);try{let B=X4.parse(R);if(B[B1.extensionName])A.accept(B[B1.extensionName]),N[B1.extensionName]=A}catch(B){U1(this,X,$,400,"Invalid or unacceptable Sec-WebSocket-Extensions header");return}}if(this.options.verifyClient){let A={origin:X.headers[`${Y===8?"sec-websocket-origin":"origin"}`],secure:!!(X.socket.authorized||X.socket.encrypted),req:X};if(this.options.verifyClient.length===2){this.options.verifyClient(A,(B,j,D,I)=>{if(!B)return Q2($,j||401,D,I);this.completeUpgrade(N,K,z,X,$,J,Z)});return}if(!this.options.verifyClient(A))return Q2($,401)}this.completeUpgrade(N,K,z,X,$,J,Z)}completeUpgrade(X,$,J,Z,K,G,Y){if(!K.readable||!K.writable)return K.destroy();if(K[L$])throw Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");if(this._state>0)return Q2(K,503);let z=["HTTP/1.1 101 Switching Protocols","Upgrade: websocket","Connection: Upgrade",`Sec-WebSocket-Accept: ${j$("sha1").update($+M$).digest("base64")}`],R=new this.options.WebSocket(null,void 0,this.options);if(J.size){let N=this.options.handleProtocols?this.options.handleProtocols(J,Z):J.values().next().value;if(N)z.push(`Sec-WebSocket-Protocol: ${N}`),R._protocol=N}if(X[B1.extensionName]){let N=X[B1.extensionName].params,A=X4.format({[B1.extensionName]:[N]});z.push(`Sec-WebSocket-Extensions: ${A}`),R._extensions=X}if(this.emit("headers",z,Z),K.write(z.concat(`\r
`).join(`\r
`)),K.removeListener("error",$4),R.setSocket(K,G,{allowSynchronousEvents:this.options.allowSynchronousEvents,maxPayload:this.options.maxPayload,skipUTF8Validation:this.options.skipUTF8Validation}),this.clients)this.clients.add(R),R.on("close",()=>{if(this.clients.delete(R),this._shouldEmitClose&&!this.clients.size)process.nextTick(A2,this)});Y(R,Z)}}Z4.exports=J4;function P$(X,$){for(let J of Object.keys($))X.on(J,$[J]);return function(){for(let Z of Object.keys($))X.removeListener(Z,$[Z])}}function A2(X){X._state=2,X.emit("close")}function $4(){this.destroy()}function Q2(X,$,J,Z){J=J||d2.STATUS_CODES[$],Z={Connection:"close","Content-Type":"text/html","Content-Length":Buffer.byteLength(J),...Z},X.once("finish",X.destroy),X.end(`HTTP/1.1 ${$} ${d2.STATUS_CODES[$]}\r
`+Object.keys(Z).map((K)=>`${K}: ${Z[K]}`).join(`\r
`)+`\r
\r
`+J)}function U1(X,$,J,Z,K,G){if(X.listenerCount("wsClientError")){let Y=Error(K);Error.captureStackTrace(Y,U1),X.emit("wsClientError",Y,J,$)}else Q2(J,Z,K,G)}});var i0=M((kG,g4)=>{function cJ(X){var $=0,J=[];function Z(){if($--,$<X)K()}function K(){var z=J.shift();if(_.queue=J.length,z)Y(z.fn).then(z.resolve).catch(z.reject)}function G(z){return new Promise(function(R,N){J.push({fn:z,resolve:R,reject:N}),_.queue=J.length})}function Y(z){$++;try{return Promise.resolve(z()).then(function(R){return Z(),R},function(R){throw Z(),R})}catch(R){return Z(),Promise.reject(R)}}var _=function(z){if($>=X)return G(z);else return Y(z)};return _}function sJ(X,$){var J=!1,Z=this;return Promise.all(X.map(function(){var K=arguments;return Z(function(){if(!J)return $.apply(void 0,K).catch(function(G){throw J=!0,G})})}))}function v4(X){return X.queue=0,X.map=sJ,X}g4.exports=function(X){if(X)return v4(cJ(X));else return v4(function($){return $()})}});import*as K0 from"node:fs";import*as m0 from"node:path";class V extends Error{code;rawCode;constructor(X,$,J,Z){if($!==void 0)X=`${$}: ${X}`;super(X,{cause:Z});this.code=$,this.rawCode=J,this.name="LibsqlError"}}function c0(X){let $=a4.exec(X);if($===null)throw new V(`The URL '${X}' is not in a valid format`,"URL_INVALID");let J=$.groups,Z=J.scheme,K=J.authority!==void 0?t4(J.authority):void 0,G=V1(J.path),Y=J.query!==void 0?e4(J.query):void 0,_=J.fragment!==void 0?V1(J.fragment):void 0;return{scheme:Z,authority:K,path:G,query:Y,fragment:_}}var a4=(()=>{return new RegExp("^(?<scheme>[A-Za-z][A-Za-z.+-]*):(//(?<authority>[^/?#]*))?(?<path>[^?#]*)(\\?(?<query>[^#]*))?(#(?<fragment>.*))?$","su")})();function t4(X){let $=o4.exec(X);if($===null)throw new V("The authority part of the URL is not in a valid format","URL_INVALID");let J=$.groups,Z=V1(J.host_br??J.host),K=J.port?parseInt(J.port,10):void 0,G=J.username!==void 0?{username:V1(J.username),password:J.password!==void 0?V1(J.password):void 0}:void 0;return{host:Z,port:K,userinfo:G}}var o4=(()=>{return new RegExp("^((?<username>[^:]*)(:(?<password>.*))?@)?((?<host>[^:\\[\\]]*)|(\\[(?<host_br>[^\\[\\]]*)\\]))(:(?<port>[0-9]*))?$","su")})();function e4(X){let $=X.split("&"),J=[];for(let Z of $){if(Z==="")continue;let K,G,Y=Z.indexOf("=");if(Y<0)K=Z,G="";else K=Z.substring(0,Y),G=Z.substring(Y+1);J.push({key:V1(K.replaceAll("+"," ")),value:V1(G.replaceAll("+"," "))})}return{pairs:J}}function V1(X){try{return decodeURIComponent(X)}catch($){if($ instanceof URIError)throw new V(`URL component has invalid percent encoding: ${$}`,"URL_INVALID",void 0,$);throw $}}function $2(X,$,J){if($===void 0)throw new V(`URL with scheme ${JSON.stringify(X+":")} requires authority (the "//" part)`,"URL_INVALID");let Z=`${X}:`,K=X8($.host),G=$8($.port),_=`//${J8($.userinfo)}${K}${G}`,z=J.split("/").map(encodeURIComponent).join("/");if(z!==""&&!z.startsWith("/"))z="/"+z;return new URL(`${Z}${_}${z}`)}function X8(X){return X.includes(":")?`[${encodeURI(X)}]`:encodeURI(X)}function $8(X){return X!==void 0?`:${X}`:""}function J8(X){if(X===void 0)return"";let $=encodeURIComponent(X.username),J=X.password!==void 0?`:${encodeURIComponent(X.password)}`:"";return`${$}${J}@`}var E1=typeof Buffer==="function",s0=typeof TextDecoder==="function"?new TextDecoder:void 0,r0=typeof TextEncoder==="function"?new TextEncoder:void 0;var J2=Array.prototype.slice.call("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="),E2=((X)=>{let $={};return X.forEach((J,Z)=>$[J]=Z),$})(J2),Z8=/^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/,q=String.fromCharCode.bind(String),a0=typeof Uint8Array.from==="function"?Uint8Array.from.bind(Uint8Array):(X)=>new Uint8Array(Array.prototype.slice.call(X,0)),e0=(X)=>X.replace(/=/g,"").replace(/[+\/]/g,($)=>$=="+"?"-":"_"),X6=(X)=>X.replace(/[^A-Za-z0-9\+\/]/g,""),$6=(X)=>{let $,J,Z,K,G="",Y=X.length%3;for(let _=0;_<X.length;){if((J=X.charCodeAt(_++))>255||(Z=X.charCodeAt(_++))>255||(K=X.charCodeAt(_++))>255)throw TypeError("invalid character found");$=J<<16|Z<<8|K,G+=J2[$>>18&63]+J2[$>>12&63]+J2[$>>6&63]+J2[$&63]}return Y?G.slice(0,Y-3)+"===".substring(Y):G},R0=typeof btoa==="function"?(X)=>btoa(X):E1?(X)=>Buffer.from(X,"binary").toString("base64"):$6,z0=E1?(X)=>Buffer.from(X).toString("base64"):(X)=>{let J=[];for(let Z=0,K=X.length;Z<K;Z+=4096)J.push(q.apply(null,X.subarray(Z,Z+4096)));return R0(J.join(""))},q2=(X,$=!1)=>$?e0(z0(X)):z0(X),K8=(X)=>{if(X.length<2){var $=X.charCodeAt(0);return $<128?X:$<2048?q(192|$>>>6)+q(128|$&63):q(224|$>>>12&15)+q(128|$>>>6&63)+q(128|$&63)}else{var $=65536+(X.charCodeAt(0)-55296)*1024+(X.charCodeAt(1)-56320);return q(240|$>>>18&7)+q(128|$>>>12&63)+q(128|$>>>6&63)+q(128|$&63)}},G8=/[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g,J6=(X)=>X.replace(G8,K8),t0=E1?(X)=>Buffer.from(X,"utf8").toString("base64"):r0?(X)=>z0(r0.encode(X)):(X)=>R0(J6(X)),P1=(X,$=!1)=>$?e0(t0(X)):t0(X),o0=(X)=>P1(X,!0),Y8=/[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g,z8=(X)=>{switch(X.length){case 4:var $=(7&X.charCodeAt(0))<<18|(63&X.charCodeAt(1))<<12|(63&X.charCodeAt(2))<<6|63&X.charCodeAt(3),J=$-65536;return q((J>>>10)+55296)+q((J&1023)+56320);case 3:return q((15&X.charCodeAt(0))<<12|(63&X.charCodeAt(1))<<6|63&X.charCodeAt(2));default:return q((31&X.charCodeAt(0))<<6|63&X.charCodeAt(1))}},Z6=(X)=>X.replace(Y8,z8),K6=(X)=>{if(X=X.replace(/\s+/g,""),!Z8.test(X))throw TypeError("malformed base64.");X+="==".slice(2-(X.length&3));let $,J,Z,K=[];for(let G=0;G<X.length;)if($=E2[X.charAt(G++)]<<18|E2[X.charAt(G++)]<<12|(J=E2[X.charAt(G++)])<<6|(Z=E2[X.charAt(G++)]),J===64)K.push(q($>>16&255));else if(Z===64)K.push(q($>>16&255,$>>8&255));else K.push(q($>>16&255,$>>8&255,$&255));return K.join("")},N0=typeof atob==="function"?(X)=>atob(X6(X)):E1?(X)=>Buffer.from(X,"base64").toString("binary"):K6,G6=E1?(X)=>a0(Buffer.from(X,"base64")):(X)=>a0(N0(X).split("").map(($)=>$.charCodeAt(0))),Y6=(X)=>G6(z6(X)),_8=E1?(X)=>Buffer.from(X,"base64").toString("utf8"):s0?(X)=>s0.decode(G6(X)):(X)=>Z6(N0(X)),z6=(X)=>X6(X.replace(/[-_]/g,($)=>$=="-"?"+":"/")),_0=(X)=>_8(z6(X)),R8=(X)=>{if(typeof X!=="string")return!1;let $=X.replace(/\s+/g,"").replace(/={0,2}$/,"");return!/[^\s0-9a-zA-Z\+/]/.test($)||!/[^\s0-9a-zA-Z\-_]/.test($)},_6=(X)=>{return{value:X,enumerable:!1,writable:!0,configurable:!0}},R6=function(){let X=($,J)=>Object.defineProperty(String.prototype,$,_6(J));X("fromBase64",function(){return _0(this)}),X("toBase64",function($){return P1(this,$)}),X("toBase64URI",function(){return P1(this,!0)}),X("toBase64URL",function(){return P1(this,!0)}),X("toUint8Array",function(){return Y6(this)})},N6=function(){let X=($,J)=>Object.defineProperty(Uint8Array.prototype,$,_6(J));X("toBase64",function($){return q2(this,$)}),X("toBase64URI",function(){return q2(this,!0)}),X("toBase64URL",function(){return q2(this,!0)})},N8=()=>{R6(),N6()},q1={version:"3.7.8",VERSION:"3.7.8",atob:N0,atobPolyfill:K6,btoa:R0,btoaPolyfill:$6,fromBase64:_0,toBase64:P1,encode:P1,encodeURI:o0,encodeURL:o0,utob:J6,btou:Z6,decode:_0,isValid:R8,fromUint8Array:q2,toUint8Array:Y6,extendString:R6,extendUint8Array:N6,extendBuiltins:N8};var i="https://github.com/libsql/libsql-client-ts#supported-urls";function X1(X){if(X==="write")return"BEGIN IMMEDIATE";else if(X==="read")return"BEGIN TRANSACTION READONLY";else if(X==="deferred")return"BEGIN DEFERRED";else throw RangeError('Unknown transaction mode, supported values are "write", "read" and "deferred"')}class f1{columns;columnTypes;rows;rowsAffected;lastInsertRowid;constructor(X,$,J,Z,K){this.columns=X,this.columnTypes=$,this.rows=J,this.rowsAffected=Z,this.lastInsertRowid=K}toJSON(){return{columns:this.columns,columnTypes:this.columnTypes,rows:this.rows.map(A8),rowsAffected:this.rowsAffected,lastInsertRowid:this.lastInsertRowid!==void 0?""+this.lastInsertRowid:null}}}function A8(X){return Array.prototype.map.call(X,Q8)}function Q8(X){if(typeof X==="bigint")return""+X;else if(X instanceof ArrayBuffer)return q1.fromUint8Array(new Uint8Array(X));else return X}var A6=":memory:";function Q6(X){return X.scheme==="file"&&(X.path===":memory:"||X.path.startsWith(":memory:?"))}function Z2(X,$){if(typeof X!=="object")throw TypeError(`Expected client configuration as object, got ${typeof X}`);let{url:J,authToken:Z,tls:K,intMode:G,concurrency:Y}=X;Y=Math.max(0,Y||20),G??="number";let _=[];if(J===A6)J="file::memory:";let z=c0(J),R=z.scheme.toLowerCase(),N=R==="file"&&z.path===A6&&z.authority===void 0,A;if(N)A={cache:{values:["shared","private"],update:(I,W)=>_.push(`${I}=${W}`)}};else A={tls:{values:["0","1"],update:(I,W)=>K=W==="1"},authToken:{update:(I,W)=>Z=W}};for(let{key:I,value:W}of z.query?.pairs??[]){if(!Object.hasOwn(A,I))throw new V(`Unsupported URL query parameter ${JSON.stringify(I)}`,"URL_PARAM_NOT_SUPPORTED");let S=A[I];if(S.values!==void 0&&!S.values.includes(W))throw new V(`Unknown value for the "${I}" query argument: ${JSON.stringify(W)}. Supported values are: [${S.values.map((I1)=>'"'+I1+'"').join(", ")}]`,"URL_INVALID");if(S.update!==void 0)S?.update(I,W)}let B=_.length===0?"":`?${_.join("&")}`,j=z.path+B,D;if(R==="libsql")if(K===!1){if(z.authority?.port===void 0)throw new V('A "libsql:" URL with ?tls=0 must specify an explicit port',"URL_INVALID");D=$?"http":"ws"}else D=$?"https":"wss";else D=R;if(D==="http"||D==="ws")K??=!1;else K??=!0;if(D!=="http"&&D!=="ws"&&D!=="https"&&D!=="wss"&&D!=="file")throw new V(`The client supports only "libsql:", "wss:", "ws:", "https:", "http:" and "file:" URLs, got ${JSON.stringify(z.scheme+":")}. For more information, please read ${i}`,"URL_SCHEME_NOT_SUPPORTED");if(G!=="number"&&G!=="bigint"&&G!=="string")throw TypeError(`Invalid value for intMode, expected "number", "bigint" or "string", got ${JSON.stringify(G)}`);if(z.fragment!==void 0)throw new V(`URL fragments are not supported: ${JSON.stringify("#"+z.fragment)}`,"URL_INVALID");if(N)return{scheme:"file",tls:!1,path:j,intMode:G,concurrency:Y,syncUrl:X.syncUrl,syncInterval:X.syncInterval,readYourWrites:X.readYourWrites,offline:X.offline,fetch:X.fetch,authToken:void 0,encryptionKey:void 0,authority:void 0};return{scheme:D,tls:K,authority:z.authority,path:j,authToken:Z,intMode:G,concurrency:Y,encryptionKey:X.encryptionKey,syncUrl:X.syncUrl,syncInterval:X.syncInterval,readYourWrites:X.readYourWrites,offline:X.offline,fetch:X.fetch}}var K2=J1(r6(),1);import{Buffer as t6}from"node:buffer";function o6(X){if(X.scheme!=="file")throw new V(`URL scheme ${JSON.stringify(X.scheme+":")} is not supported by the local sqlite3 client. For more information, please read ${i}`,"URL_SCHEME_NOT_SUPPORTED");let $=X.authority;if($!==void 0){let Y=$.host.toLowerCase();if(Y!==""&&Y!=="localhost")throw new V(`Invalid host in file URL: ${JSON.stringify($.host)}. A "file:" URL with an absolute path should start with one slash ("file:/absolute/path.db") or with three slashes ("file:///absolute/path.db"). For more information, please read ${i}`,"URL_INVALID");if($.port!==void 0)throw new V("File URL cannot have a port","URL_INVALID");if($.userinfo!==void 0)throw new V("File URL cannot have username and password","URL_INVALID")}let J=Q6(X);if(J&&X.syncUrl)throw new V(`Embedded replica must use file for local db but URI with in-memory mode were provided instead: ${X.path}`,"URL_INVALID");let Z=X.path;if(J)Z=`${X.scheme}:${X.path}`;let K={authToken:X.authToken,encryptionKey:X.encryptionKey,syncUrl:X.syncUrl,syncPeriod:X.syncInterval,readYourWrites:X.readYourWrites,offline:X.offline},G=new K2.default(Z,K);return P(G,"SELECT 1 AS checkThatTheDatabaseCanBeOpened",X.intMode),new e6(Z,K,G,X.intMode)}class e6{#X;#$;#J;#Z;closed;protocol;constructor(X,$,J,Z){this.#X=X,this.#$=$,this.#J=J,this.#Z=Z,this.closed=!1,this.protocol="file"}async execute(X,$){let J;if(typeof X==="string")J={sql:X,args:$||[]};else J=X;return this.#K(),P(this.#G(),J,this.#Z)}async batch(X,$="deferred"){this.#K();let J=this.#G();try{P(J,X1($),this.#Z);let Z=X.map((K)=>{if(!J.inTransaction)throw new V("The transaction has been rolled back","TRANSACTION_CLOSED");let G=Array.isArray(K)?{sql:K[0],args:K[1]||[]}:K;return P(J,G,this.#Z)});return P(J,"COMMIT",this.#Z),Z}finally{if(J.inTransaction)P(J,"ROLLBACK",this.#Z)}}async migrate(X){this.#K();let $=this.#G();try{P($,"PRAGMA foreign_keys=off",this.#Z),P($,X1("deferred"),this.#Z);let J=X.map((Z)=>{if(!$.inTransaction)throw new V("The transaction has been rolled back","TRANSACTION_CLOSED");return P($,Z,this.#Z)});return P($,"COMMIT",this.#Z),J}finally{if($.inTransaction)P($,"ROLLBACK",this.#Z);P($,"PRAGMA foreign_keys=on",this.#Z)}}async transaction(X="write"){let $=this.#G();return P($,X1(X),this.#Z),this.#J=null,new X3($,this.#Z)}async executeMultiple(X){this.#K();let $=this.#G();try{return $3($,X)}finally{if($.inTransaction)P($,"ROLLBACK",this.#Z)}}async sync(){this.#K();let X=await this.#G().sync();return{frames_synced:X.frames_synced,frame_no:X.frame_no}}async reconnect(){try{if(!this.closed&&this.#J!==null)this.#J.close()}finally{this.#J=new K2.default(this.#X,this.#$),this.closed=!1}}close(){if(this.closed=!0,this.#J!==null)this.#J.close(),this.#J=null}#K(){if(this.closed)throw new V("The client is closed","CLIENT_CLOSED")}#G(){if(this.#J===null)this.#J=new K2.default(this.#X,this.#$);return this.#J}}class X3{#X;#$;constructor(X,$){this.#X=X,this.#$=$}async execute(X,$){let J;if(typeof X==="string")J={sql:X,args:$||[]};else J=X;return this.#J(),P(this.#X,J,this.#$)}async batch(X){return X.map(($)=>{this.#J();let J=Array.isArray($)?{sql:$[0],args:$[1]||[]}:$;return P(this.#X,J,this.#$)})}async executeMultiple(X){return this.#J(),$3(this.#X,X)}async rollback(){if(!this.#X.open)return;this.#J(),P(this.#X,"ROLLBACK",this.#$)}async commit(){this.#J(),P(this.#X,"COMMIT",this.#$)}close(){if(this.#X.inTransaction)P(this.#X,"ROLLBACK",this.#$)}get closed(){return!this.#X.inTransaction}#J(){if(this.closed)throw new V("The transaction is closed","TRANSACTION_CLOSED")}}function P(X,$,J){let Z,K;if(typeof $==="string")Z=$,K=[];else if(Z=$.sql,Array.isArray($.args))K=$.args.map((G)=>a6(G,J));else{K={};for(let G in $.args){let Y=G[0]==="@"||G[0]==="$"||G[0]===":"?G.substring(1):G;K[Y]=a6($.args[G],J)}}try{let G=X.prepare(Z);G.safeIntegers(!0);let Y=!0;try{G.raw(!0)}catch{Y=!1}if(Y){let _=Array.from(G.columns().map((B)=>B.name)),z=Array.from(G.columns().map((B)=>B.type??"")),R=G.all(K).map((B)=>{return YX(B,_,J)}),N=0,A=void 0;return new f1(_,z,R,0,void 0)}else{let _=G.run(K),z=_.changes,R=BigInt(_.lastInsertRowid);return new f1([],[],[],z,R)}}catch(G){throw J3(G)}}function YX(X,$,J){let Z={};Object.defineProperty(Z,"length",{value:X.length});for(let K=0;K<X.length;++K){let G=zX(X[K],J);Object.defineProperty(Z,K,{value:G});let Y=$[K];if(!Object.hasOwn(Z,Y))Object.defineProperty(Z,Y,{value:G,enumerable:!0,configurable:!0,writable:!0})}return Z}function zX(X,$){if(typeof X==="bigint")if($==="number"){if(X<_X||X>RX)throw RangeError("Received integer which cannot be safely represented as a JavaScript number");return Number(X)}else if($==="bigint")return X;else if($==="string")return""+X;else throw Error("Invalid value for IntMode");else if(X instanceof t6)return X.buffer;return X}var _X=-9007199254740991n,RX=9007199254740991n;function a6(X,$){if(typeof X==="number"){if(!Number.isFinite(X))throw RangeError("Only finite numbers (not Infinity or NaN) can be passed as arguments");return X}else if(typeof X==="bigint"){if(X<NX||X>AX)throw RangeError("bigint is too large to be represented as a 64-bit integer and passed as argument");return X}else if(typeof X==="boolean")switch($){case"bigint":return X?1n:0n;case"string":return X?"1":"0";default:return X?1:0}else if(X instanceof ArrayBuffer)return t6.from(X);else if(X instanceof Date)return X.valueOf();else if(X===void 0)throw TypeError("undefined cannot be passed as argument to the database");else return X}var NX=-9223372036854775808n,AX=9223372036854775807n;function $3(X,$){try{X.exec($)}catch(J){throw J3(J)}}function J3(X){if(X instanceof K2.default.SqliteError)return new V(X.message,X.code,X.rawCode,X);return X}var E$=J1(t3(),1),q$=J1(x0(),1),f$=J1(U0(),1),b1=J1(m2(),1),C$=J1(K4(),1);class i1{constructor(){this.intMode="number"}intMode}class x extends Error{constructor(X){super(X);this.name="ClientError"}}class Q extends x{constructor(X){super(X);this.name="ProtoError"}}class I2 extends x{code;proto;constructor(X,$){super(X);this.name="ResponseError",this.code=$.code,this.proto=$,this.stack=void 0}}class L extends x{constructor(X,$){if($!==void 0){super(`${X}: ${$}`);this.cause=$}else super(X);this.name="ClosedError"}}class V2 extends x{constructor(X){super(X);this.name="WebSocketUnsupportedError"}}class m1 extends x{constructor(X){super(X);this.name="WebSocketError"}}class W1 extends x{status;constructor(X,$){super(X);this.status=$,this.name="HttpServerError"}}class p extends x{constructor(X){super(X);this.name="ProtocolVersionError"}}class f extends x{constructor(X){super(X);this.name="InternalError"}}class n extends x{constructor(X){super(X);this.name="MisuseError"}}function C(X){if(typeof X==="string")return X;throw d1(X,"string")}function h(X){if(X===null||X===void 0)return;else if(typeof X==="string")return X;throw d1(X,"string or null")}function t(X){if(typeof X==="number")return X;throw d1(X,"number")}function z1(X){if(typeof X==="boolean")return X;throw d1(X,"boolean")}function O2(X){if(Array.isArray(X))return X;throw d1(X,"array")}function y(X){if(X!==null&&typeof X==="object"&&!Array.isArray(X))return X;throw d1(X,"object")}function b(X,$){return O2(X).map((J)=>$(y(J)))}function d1(X,$){if(X===void 0)return new Q(`Expected ${$}, but the property was missing`);let J=typeof X;if(X===null)J="null";else if(Array.isArray(X))J="array";return new Q(`Expected ${$}, received ${J}`)}function j1(X,$){return $(y(X))}class G4{#X;#$;constructor(X){this.#X=X,this.#$=!1}begin(){this.#X.push("{"),this.#$=!0}end(){this.#X.push("}"),this.#$=!1}#J(X){if(this.#$)this.#X.push('"'),this.#$=!1;else this.#X.push(',"');this.#X.push(X),this.#X.push('":')}string(X,$){this.#J(X),this.#X.push(JSON.stringify($))}stringRaw(X,$){this.#J(X),this.#X.push('"'),this.#X.push($),this.#X.push('"')}number(X,$){this.#J(X),this.#X.push(""+$)}boolean(X,$){this.#J(X),this.#X.push($?"true":"false")}object(X,$,J){this.#J(X),this.begin(),J(this,$),this.end()}arrayObjects(X,$,J){this.#J(X),this.#X.push("[");for(let Z=0;Z<$.length;++Z){if(Z!==0)this.#X.push(",");this.begin(),J(this,$[Z]),this.end()}this.#X.push("]")}}function D2(X,$){let J=[],Z=new G4(J);return Z.begin(),$(Z,X),Z.end(),J.join("")}var F1=0,H2=1,x2=2;var Y4=5;class z4{#X;#$;#J;constructor(X){this.#X=X,this.#$=new DataView(X.buffer,X.byteOffset,X.byteLength),this.#J=0}varint(){let X=0;for(let $=0;;$+=7){let J=this.#X[this.#J++];if(X|=(J&127)<<$,!(J&128))break}return X}varintBig(){let X=0n;for(let $=0n;;$+=7n){let J=this.#X[this.#J++];if(X|=BigInt(J&127)<<$,!(J&128))break}return X}bytes(X){let $=new Uint8Array(this.#X.buffer,this.#X.byteOffset+this.#J,X);return this.#J+=X,$}double(){let X=this.#$.getFloat64(this.#J,!0);return this.#J+=8,X}skipVarint(){for(;;)if(!(this.#X[this.#J++]&128))break}skip(X){this.#J+=X}eof(){return this.#J>=this.#X.byteLength}}class _4{#X;#$;constructor(X){this.#X=X,this.#$=-1}setup(X){this.#$=X}#J(X){if(this.#$!==X)throw new Q(`Expected wire type ${X}, got ${this.#$}`);this.#$=-1}bytes(){this.#J(x2);let X=this.#X.varint();return this.#X.bytes(X)}string(){return new TextDecoder().decode(this.bytes())}message(X){return _1(this.bytes(),X)}int32(){return this.#J(F1),this.#X.varint()}uint32(){return this.int32()}bool(){return this.int32()!==0}uint64(){return this.#J(F1),this.#X.varintBig()}sint64(){let X=this.uint64();return X>>1n^-(X&1n)}double(){return this.#J(H2),this.#X.double()}maybeSkip(){if(this.#$<0)return;else if(this.#$===F1)this.#X.skipVarint();else if(this.#$===H2)this.#X.skip(8);else if(this.#$===x2){let X=this.#X.varint();this.#X.skip(X)}else if(this.#$===Y4)this.#X.skip(4);else throw new Q(`Unexpected wire type ${this.#$}`);this.#$=-1}}function _1(X,$){let J=new z4(X),Z=new _4(J),K=$.default();while(!J.eof()){let G=J.varint(),Y=G>>3,_=G&7;Z.setup(_);let z=$[Y];if(z!==void 0){let R=z(Z,K);if(R!==void 0)K=R}Z.maybeSkip()}return K}class y0{#X;#$;#J;#Z;constructor(){this.#X=new ArrayBuffer(256),this.#$=new Uint8Array(this.#X),this.#J=new DataView(this.#X),this.#Z=0}#K(X){if(this.#Z+X<=this.#X.byteLength)return;let $=this.#X.byteLength;while($<this.#Z+X)$*=2;let J=new ArrayBuffer($),Z=new Uint8Array(J),K=new DataView(J);Z.set(new Uint8Array(this.#X,0,this.#Z)),this.#X=J,this.#$=Z,this.#J=K}#G(X){this.#K(5),X=0|X;do{let $=X&127;X>>>=7,$|=X?128:0,this.#$[this.#Z++]=$}while(X)}#z(X){this.#K(10),X=X&0xffffffffffffffffn;do{let $=Number(X&0x7fn);X>>=7n,$|=X?128:0,this.#$[this.#Z++]=$}while(X)}#Y(X,$){this.#G(X<<3|$)}bytes(X,$){this.#Y(X,x2),this.#G($.byteLength),this.#K($.byteLength),this.#$.set($,this.#Z),this.#Z+=$.byteLength}string(X,$){this.bytes(X,new TextEncoder().encode($))}message(X,$,J){let Z=new y0;J(Z,$),this.bytes(X,Z.data())}int32(X,$){this.#Y(X,F1),this.#G($)}uint32(X,$){this.int32(X,$)}bool(X,$){this.int32(X,$?1:0)}sint64(X,$){this.#Y(X,F1),this.#z($<<1n^$>>63n)}double(X,$){this.#Y(X,H2),this.#K(8),this.#J.setFloat64(this.#Z,$,!0),this.#Z+=8}data(){return new Uint8Array(this.#X,0,this.#Z)}}function B2(X,$){let J=new y0;return $(J,X),J.data()}class R1{#X;#$;constructor(){this.#X=new Set,this.#$=new Set}alloc(){for(let $ of this.#$){if(this.#$.delete($),this.#X.add($),!this.#X.has(this.#X.size-1))this.#$.add(this.#X.size-1);return $}let X=this.#X.size;return this.#X.add(X),X}free(X){if(!this.#X.delete(X))throw new f("Freeing an id that is not allocated");if(this.#$.delete(this.#X.size),X<this.#X.size)this.#$.add(X)}}function H(X,$){throw new f($)}function l1(X){if(X===null)return null;else if(typeof X==="string")return X;else if(typeof X==="number"){if(!Number.isFinite(X))throw RangeError("Only finite numbers (not Infinity or NaN) can be passed as arguments");return X}else if(typeof X==="bigint"){if(X<h$||X>S$)throw RangeError("This bigint value is too large to be represented as a 64-bit integer and passed as argument");return X}else if(typeof X==="boolean")return X?1n:0n;else if(X instanceof ArrayBuffer)return new Uint8Array(X);else if(X instanceof Uint8Array)return X;else if(X instanceof Date)return+X.valueOf();else if(typeof X==="object")return""+X.toString();else throw TypeError("Unsupported type of value")}var h$=-9223372036854775808n,S$=9223372036854775807n;function P0(X,$){if(X===null)return null;else if(typeof X==="number")return X;else if(typeof X==="string")return X;else if(typeof X==="bigint")if($==="number"){let J=Number(X);if(!Number.isSafeInteger(J))throw RangeError("Received integer which is too large to be safely represented as a JavaScript number");return J}else if($==="bigint")return X;else if($==="string")return""+X;else throw new n("Invalid value for IntMode");else if(X instanceof Uint8Array)return X.slice().buffer;else if(X===void 0)throw new Q("Received unrecognized type of Value");else throw H(X,"Impossible type of Value")}function T1(X){return{affectedRowCount:X.affectedRowCount,lastInsertRowid:X.lastInsertRowid,columnNames:X.cols.map(($)=>$.name),columnDecltypes:X.cols.map(($)=>$.decltype)}}function n2(X,$){let J=T1(X),Z=X.rows.map((K)=>R4(J.columnNames,K,$));return{...J,rows:Z}}function c2(X,$){let J=T1(X),Z;if(X.rows.length>0)Z=R4(J.columnNames,X.rows[0],$);return{...J,row:Z}}function s2(X,$){let J=T1(X),Z;if(X.rows.length>0&&J.columnNames.length>0)Z=P0(X.rows[0][0],$);return{...J,value:Z}}function R4(X,$,J){let Z={};Object.defineProperty(Z,"length",{value:$.length});for(let K=0;K<$.length;++K){let G=P0($[K],J);Object.defineProperty(Z,K,{value:G});let Y=X[K];if(Y!==void 0&&!Object.hasOwn(Z,Y))Object.defineProperty(Z,Y,{value:G,enumerable:!0,configurable:!0,writable:!0})}return Z}function o(X){return new I2(X.message,X)}class M1{#X;#$;#J;constructor(X,$){this.#X=X,this.#$=$,this.#J=void 0}_getSqlId(X){if(this.#X!==X)throw new n("Attempted to use SQL text opened with other object");else if(this.#J!==void 0)throw new L("SQL text is closed",this.#J);return this.#$}close(){this._setClosed(new x("SQL text was manually closed"))}_setClosed(X){if(this.#J===void 0)this.#J=X,this.#X._closeSql(this.#$)}get closed(){return this.#J!==void 0}}function U2(X,$){if($ instanceof M1)return{sqlId:$._getSqlId(X)};else return{sql:""+$}}class N1{#X;#$;constructor(){this.#X=[],this.#$=[]}get length(){return this.#X.length+this.#$.length}push(X){this.#X.push(X)}shift(){if(this.#$.length===0&&this.#X.length>0)this.#$=this.#X.reverse(),this.#X=[];return this.#$.pop()}first(){return this.#$.length!==0?this.#$[this.#$.length-1]:this.#X[0]}}class W2{sql;_args;_namedArgs;constructor(X){this.sql=X,this._args=[],this._namedArgs=new Map}bindIndexes(X){this._args.length=0;for(let $ of X)this._args.push(l1($));return this}bindIndex(X,$){if(X!==(X|0)||X<=0)throw RangeError("Index of a positional argument must be positive integer");while(this._args.length<X)this._args.push(null);return this._args[X-1]=l1($),this}bindName(X,$){return this._namedArgs.set(X,l1($)),this}unbindAll(){return this._args.length=0,this._namedArgs.clear(),this}}function r2(X,$,J){let Z,K=[],G=[];if($ instanceof W2){Z=$.sql,K=$._args;for(let[z,R]of $._namedArgs.entries())G.push({name:z,value:R})}else if(Array.isArray($))if(Z=$[0],Array.isArray($[1]))K=$[1].map((z)=>l1(z));else G=Object.entries($[1]).map(([z,R])=>{return{name:z,value:l1(R)}});else Z=$;let{sql:Y,sqlId:_}=U2(X,Z);return{sql:Y,sqlId:_,args:K,namedArgs:G,wantRows:J}}class a2{_stream;#X;_steps;#$;constructor(X,$){this._stream=X,this.#X=$,this._steps=[],this.#$=!1}step(){return new E0(this)}execute(){if(this.#$)throw new n("This batch has already been executed");this.#$=!0;let X={steps:this._steps.map(($)=>$.proto)};if(this.#X)return g$(this._stream,this._steps,X);else return v$(this._stream,this._steps,X)}}function v$(X,$,J){return X._batch(J).then((Z)=>{for(let K=0;K<$.length;++K){let G=Z.stepResults.get(K),Y=Z.stepErrors.get(K);$[K].callback(G,Y)}})}async function g$(X,$,J){let Z=await X._openCursor(J);try{let K=0,G=void 0,Y=[];for(;;){let _=await Z.next();if(_===void 0)break;if(_.type==="step_begin"){if(_.step<K||_.step>=$.length)throw new Q("Server produced StepBeginEntry for unexpected step");else if(G!==void 0)throw new Q("Server produced StepBeginEntry before terminating previous step");for(let z=K;z<_.step;++z)$[z].callback(void 0,void 0);K=_.step+1,G=_,Y=[]}else if(_.type==="step_end"){if(G===void 0)throw new Q("Server produced StepEndEntry but no step is active");let z={cols:G.cols,rows:Y,affectedRowCount:_.affectedRowCount,lastInsertRowid:_.lastInsertRowid};$[G.step].callback(z,void 0),G=void 0,Y=[]}else if(_.type==="step_error"){if(G===void 0){if(_.step>=$.length)throw new Q("Server produced StepErrorEntry for unexpected step");for(let z=K;z<_.step;++z)$[z].callback(void 0,void 0)}else{if(_.step!==G.step)throw new Q("Server produced StepErrorEntry for unexpected step");G=void 0,Y=[]}$[_.step].callback(void 0,_.error),K=_.step+1}else if(_.type==="row"){if(G===void 0)throw new Q("Server produced RowEntry but no step is active");Y.push(_.row)}else if(_.type==="error")throw o(_.error);else if(_.type==="none")throw new Q("Server produced unrecognized CursorEntry");else throw H(_,"Impossible CursorEntry")}if(G!==void 0)throw new Q("Server closed Cursor before terminating active step");for(let _=K;_<$.length;++_)$[_].callback(void 0,void 0)}finally{Z.close()}}class E0{_batch;#X;_index;constructor(X){this._batch=X,this.#X=[],this._index=void 0}condition(X){return this.#X.push(X._proto),this}query(X){return this.#$(X,!0,n2)}queryRow(X){return this.#$(X,!0,c2)}queryValue(X){return this.#$(X,!0,s2)}run(X){return this.#$(X,!1,T1)}#$(X,$,J){if(this._index!==void 0)throw new n("This BatchStep has already been added to the batch");let Z=r2(this._batch._stream._sqlOwner(),X,$),K;if(this.#X.length===0)K=void 0;else if(this.#X.length===1)K=this.#X[0];else K={type:"and",conds:this.#X.slice()};let G={stmt:Z,condition:K};return new Promise((Y,_)=>{let z=(R,N)=>{if(R!==void 0&&N!==void 0)_(new Q("Server returned both result and error"));else if(N!==void 0)_(o(N));else if(R!==void 0)Y(J(R,this._batch._stream.intMode));else Y(void 0)};this._index=this._batch._steps.length,this._batch._steps.push({proto:G,callback:z})})}}class F{_batch;_proto;constructor(X,$){this._batch=X,this._proto=$}static ok(X){return new F(X._batch,{type:"ok",step:N4(X)})}static error(X){return new F(X._batch,{type:"error",step:N4(X)})}static not(X){return new F(X._batch,{type:"not",cond:X._proto})}static and(X,$){for(let J of $)A4(X,J);return new F(X,{type:"and",conds:$.map((J)=>J._proto)})}static or(X,$){for(let J of $)A4(X,J);return new F(X,{type:"or",conds:$.map((J)=>J._proto)})}static isAutocommit(X){return X._stream.client()._ensureVersion(3,"BatchCond.isAutocommit()"),new F(X,{type:"is_autocommit"})}}function N4(X){if(X._index===void 0)throw new n("Cannot add a condition referencing a step that has not been added to the batch");return X._index}function A4(X,$){if($._batch!==X)throw new n("Cannot mix BatchCond objects for different Batch objects")}function Q4(X){return{paramNames:X.params.map(($)=>$.name),columns:X.cols,isExplain:X.isExplain,isReadonly:X.isReadonly}}class n1{constructor(X){this.intMode=X}query(X){return this.#X(X,!0,n2)}queryRow(X){return this.#X(X,!0,c2)}queryValue(X){return this.#X(X,!0,s2)}run(X){return this.#X(X,!1,T1)}#X(X,$,J){let Z=r2(this._sqlOwner(),X,$);return this._execute(Z).then((K)=>J(K,this.intMode))}batch(X=!1){return new a2(this,X)}describe(X){let $=U2(this._sqlOwner(),X);return this._describe($).then(Q4)}sequence(X){let $=U2(this._sqlOwner(),X);return this._sequence($)}intMode}class j2{}var u$=1000,k$=10;class q0 extends j2{#X;#$;#J;#Z;#K;#G;#z;constructor(X,$,J){super();this.#X=X,this.#$=$,this.#J=J,this.#Z=new N1,this.#K=new N1,this.#G=void 0,this.#z=!1}async next(){for(;;){if(this.#G!==void 0)throw new L("Cursor is closed",this.#G);while(!this.#z&&this.#K.length<k$)this.#K.push(this.#Y());let X=this.#Z.shift();if(this.#z||X!==void 0)return X;await this.#K.shift().then(($)=>{if($===void 0)return;for(let J of $.entries)this.#Z.push(J);this.#z||=$.done})}}#Y(){return this.#$._sendCursorRequest(this,{type:"fetch_cursor",cursorId:this.#J,maxCount:u$}).then((X)=>X,(X)=>{this._setClosed(X);return})}_setClosed(X){if(this.#G!==void 0)return;this.#G=X,this.#$._sendCursorRequest(this,{type:"close_cursor",cursorId:this.#J}).catch(()=>{return}),this.#$._cursorClosed(this)}close(){this._setClosed(new x("Cursor was manually closed"))}get closed(){return this.#G!==void 0}}class F2 extends n1{#X;#$;#J;#Z;#K;#G;static open(X){let $=X._streamIdAlloc.alloc(),J=new F2(X,$),Z=()=>{return},K=(Y)=>J.#R(Y),G={type:"open_stream",streamId:$};return X._sendRequest(G,{responseCallback:Z,errorCallback:K}),J}constructor(X,$){super(X.intMode);this.#X=X,this.#$=$,this.#J=new N1,this.#Z=void 0,this.#K=!1,this.#G=void 0}client(){return this.#X}_sqlOwner(){return this.#X}_execute(X){return this.#z({type:"execute",streamId:this.#$,stmt:X}).then(($)=>{return $.result})}_batch(X){return this.#z({type:"batch",streamId:this.#$,batch:X}).then(($)=>{return $.result})}_describe(X){return this.#X._ensureVersion(2,"describe()"),this.#z({type:"describe",streamId:this.#$,sql:X.sql,sqlId:X.sqlId}).then(($)=>{return $.result})}_sequence(X){return this.#X._ensureVersion(2,"sequence()"),this.#z({type:"sequence",streamId:this.#$,sql:X.sql,sqlId:X.sqlId}).then(($)=>{return})}getAutocommit(){return this.#X._ensureVersion(3,"getAutocommit()"),this.#z({type:"get_autocommit",streamId:this.#$}).then((X)=>{return X.isAutocommit})}#z(X){return new Promise(($,J)=>{this.#Y({type:"request",request:X,responseCallback:$,errorCallback:J})})}_openCursor(X){return this.#X._ensureVersion(3,"cursor"),new Promise(($,J)=>{this.#Y({type:"cursor",batch:X,cursorCallback:$,errorCallback:J})})}_sendCursorRequest(X,$){if(X!==this.#Z)throw new f("Cursor not associated with the stream attempted to execute a request");return new Promise((J,Z)=>{if(this.#G!==void 0)Z(new L("Stream is closed",this.#G));else this.#X._sendRequest($,{responseCallback:J,errorCallback:Z})})}_cursorClosed(X){if(X!==this.#Z)throw new f("Cursor was closed, but it was not associated with the stream");this.#Z=void 0,this.#_()}#Y(X){if(this.#G!==void 0)X.errorCallback(new L("Stream is closed",this.#G));else if(this.#K)X.errorCallback(new L("Stream is closing",void 0));else this.#J.push(X),this.#_()}#_(){for(;;){let X=this.#J.first();if(X===void 0&&this.#Z===void 0&&this.#K){this.#R(new x("Stream was gracefully closed"));break}else if(X?.type==="request"&&this.#Z===void 0){let{request:$,responseCallback:J,errorCallback:Z}=X;this.#J.shift(),this.#X._sendRequest($,{responseCallback:J,errorCallback:Z})}else if(X?.type==="cursor"&&this.#Z===void 0){let{batch:$,cursorCallback:J}=X;this.#J.shift();let Z=this.#X._cursorIdAlloc.alloc(),K=new q0(this.#X,this,Z),G={type:"open_cursor",streamId:this.#$,cursorId:Z,batch:$},Y=()=>{return},_=(z)=>K._setClosed(z);this.#X._sendRequest(G,{responseCallback:Y,errorCallback:_}),this.#Z=K,J(K)}else break}}#R(X){if(this.#G!==void 0)return;if(this.#G=X,this.#Z!==void 0)this.#Z._setClosed(X);for(;;){let K=this.#J.shift();if(K!==void 0)K.errorCallback(X);else break}let $={type:"close_stream",streamId:this.#$},J=()=>this.#X._streamIdAlloc.free(this.#$),Z=()=>{return};this.#X._sendRequest($,{responseCallback:J,errorCallback:Z})}close(){this.#R(new x("Stream was manually closed"))}closeGracefully(){this.#K=!0,this.#_()}get closed(){return this.#G!==void 0||this.#K}}function T2(X,$){if($.sql!==void 0)X.string("sql",$.sql);if($.sqlId!==void 0)X.number("sql_id",$.sqlId);X.arrayObjects("args",$.args,I4),X.arrayObjects("named_args",$.namedArgs,p$),X.boolean("want_rows",$.wantRows)}function p$(X,$){X.string("name",$.name),X.object("value",$.value,I4)}function c1(X,$){X.arrayObjects("steps",$.steps,b$)}function b$(X,$){if($.condition!==void 0)X.object("condition",$.condition,f0);X.object("stmt",$.stmt,T2)}function f0(X,$){if(X.stringRaw("type",$.type),$.type==="ok"||$.type==="error")X.number("step",$.step);else if($.type==="not")X.object("cond",$.cond,f0);else if($.type==="and"||$.type==="or")X.arrayObjects("conds",$.conds,f0);else if($.type==="is_autocommit");else throw H($,"Impossible type of BatchCond")}function I4(X,$){if($===null)X.stringRaw("type","null");else if(typeof $==="bigint")X.stringRaw("type","integer"),X.stringRaw("value",""+$);else if(typeof $==="number")X.stringRaw("type","float"),X.number("value",$);else if(typeof $==="string")X.stringRaw("type","text"),X.string("value",$);else if($ instanceof Uint8Array)X.stringRaw("type","blob"),X.stringRaw("base64",q1.fromUint8Array($));else if($===void 0);else throw H($,"Impossible type of Value")}function V4(X,$){if(X.stringRaw("type",$.type),$.type==="hello"){if($.jwt!==void 0)X.string("jwt",$.jwt)}else if($.type==="request")X.number("request_id",$.requestId),X.object("request",$.request,i$);else throw H($,"Impossible type of ClientMsg")}function i$(X,$){if(X.stringRaw("type",$.type),$.type==="open_stream")X.number("stream_id",$.streamId);else if($.type==="close_stream")X.number("stream_id",$.streamId);else if($.type==="execute")X.number("stream_id",$.streamId),X.object("stmt",$.stmt,T2);else if($.type==="batch")X.number("stream_id",$.streamId),X.object("batch",$.batch,c1);else if($.type==="open_cursor")X.number("stream_id",$.streamId),X.number("cursor_id",$.cursorId),X.object("batch",$.batch,c1);else if($.type==="close_cursor")X.number("cursor_id",$.cursorId);else if($.type==="fetch_cursor")X.number("cursor_id",$.cursorId),X.number("max_count",$.maxCount);else if($.type==="sequence"){if(X.number("stream_id",$.streamId),$.sql!==void 0)X.string("sql",$.sql);if($.sqlId!==void 0)X.number("sql_id",$.sqlId)}else if($.type==="describe"){if(X.number("stream_id",$.streamId),$.sql!==void 0)X.string("sql",$.sql);if($.sqlId!==void 0)X.number("sql_id",$.sqlId)}else if($.type==="store_sql")X.number("sql_id",$.sqlId),X.string("sql",$.sql);else if($.type==="close_sql")X.number("sql_id",$.sqlId);else if($.type==="get_autocommit")X.number("stream_id",$.streamId);else throw H($,"Impossible type of Request")}function M2(X,$){if($.sql!==void 0)X.string(1,$.sql);if($.sqlId!==void 0)X.int32(2,$.sqlId);for(let J of $.args)X.message(3,J,D4);for(let J of $.namedArgs)X.message(4,J,m$);X.bool(5,$.wantRows)}function m$(X,$){X.string(1,$.name),X.message(2,$.value,D4)}function s1(X,$){for(let J of $.steps)X.message(1,J,d$)}function d$(X,$){if($.condition!==void 0)X.message(1,$.condition,C0);X.message(2,$.stmt,M2)}function C0(X,$){if($.type==="ok")X.uint32(1,$.step);else if($.type==="error")X.uint32(2,$.step);else if($.type==="not")X.message(3,$.cond,C0);else if($.type==="and")X.message(4,$.conds,O4);else if($.type==="or")X.message(5,$.conds,O4);else if($.type==="is_autocommit")X.message(6,void 0,H4);else throw H($,"Impossible type of BatchCond")}function O4(X,$){for(let J of $)X.message(1,J,C0)}function D4(X,$){if($===null)X.message(1,void 0,H4);else if(typeof $==="bigint")X.sint64(2,$);else if(typeof $==="number")X.double(3,$);else if(typeof $==="string")X.string(4,$);else if($ instanceof Uint8Array)X.bytes(5,$);else if($===void 0);else throw H($,"Impossible type of Value")}function H4(X,$){}function x4(X,$){if($.type==="hello")X.message(1,$,l$);else if($.type==="request")X.message(2,$,n$);else throw H($,"Impossible type of ClientMsg")}function l$(X,$){if($.jwt!==void 0)X.string(1,$.jwt)}function n$(X,$){X.int32(1,$.requestId);let J=$.request;if(J.type==="open_stream")X.message(2,J,c$);else if(J.type==="close_stream")X.message(3,J,s$);else if(J.type==="execute")X.message(4,J,r$);else if(J.type==="batch")X.message(5,J,a$);else if(J.type==="open_cursor")X.message(6,J,t$);else if(J.type==="close_cursor")X.message(7,J,o$);else if(J.type==="fetch_cursor")X.message(8,J,e$);else if(J.type==="sequence")X.message(9,J,XJ);else if(J.type==="describe")X.message(10,J,$J);else if(J.type==="store_sql")X.message(11,J,JJ);else if(J.type==="close_sql")X.message(12,J,ZJ);else if(J.type==="get_autocommit")X.message(13,J,KJ);else throw H(J,"Impossible type of Request")}function c$(X,$){X.int32(1,$.streamId)}function s$(X,$){X.int32(1,$.streamId)}function r$(X,$){X.int32(1,$.streamId),X.message(2,$.stmt,M2)}function a$(X,$){X.int32(1,$.streamId),X.message(2,$.batch,s1)}function t$(X,$){X.int32(1,$.streamId),X.int32(2,$.cursorId),X.message(3,$.batch,s1)}function o$(X,$){X.int32(1,$.cursorId)}function e$(X,$){X.int32(1,$.cursorId),X.uint32(2,$.maxCount)}function XJ(X,$){if(X.int32(1,$.streamId),$.sql!==void 0)X.string(2,$.sql);if($.sqlId!==void 0)X.int32(3,$.sqlId)}function $J(X,$){if(X.int32(1,$.streamId),$.sql!==void 0)X.string(2,$.sql);if($.sqlId!==void 0)X.int32(3,$.sqlId)}function JJ(X,$){X.int32(1,$.sqlId),X.string(2,$.sql)}function ZJ(X,$){X.int32(1,$.sqlId)}function KJ(X,$){X.int32(1,$.streamId)}function A1(X){let $=C(X.message),J=h(X.code);return{message:$,code:J}}function L2(X){let $=b(X.cols,B4),J=O2(X.rows).map((Y)=>b(Y,U4)),Z=t(X.affected_row_count),K=h(X.last_insert_rowid),G=K!==void 0?BigInt(K):void 0;return{cols:$,rows:J,affectedRowCount:Z,lastInsertRowid:G}}function B4(X){let $=h(X.name),J=h(X.decltype);return{name:$,decltype:J}}function t2(X){let $=new Map;O2(X.step_results).forEach((Z,K)=>{if(Z!==null)$.set(K,L2(y(Z)))});let J=new Map;return O2(X.step_errors).forEach((Z,K)=>{if(Z!==null)J.set(K,A1(y(Z)))}),{stepResults:$,stepErrors:J}}function o2(X){let $=C(X.type);if($==="step_begin"){let J=t(X.step),Z=b(X.cols,B4);return{type:"step_begin",step:J,cols:Z}}else if($==="step_end"){let J=t(X.affected_row_count),Z=h(X.last_insert_rowid),K=Z!==void 0?BigInt(Z):void 0;return{type:"step_end",affectedRowCount:J,lastInsertRowid:K}}else if($==="step_error"){let J=t(X.step),Z=A1(y(X.error));return{type:"step_error",step:J,error:Z}}else if($==="row")return{type:"row",row:b(X.row,U4)};else if($==="error")return{type:"error",error:A1(y(X.error))};else throw new Q("Unexpected type of CursorEntry")}function e2(X){let $=b(X.params,GJ),J=b(X.cols,YJ),Z=z1(X.is_explain),K=z1(X.is_readonly);return{params:$,cols:J,isExplain:Z,isReadonly:K}}function GJ(X){return{name:h(X.name)}}function YJ(X){let $=C(X.name),J=h(X.decltype);return{name:$,decltype:J}}function U4(X){let $=C(X.type);if($==="null")return null;else if($==="integer"){let J=C(X.value);return BigInt(J)}else if($==="float")return t(X.value);else if($==="text")return C(X.value);else if($==="blob")return q1.toUint8Array(C(X.base64));else throw new Q("Unexpected type of Value")}function W4(X){let $=C(X.type);if($==="hello_ok")return{type:"hello_ok"};else if($==="hello_error")return{type:"hello_error",error:A1(y(X.error))};else if($==="response_ok"){let J=t(X.request_id),Z=zJ(y(X.response));return{type:"response_ok",requestId:J,response:Z}}else if($==="response_error"){let J=t(X.request_id),Z=A1(y(X.error));return{type:"response_error",requestId:J,error:Z}}else throw new Q("Unexpected type of ServerMsg")}function zJ(X){let $=C(X.type);if($==="open_stream")return{type:"open_stream"};else if($==="close_stream")return{type:"close_stream"};else if($==="execute")return{type:"execute",result:L2(y(X.result))};else if($==="batch")return{type:"batch",result:t2(y(X.result))};else if($==="open_cursor")return{type:"open_cursor"};else if($==="close_cursor")return{type:"close_cursor"};else if($==="fetch_cursor"){let J=b(X.entries,o2),Z=z1(X.done);return{type:"fetch_cursor",entries:J,done:Z}}else if($==="sequence")return{type:"sequence"};else if($==="describe")return{type:"describe",result:e2(y(X.result))};else if($==="store_sql")return{type:"store_sql"};else if($==="close_sql")return{type:"close_sql"};else if($==="get_autocommit")return{type:"get_autocommit",isAutocommit:z1(X.is_autocommit)};else throw new Q("Unexpected type of Response")}var u={default(){return{message:"",code:void 0}},1(X,$){$.message=X.string()},2(X,$){$.code=X.string()}},Q1={default(){return{cols:[],rows:[],affectedRowCount:0,lastInsertRowid:void 0}},1(X,$){$.cols.push(X.message(j4))},2(X,$){$.rows.push(X.message(F4))},3(X,$){$.affectedRowCount=Number(X.uint64())},4(X,$){$.lastInsertRowid=X.sint64()}},j4={default(){return{name:void 0,decltype:void 0}},1(X,$){$.name=X.string()},2(X,$){$.decltype=X.string()}},F4={default(){return[]},1(X,$){$.push(X.message(OJ))}},r1={default(){return{stepResults:new Map,stepErrors:new Map}},1(X,$){let[J,Z]=X.message(_J);$.stepResults.set(J,Z)},2(X,$){let[J,Z]=X.message(RJ);$.stepErrors.set(J,Z)}},_J={default(){return[0,Q1.default()]},1(X,$){$[0]=X.uint32()},2(X,$){$[1]=X.message(Q1)}},RJ={default(){return[0,u.default()]},1(X,$){$[0]=X.uint32()},2(X,$){$[1]=X.message(u)}},X0={default(){return{type:"none"}},1(X){return X.message(NJ)},2(X){return X.message(AJ)},3(X){return X.message(QJ)},4(X){return{type:"row",row:X.message(F4)}},5(X){return{type:"error",error:X.message(u)}}},NJ={default(){return{type:"step_begin",step:0,cols:[]}},1(X,$){$.step=X.uint32()},2(X,$){$.cols.push(X.message(j4))}},AJ={default(){return{type:"step_end",affectedRowCount:0,lastInsertRowid:void 0}},1(X,$){$.affectedRowCount=X.uint32()},2(X,$){$.lastInsertRowid=X.uint64()}},QJ={default(){return{type:"step_error",step:0,error:u.default()}},1(X,$){$.step=X.uint32()},2(X,$){$.error=X.message(u)}},a1={default(){return{params:[],cols:[],isExplain:!1,isReadonly:!1}},1(X,$){$.params.push(X.message(IJ))},2(X,$){$.cols.push(X.message(VJ))},3(X,$){$.isExplain=X.bool()},4(X,$){$.isReadonly=X.bool()}},IJ={default(){return{name:void 0}},1(X,$){$.name=X.string()}},VJ={default(){return{name:"",decltype:void 0}},1(X,$){$.name=X.string()},2(X,$){$.decltype=X.string()}},OJ={default(){return},1(X){return null},2(X){return X.sint64()},3(X){return X.double()},4(X){return X.string()},5(X){return X.bytes()}};var T4={default(){return{type:"none"}},1(X){return{type:"hello_ok"}},2(X){return X.message(DJ)},3(X){return X.message(xJ)},4(X){return X.message(HJ)}},DJ={default(){return{type:"hello_error",error:u.default()}},1(X,$){$.error=X.message(u)}},HJ={default(){return{type:"response_error",requestId:0,error:u.default()}},1(X,$){$.requestId=X.int32()},2(X,$){$.error=X.message(u)}},xJ={default(){return{type:"response_ok",requestId:0,response:{type:"none"}}},1(X,$){$.requestId=X.int32()},2(X,$){$.response={type:"open_stream"}},3(X,$){$.response={type:"close_stream"}},4(X,$){$.response=X.message(BJ)},5(X,$){$.response=X.message(UJ)},6(X,$){$.response={type:"open_cursor"}},7(X,$){$.response={type:"close_cursor"}},8(X,$){$.response=X.message(WJ)},9(X,$){$.response={type:"sequence"}},10(X,$){$.response=X.message(jJ)},11(X,$){$.response={type:"store_sql"}},12(X,$){$.response={type:"close_sql"}},13(X,$){$.response=X.message(FJ)}},BJ={default(){return{type:"execute",result:Q1.default()}},1(X,$){$.result=X.message(Q1)}},UJ={default(){return{type:"batch",result:r1.default()}},1(X,$){$.result=X.message(r1)}},WJ={default(){return{type:"fetch_cursor",entries:[],done:!1}},1(X,$){$.entries.push(X.message(X0))},2(X,$){$.done=X.bool()}},jJ={default(){return{type:"describe",result:a1.default()}},1(X,$){$.result=X.message(a1)}},FJ={default(){return{type:"get_autocommit",isAutocommit:!1}},1(X,$){$.isAutocommit=X.bool()}};var M4=new Map([["hrana2",{version:2,encoding:"json"}],["hrana1",{version:1,encoding:"json"}]]),w0=new Map([["hrana3-protobuf",{version:3,encoding:"protobuf"}],["hrana3",{version:3,encoding:"json"}],["hrana2",{version:2,encoding:"json"}],["hrana1",{version:1,encoding:"json"}]]);class $0 extends i1{#X;#$;#J;#Z;#K;#G;#z;#Y;#_;_streamIdAlloc;_cursorIdAlloc;#R;constructor(X,$){super();this.#X=X,this.#$=[],this.#J=!1,this.#Z=void 0,this.#K=!1,this.#G=void 0,this.#z=!1,this.#Y=new Map,this.#_=new R1,this._streamIdAlloc=new R1,this._cursorIdAlloc=new R1,this.#R=new R1,this.#X.binaryType="arraybuffer",this.#X.addEventListener("open",()=>this.#V()),this.#X.addEventListener("close",(J)=>this.#I(J)),this.#X.addEventListener("error",(J)=>this.#O(J)),this.#X.addEventListener("message",(J)=>this.#H(J)),this.#A({type:"hello",jwt:$})}#A(X){if(this.#Z!==void 0)throw new f("Trying to send a message on a closed client");if(this.#J)this.#Q(X);else{let $=()=>this.#Q(X),J=()=>{return};this.#$.push({openCallback:$,errorCallback:J})}}#V(){let X=this.#X.protocol;if(X===void 0){this.#N(new x("The `WebSocket.protocol` property is undefined. This most likely means that the WebSocket implementation provided by the environment is broken. If you are using Miniflare 2, please update to Miniflare 3, which fixes this problem."));return}else if(X==="")this.#G={version:1,encoding:"json"};else if(this.#G=w0.get(X),this.#G===void 0){this.#N(new Q(`Unrecognized WebSocket subprotocol: ${JSON.stringify(X)}`));return}for(let $ of this.#$)$.openCallback();this.#$.length=0,this.#J=!0}#Q(X){let $=this.#G.encoding;if($==="json"){let J=D2(X,V4);this.#X.send(J)}else if($==="protobuf"){let J=B2(X,x4);this.#X.send(J)}else throw H($,"Impossible encoding")}getVersion(){return new Promise((X,$)=>{if(this.#z=!0,this.#Z!==void 0)$(this.#Z);else if(!this.#J){let J=()=>X(this.#G.version);this.#$.push({openCallback:J,errorCallback:$})}else X(this.#G.version)})}_ensureVersion(X,$){if(this.#G===void 0||!this.#z)throw new p(`${$} is supported only on protocol version ${X} and higher, but the version supported by the WebSocket server is not yet known. Use Client.getVersion() to wait until the version is available.`);else if(this.#G.version<X)throw new p(`${$} is supported on protocol version ${X} and higher, but the WebSocket server only supports version ${this.#G.version}`)}_sendRequest(X,$){if(this.#Z!==void 0){$.errorCallback(new L("Client is closed",this.#Z));return}let J=this.#_.alloc();this.#Y.set(J,{...$,type:X.type}),this.#A({type:"request",requestId:J,request:X})}#O(X){let J=X.message??"WebSocket was closed due to an error";this.#N(new m1(J))}#I(X){let $=`WebSocket was closed with code ${X.code}`;if(X.reason)$+=`: ${X.reason}`;this.#N(new m1($))}#N(X){if(this.#Z!==void 0)return;this.#Z=X;for(let $ of this.#$)$.errorCallback(X);this.#$.length=0;for(let[$,J]of this.#Y.entries())J.errorCallback(X),this.#_.free($);this.#Y.clear(),this.#X.close()}#H(X){if(this.#Z!==void 0)return;try{let $,J=this.#G.encoding;if(J==="json"){if(typeof X.data!=="string"){this.#X.close(3003,"Only text messages are accepted with JSON encoding"),this.#N(new Q("Received non-text message from server with JSON encoding"));return}$=j1(JSON.parse(X.data),W4)}else if(J==="protobuf"){if(!(X.data instanceof ArrayBuffer)){this.#X.close(3003,"Only binary messages are accepted with Protobuf encoding"),this.#N(new Q("Received non-binary message from server with Protobuf encoding"));return}$=_1(new Uint8Array(X.data),T4)}else throw H(J,"Impossible encoding");this.#D($)}catch($){this.#X.close(3007,"Could not handle message"),this.#N($)}}#D(X){if(X.type==="none")throw new Q("Received an unrecognized ServerMsg");else if(X.type==="hello_ok"||X.type==="hello_error"){if(this.#K)throw new Q("Received a duplicated hello response");if(this.#K=!0,X.type==="hello_error")throw o(X.error);return}else if(!this.#K)throw new Q("Received a non-hello message before a hello response");if(X.type==="response_ok"){let $=X.requestId,J=this.#Y.get($);if(this.#Y.delete($),J===void 0)throw new Q("Received unexpected OK response");this.#_.free($);try{if(J.type!==X.response.type)throw console.dir({responseState:J,msg:X}),new Q("Received unexpected type of response");J.responseCallback(X.response)}catch(Z){throw J.errorCallback(Z),Z}}else if(X.type==="response_error"){let $=X.requestId,J=this.#Y.get($);if(this.#Y.delete($),J===void 0)throw new Q("Received unexpected error response");this.#_.free($),J.errorCallback(o(X.error))}else throw H(X,"Impossible ServerMsg type")}openStream(){return F2.open(this)}storeSql(X){this._ensureVersion(2,"storeSql()");let $=this.#R.alloc(),J=new M1(this,$),Z=()=>{return},K=(Y)=>J._setClosed(Y),G={type:"store_sql",sqlId:$,sql:X};return this._sendRequest(G,{responseCallback:Z,errorCallback:K}),J}_closeSql(X){if(this.#Z!==void 0)return;let $=()=>this.#R.free(X),J=(K)=>this.#N(K),Z={type:"close_sql",sqlId:X};this._sendRequest(Z,{responseCallback:$,errorCallback:J})}close(){this.#N(new x("Client was manually closed"))}get closed(){return this.#Z!==void 0}}var y2=Request,h0=Headers,S0=fetch;var L1;if(typeof queueMicrotask<"u")L1=queueMicrotask;else{let X=Promise.resolve();L1=($)=>{X.then($)}}class v0{#X;#$;#J;constructor(X){this.#X=new Uint8Array(new ArrayBuffer(X)),this.#$=0,this.#J=0}get length(){return this.#J-this.#$}data(){return this.#X.slice(this.#$,this.#J)}push(X){this.#Z(X.byteLength),this.#X.set(X,this.#J),this.#J+=X.byteLength}#Z(X){if(this.#J+X<=this.#X.byteLength)return;let $=this.#J-this.#$;if($+X<=this.#X.byteLength&&2*this.#J>=this.#X.byteLength)this.#X.copyWithin(0,this.#$,this.#J);else{let J=this.#X.byteLength;do J*=2;while($+X>J);let Z=new Uint8Array(new ArrayBuffer(J));Z.set(this.#X.slice(this.#$,this.#J),0),this.#X=Z}this.#J=$,this.#$=0}shift(X){this.#$+=X}}function L4(X){let $=h(X.baton),J=h(X.base_url),Z=b(X.results,TJ);return{baton:$,baseUrl:J,results:Z}}function TJ(X){let $=C(X.type);if($==="ok")return{type:"ok",response:MJ(y(X.response))};else if($==="error")return{type:"error",error:A1(y(X.error))};else throw new Q("Unexpected type of StreamResult")}function MJ(X){let $=C(X.type);if($==="close")return{type:"close"};else if($==="execute")return{type:"execute",result:L2(y(X.result))};else if($==="batch")return{type:"batch",result:t2(y(X.result))};else if($==="sequence")return{type:"sequence"};else if($==="describe")return{type:"describe",result:e2(y(X.result))};else if($==="store_sql")return{type:"store_sql"};else if($==="close_sql")return{type:"close_sql"};else if($==="get_autocommit")return{type:"get_autocommit",isAutocommit:z1(X.is_autocommit)};else throw new Q("Unexpected type of StreamResponse")}function y4(X){let $=h(X.baton),J=h(X.base_url);return{baton:$,baseUrl:J}}var P4={default(){return{baton:void 0,baseUrl:void 0,results:[]}},1(X,$){$.baton=X.string()},2(X,$){$.baseUrl=X.string()},3(X,$){$.results.push(X.message(LJ))}},LJ={default(){return{type:"none"}},1(X){return{type:"ok",response:X.message(yJ)}},2(X){return{type:"error",error:X.message(u)}}},yJ={default(){return{type:"none"}},1(X){return{type:"close"}},2(X){return X.message(PJ)},3(X){return X.message(EJ)},4(X){return{type:"sequence"}},5(X){return X.message(qJ)},6(X){return{type:"store_sql"}},7(X){return{type:"close_sql"}},8(X){return X.message(fJ)}},PJ={default(){return{type:"execute",result:Q1.default()}},1(X,$){$.result=X.message(Q1)}},EJ={default(){return{type:"batch",result:r1.default()}},1(X,$){$.result=X.message(r1)}},qJ={default(){return{type:"describe",result:a1.default()}},1(X,$){$.result=X.message(a1)}},fJ={default(){return{type:"get_autocommit",isAutocommit:!1}},1(X,$){$.isAutocommit=X.bool()}},E4={default(){return{baton:void 0,baseUrl:void 0}},1(X,$){$.baton=X.string()},2(X,$){$.baseUrl=X.string()}};class g0 extends j2{#X;#$;#J;#Z;#K;#G;constructor(X,$){super();this.#X=X,this.#$=$,this.#J=void 0,this.#Z=new v0(16384),this.#K=void 0,this.#G=!1}async open(X){if(X.body===null)throw new Q("No response body for cursor request");this.#J=X.body.getReader();let $=await this.#z(y4,E4);if($===void 0)throw new Q("Empty response to cursor request");return $}next(){return this.#z(o2,X0)}close(){this._setClosed(new x("Cursor was manually closed"))}_setClosed(X){if(this.#K!==void 0)return;if(this.#K=X,this.#X._cursorClosed(this),this.#J!==void 0)this.#J.cancel()}get closed(){return this.#K!==void 0}async#z(X,$){for(;;){if(this.#G)return;else if(this.#K!==void 0)throw new L("Cursor is closed",this.#K);if(this.#$==="json"){let K=this.#Y();if(K!==void 0){let G=new TextDecoder().decode(K),Y=JSON.parse(G);return j1(Y,X)}}else if(this.#$==="protobuf"){let K=this.#_();if(K!==void 0)return _1(K,$)}else throw H(this.#$,"Impossible encoding");if(this.#J===void 0)throw new f("Attempted to read from HTTP cursor before it was opened");let{value:J,done:Z}=await this.#J.read();if(Z&&this.#Z.length===0)this.#G=!0;else if(Z)throw new Q("Unexpected end of cursor stream");else this.#Z.push(J)}}#Y(){let X=this.#Z.data(),$=10,J=X.indexOf(10);if(J<0)return;let Z=X.slice(0,J);return this.#Z.shift(J+1),Z}#_(){let X=this.#Z.data(),$=0,J=0;for(;;){if(J>=X.byteLength)return;let K=X[J];if($|=(K&127)<<7*J,J+=1,!(K&128))break}if(X.byteLength<J+$)return;let Z=X.slice(J,J+$);return this.#Z.shift(J+$),Z}}function q4(X,$){if($.baton!==void 0)X.string("baton",$.baton);X.arrayObjects("requests",$.requests,CJ)}function CJ(X,$){if(X.stringRaw("type",$.type),$.type==="close");else if($.type==="execute")X.object("stmt",$.stmt,T2);else if($.type==="batch")X.object("batch",$.batch,c1);else if($.type==="sequence"){if($.sql!==void 0)X.string("sql",$.sql);if($.sqlId!==void 0)X.number("sql_id",$.sqlId)}else if($.type==="describe"){if($.sql!==void 0)X.string("sql",$.sql);if($.sqlId!==void 0)X.number("sql_id",$.sqlId)}else if($.type==="store_sql")X.number("sql_id",$.sqlId),X.string("sql",$.sql);else if($.type==="close_sql")X.number("sql_id",$.sqlId);else if($.type==="get_autocommit");else throw H($,"Impossible type of StreamRequest")}function f4(X,$){if($.baton!==void 0)X.string("baton",$.baton);X.object("batch",$.batch,c1)}function C4(X,$){if($.baton!==void 0)X.string(1,$.baton);for(let J of $.requests)X.message(2,J,wJ)}function wJ(X,$){if($.type==="close")X.message(1,$,hJ);else if($.type==="execute")X.message(2,$,SJ);else if($.type==="batch")X.message(3,$,vJ);else if($.type==="sequence")X.message(4,$,gJ);else if($.type==="describe")X.message(5,$,uJ);else if($.type==="store_sql")X.message(6,$,kJ);else if($.type==="close_sql")X.message(7,$,pJ);else if($.type==="get_autocommit")X.message(8,$,bJ);else throw H($,"Impossible type of StreamRequest")}function hJ(X,$){}function SJ(X,$){X.message(1,$.stmt,M2)}function vJ(X,$){X.message(1,$.batch,s1)}function gJ(X,$){if($.sql!==void 0)X.string(1,$.sql);if($.sqlId!==void 0)X.int32(2,$.sqlId)}function uJ(X,$){if($.sql!==void 0)X.string(1,$.sql);if($.sqlId!==void 0)X.int32(2,$.sqlId)}function kJ(X,$){X.int32(1,$.sqlId),X.string(2,$.sql)}function pJ(X,$){X.int32(1,$.sqlId)}function bJ(X,$){}function w4(X,$){if($.baton!==void 0)X.string(1,$.baton);X.message(2,$.batch,s1)}class J0 extends n1{#X;#$;#J;#Z;#K;#G;#z;#Y;#_;#R;#A;#V;constructor(X,$,J,Z){super(X.intMode);this.#X=X,this.#$=$.toString(),this.#J=J,this.#Z=Z,this.#K=void 0,this.#G=new N1,this.#z=!1,this.#_=!1,this.#R=!1,this.#A=void 0,this.#V=new R1}client(){return this.#X}_sqlOwner(){return this}storeSql(X){let $=this.#V.alloc();return this.#Q({type:"store_sql",sqlId:$,sql:X}).then(()=>{return},(J)=>this._setClosed(J)),new M1(this,$)}_closeSql(X){if(this.#A!==void 0)return;this.#Q({type:"close_sql",sqlId:X}).then(()=>this.#V.free(X),($)=>this._setClosed($))}_execute(X){return this.#Q({type:"execute",stmt:X}).then(($)=>{return $.result})}_batch(X){return this.#Q({type:"batch",batch:X}).then(($)=>{return $.result})}_describe(X){return this.#Q({type:"describe",sql:X.sql,sqlId:X.sqlId}).then(($)=>{return $.result})}_sequence(X){return this.#Q({type:"sequence",sql:X.sql,sqlId:X.sqlId}).then(($)=>{return})}getAutocommit(){return this.#X._ensureVersion(3,"getAutocommit()"),this.#Q({type:"get_autocommit"}).then((X)=>{return X.isAutocommit})}#Q(X){return new Promise(($,J)=>{this.#O({type:"pipeline",request:X,responseCallback:$,errorCallback:J})})}_openCursor(X){return new Promise(($,J)=>{this.#O({type:"cursor",batch:X,cursorCallback:$,errorCallback:J})})}_cursorClosed(X){if(X!==this.#Y)throw new f("Cursor was closed, but it was not associated with the stream");this.#Y=void 0,L1(()=>this.#I())}close(){this._setClosed(new x("Stream was manually closed"))}closeGracefully(){this.#_=!0,L1(()=>this.#I())}get closed(){return this.#A!==void 0||this.#_}_setClosed(X){if(this.#A!==void 0)return;if(this.#A=X,this.#Y!==void 0)this.#Y._setClosed(X);this.#X._streamClosed(this);for(;;){let $=this.#G.shift();if($!==void 0)$.errorCallback(X);else break}if((this.#K!==void 0||this.#z)&&!this.#R)this.#G.push({type:"pipeline",request:{type:"close"},responseCallback:()=>{return},errorCallback:()=>{return}}),this.#R=!0,L1(()=>this.#I())}#O(X){if(this.#A!==void 0)throw new L("Stream is closed",this.#A);else if(this.#_)throw new L("Stream is closing",void 0);else this.#G.push(X),L1(()=>this.#I())}#I(){if(this.#z||this.#Y!==void 0)return;if(this.#_&&this.#G.length===0){this._setClosed(new x("Stream was gracefully closed"));return}let X=this.#X._endpoint;if(X===void 0){this.#X._endpointPromise.then(()=>this.#I(),(J)=>this._setClosed(J));return}let $=this.#G.shift();if($===void 0)return;else if($.type==="pipeline"){let J=[$];for(;;){let Z=this.#G.first();if(Z!==void 0&&Z.type==="pipeline")J.push(Z),this.#G.shift();else if(Z===void 0&&this.#_&&!this.#R){J.push({type:"pipeline",request:{type:"close"},responseCallback:()=>{return},errorCallback:()=>{return}}),this.#R=!0;break}else break}this.#N(X,J)}else if($.type==="cursor")this.#H(X,$);else throw H($,"Impossible type of QueueEntry")}#N(X,$){this.#D(()=>this.#B($,X),(J)=>mJ(J,X.encoding),(J)=>J.baton,(J)=>J.baseUrl,(J)=>iJ($,J),(J)=>$.forEach((Z)=>Z.errorCallback(J)))}#H(X,$){let J=new g0(this,X.encoding);this.#Y=J,this.#D(()=>this.#U($,X),(Z)=>J.open(Z),(Z)=>Z.baton,(Z)=>Z.baseUrl,(Z)=>$.cursorCallback(J),(Z)=>$.errorCallback(Z))}#D(X,$,J,Z,K,G){let Y;try{let _=X(),z=this.#Z;Y=z(_)}catch(_){Y=Promise.reject(_)}this.#z=!0,Y.then((_)=>{if(!_.ok)return dJ(_).then((z)=>{throw z});return $(_)}).then((_)=>{this.#K=J(_),this.#$=Z(_)??this.#$,K(_)}).catch((_)=>{this._setClosed(_),G(_)}).finally(()=>{this.#z=!1,this.#I()})}#B(X,$){return this.#x(new URL($.pipelinePath,this.#$),{baton:this.#K,requests:X.map((J)=>J.request)},$.encoding,q4,C4)}#U(X,$){if($.cursorPath===void 0)throw new p(`Cursors are supported only on protocol version 3 and higher, but the HTTP server only supports version ${$.version}.`);return this.#x(new URL($.cursorPath,this.#$),{baton:this.#K,batch:X.batch},$.encoding,f4,w4)}#x(X,$,J,Z,K){let G,Y;if(J==="json")G=D2($,Z),Y="application/json";else if(J==="protobuf")G=B2($,K),Y="application/x-protobuf";else throw H(J,"Impossible encoding");let _=new h0;if(_.set("content-type",Y),this.#J!==void 0)_.set("authorization",`Bearer ${this.#J}`);return new y2(X.toString(),{method:"POST",headers:_,body:G})}}function iJ(X,$){if($.results.length!==X.length)throw new Q("Server returned unexpected number of pipeline results");for(let J=0;J<X.length;++J){let Z=$.results[J],K=X[J];if(Z.type==="ok"){if(Z.response.type!==K.request.type)throw new Q("Received unexpected type of response");K.responseCallback(Z.response)}else if(Z.type==="error")K.errorCallback(o(Z.error));else if(Z.type==="none")throw new Q("Received unrecognized type of StreamResult");else throw H(Z,"Received impossible type of StreamResult")}}async function mJ(X,$){if($==="json"){let J=await X.json();return j1(J,L4)}if($==="protobuf"){let J=await X.arrayBuffer();return _1(new Uint8Array(J),P4)}throw await X.body?.cancel(),H($,"Impossible encoding")}async function dJ(X){let $=X.headers.get("content-type")??"text/plain",J=`Server returned HTTP status ${X.status}`;if($==="application/json"){let Z=await X.json();if("message"in Z)return o(Z);return new W1(J,X.status)}if($==="text/plain"){let Z=(await X.text()).trim();if(Z!=="")J+=`: ${Z}`;return new W1(J,X.status)}return await X.body?.cancel(),new W1(J,X.status)}var lJ=[{versionPath:"v3-protobuf",pipelinePath:"v3-protobuf/pipeline",cursorPath:"v3-protobuf/cursor",version:3,encoding:"protobuf"}],u0={versionPath:"v2",pipelinePath:"v2/pipeline",cursorPath:void 0,version:2,encoding:"json"};class Z0 extends i1{#X;#$;#J;#Z;#K;_endpointPromise;_endpoint;constructor(X,$,J,Z=2){super();if(this.#X=X,this.#$=$,this.#J=J??S0,this.#Z=void 0,this.#K=new Set,Z==3)this._endpointPromise=nJ(this.#J,this.#X),this._endpointPromise.then((K)=>this._endpoint=K,(K)=>this.#G(K));else this._endpointPromise=Promise.resolve(u0),this._endpointPromise.then((K)=>this._endpoint=K,(K)=>this.#G(K))}async getVersion(){if(this._endpoint!==void 0)return this._endpoint.version;return(await this._endpointPromise).version}_ensureVersion(X,$){if(X<=u0.version)return;else if(this._endpoint===void 0)throw new p(`${$} is supported only on protocol version ${X} and higher, but the version supported by the HTTP server is not yet known. Use Client.getVersion() to wait until the version is available.`);else if(this._endpoint.version<X)throw new p(`${$} is supported only on protocol version ${X} and higher, but the HTTP server only supports version ${this._endpoint.version}.`)}openStream(){if(this.#Z!==void 0)throw new L("Client is closed",this.#Z);let X=new J0(this,this.#X,this.#$,this.#J);return this.#K.add(X),X}_streamClosed(X){this.#K.delete(X)}close(){this.#G(new x("Client was manually closed"))}get closed(){return this.#Z!==void 0}#G(X){if(this.#Z!==void 0)return;this.#Z=X;for(let $ of Array.from(this.#K))$._setClosed(new L("Client was closed",X))}}async function nJ(X,$){let J=X;for(let Z of lJ){let K=new URL(Z.versionPath,$),G=new y2(K.toString(),{method:"GET"}),Y=await J(G);if(await Y.arrayBuffer(),Y.ok)return Z}return u0}function k0(X,$,J=2){if(typeof b1.default>"u")throw new V2("WebSockets are not supported in this environment");var Z=void 0;if(J==3)Z=Array.from(w0.keys());else Z=Array.from(M4.keys());let K=new b1.default(X,Z);return new $0(K,$)}function p0(X,$,J,Z=2){return new Z0(X instanceof URL?X:new URL(X),$,J,Z)}class P2{#X;#$;#J;constructor(X,$){this.#X=X,this.#$=$,this.#J=void 0}execute(X){return this.batch([X]).then(($)=>$[0])}async batch(X){let $=this._getStream();if($.closed)throw new V("Cannot execute statements because the transaction is closed","TRANSACTION_CLOSED");try{let J=X.map(e),Z;if(this.#J===void 0){this._getSqlCache().apply(J);let G=$.batch(this.#$>=3),Y=G.step(),_=Y.run(X1(this.#X)),z=Y;Z=J.map((R)=>{let N=G.step().condition(F.ok(z));if(this.#$>=3)N.condition(F.not(F.isAutocommit(G)));let A=N.query(R);return A.catch(()=>{return}),z=N,A}),this.#J=G.execute().then(()=>_).then(()=>{return});try{await this.#J}catch(R){throw this.close(),R}}else{if(this.#$<3)await this.#J;this._getSqlCache().apply(J);let G=$.batch(this.#$>=3),Y=void 0;Z=J.map((_)=>{let z=G.step();if(Y!==void 0)z.condition(F.ok(Y));if(this.#$>=3)z.condition(F.not(F.isAutocommit(G)));let R=z.query(_);return R.catch(()=>{return}),Y=z,R}),await G.execute()}let K=[];for(let G of Z){let Y=await G;if(Y===void 0)throw new V("Statement in a transaction was not executed, probably because the transaction has been rolled back","TRANSACTION_CLOSED");K.push(o1(Y))}return K}catch(J){throw T(J)}}async executeMultiple(X){let $=this._getStream();if($.closed)throw new V("Cannot execute statements because the transaction is closed","TRANSACTION_CLOSED");try{if(this.#J===void 0){this.#J=$.run(X1(this.#X)).then(()=>{return});try{await this.#J}catch(J){throw this.close(),J}}else await this.#J;await $.sequence(X)}catch(J){throw T(J)}}async rollback(){try{let X=this._getStream();if(X.closed)return;if(this.#J!==void 0);else return;let $=X.run("ROLLBACK").catch((J)=>{throw T(J)});X.closeGracefully(),await $}catch(X){throw T(X)}finally{this.close()}}async commit(){try{let X=this._getStream();if(X.closed)throw new V("Cannot commit the transaction because it is already closed","TRANSACTION_CLOSED");if(this.#J!==void 0)await this.#J;else return;let $=X.run("COMMIT").catch((J)=>{throw T(J)});X.closeGracefully(),await $}catch(X){throw T(X)}finally{this.close()}}}async function t1(X,$,J,Z,K=!1){if(K)J.step().run("PRAGMA foreign_keys=off");let G=J.step(),Y=G.run(X1(X)),_=G,z=Z.map((j)=>{let D=J.step().condition(F.ok(_));if($>=3)D.condition(F.not(F.isAutocommit(J)));let I=D.query(j);return _=D,I}),R=J.step().condition(F.ok(_));if($>=3)R.condition(F.not(F.isAutocommit(J)));let N=R.run("COMMIT");if(J.step().condition(F.not(F.ok(R))).run("ROLLBACK").catch((j)=>{return}),K)J.step().run("PRAGMA foreign_keys=on");await J.execute();let B=[];await Y;for(let j of z){let D=await j;if(D===void 0)throw new V("Statement in a batch was not executed, probably because the transaction has been rolled back","TRANSACTION_CLOSED");B.push(o1(D))}return await N,B}function e(X){let $,J;if(Array.isArray(X))[$,J]=X;else if(typeof X==="string")$=X;else $=X.sql,J=X.args;let Z=new W2($);if(J)if(Array.isArray(J))Z.bindIndexes(J);else for(let[K,G]of Object.entries(J))Z.bindName(K,G);return Z}function o1(X){let $=X.columnNames.map((Y)=>Y??""),J=X.columnDecltypes.map((Y)=>Y??""),Z=X.rows,K=X.affectedRowCount,G=X.lastInsertRowid!==void 0?X.lastInsertRowid:void 0;return new f1($,J,Z,K,G)}function T(X){if(X instanceof x){let $=h4(X);return new V(X.message,$,void 0,X)}return X}function h4(X){if(X instanceof I2&&X.code!==void 0)return X.code;else if(X instanceof Q)return"HRANA_PROTO_ERROR";else if(X instanceof L)return X.cause instanceof x?h4(X.cause):"HRANA_CLOSED_ERROR";else if(X instanceof m1)return"HRANA_WEBSOCKET_ERROR";else if(X instanceof W1)return"SERVER_ERROR";else if(X instanceof p)return"PROTOCOL_VERSION_ERROR";else if(X instanceof f)return"INTERNAL_ERROR";else return"UNKNOWN"}class e1{#X;#$;capacity;constructor(X,$){this.#X=X,this.#$=new S4,this.capacity=$}apply(X){if(this.capacity<=0)return;let $=new Set;for(let J of X){if(typeof J.sql!=="string")continue;let Z=J.sql;if(Z.length>=5000)continue;let K=this.#$.get(Z);if(K===void 0){while(this.#$.size+1>this.capacity){let[G,Y]=this.#$.peekLru();if($.has(Y))break;Y.close(),this.#$.delete(G)}if(this.#$.size+1<=this.capacity)K=this.#X.storeSql(Z),this.#$.set(Z,K)}if(K!==void 0)J.sql=K,$.add(K)}}}class S4{#X;constructor(){this.#X=new Map}get(X){let $=this.#X.get(X);if($!==void 0)this.#X.delete(X),this.#X.set(X,$);return $}set(X,$){this.#X.set(X,$)}peekLru(){for(let X of this.#X.entries())return X;return}delete(X){this.#X.delete(X)}get size(){return this.#X.size}}var k4=J1(i0(),1);function p4(X){if(X.scheme!=="wss"&&X.scheme!=="ws")throw new V(`The WebSocket client supports only "libsql:", "wss:" and "ws:" URLs, got ${JSON.stringify(X.scheme+":")}. For more information, please read ${i}`,"URL_SCHEME_NOT_SUPPORTED");if(X.encryptionKey!==void 0)throw new V("Encryption key is not supported by the remote client.","ENCRYPTION_KEY_NOT_SUPPORTED");if(X.scheme==="ws"&&X.tls)throw new V('A "ws:" URL cannot opt into TLS by using ?tls=1',"URL_INVALID");else if(X.scheme==="wss"&&!X.tls)throw new V('A "wss:" URL cannot opt out of TLS by using ?tls=0',"URL_INVALID");let $=$2(X.scheme,X.authority,X.path),J;try{J=k0($,X.authToken)}catch(Z){if(Z instanceof V2){let K=X.scheme==="wss"?"https":"http",G=$2(K,X.authority,X.path);throw new V(`This environment does not support WebSockets, please switch to the HTTP client by using a "${K}:" URL (${JSON.stringify(G)}). For more information, please read ${i}`,"WEBSOCKETS_NOT_SUPPORTED")}throw T(Z)}return new b4(J,$,X.authToken,X.intMode,X.concurrency)}var rJ=60000,u4=100;class b4{#X;#$;#J;#Z;#K;closed;protocol;#G;#z;constructor(X,$,J,Z,K){this.#X=$,this.#$=J,this.#J=Z,this.#Z=this.#_(X),this.#K=void 0,this.closed=!1,this.protocol="ws",this.#z=k4.default(K)}async limit(X){return this.#z(X)}async execute(X,$){let J;if(typeof X==="string")J={sql:X,args:$||[]};else J=X;return this.limit(async()=>{let Z=await this.#Y();try{let K=e(J);Z.conn.sqlCache.apply([K]);let G=Z.stream.query(K);Z.stream.closeGracefully();let Y=await G;return o1(Y)}catch(K){throw T(K)}finally{this._closeStream(Z)}})}async batch(X,$="deferred"){return this.limit(async()=>{let J=await this.#Y();try{let K=X.map((R)=>{if(Array.isArray(R))return{sql:R[0],args:R[1]||[]};return R}).map(e),G=await J.conn.client.getVersion();J.conn.sqlCache.apply(K);let Y=J.stream.batch(G>=3);return await t1($,G,Y,K)}catch(Z){throw T(Z)}finally{this._closeStream(J)}})}async migrate(X){return this.limit(async()=>{let $=await this.#Y();try{let J=X.map(e),Z=await $.conn.client.getVersion(),K=$.stream.batch(Z>=3);return await t1("deferred",Z,K,J,!0)}catch(J){throw T(J)}finally{this._closeStream($)}})}async transaction(X="write"){return this.limit(async()=>{let $=await this.#Y();try{let J=await $.conn.client.getVersion();return new i4(this,$,X,J)}catch(J){throw this._closeStream($),T(J)}})}async executeMultiple(X){return this.limit(async()=>{let $=await this.#Y();try{let J=$.stream.sequence(X);$.stream.closeGracefully(),await J}catch(J){throw T(J)}finally{this._closeStream($)}})}sync(){throw new V("sync not supported in ws mode","SYNC_NOT_SUPPORTED")}async#Y(){if(this.closed)throw new V("The client is closed","CLIENT_CLOSED");if(new Date().valueOf()-this.#Z.openTime.valueOf()>rJ&&this.#K===void 0){let Z=this.#_();this.#K=Z,Z.client.getVersion().then((K)=>{if(this.#Z!==Z){if(this.#Z.streamStates.size===0)this.#Z.client.close()}this.#Z=Z,this.#K=void 0},(K)=>{this.#K=void 0})}if(this.#Z.client.closed)try{if(this.#K!==void 0)this.#Z=this.#K;else this.#Z=this.#_()}catch(Z){throw T(Z)}let J=this.#Z;try{if(J.useSqlCache===void 0){if(J.useSqlCache=await J.client.getVersion()>=2,J.useSqlCache)J.sqlCache.capacity=u4}let Z=J.client.openStream();Z.intMode=this.#J;let K={conn:J,stream:Z};return J.streamStates.add(K),K}catch(Z){throw T(Z)}}#_(X){try{return X??=k0(this.#X,this.#$),{client:X,useSqlCache:void 0,sqlCache:new e1(X,0),openTime:new Date,streamStates:new Set}}catch($){throw T($)}}async reconnect(){try{for(let J of Array.from(this.#Z.streamStates))try{J.stream.close()}catch{}this.#Z.client.close()}catch{}if(this.#K){try{this.#K.client.close()}catch{}this.#K=void 0}let X=this.#_(),$=await X.client.getVersion();if(X.useSqlCache=$>=2,X.useSqlCache)X.sqlCache.capacity=u4;this.#Z=X,this.closed=!1}_closeStream(X){X.stream.close();let $=X.conn;if($.streamStates.delete(X),$.streamStates.size===0&&$!==this.#Z)$.client.close()}close(){if(this.#Z.client.close(),this.closed=!0,this.#K){try{this.#K.client.close()}catch{}this.#K=void 0}this.closed=!0}}class i4 extends P2{#X;#$;constructor(X,$,J,Z){super(J,Z);this.#X=X,this.#$=$}_getStream(){return this.#$.stream}_getSqlCache(){return this.#$.conn.sqlCache}close(){this.#X._closeStream(this.#$)}get closed(){return this.#$.stream.closed}}var m4=J1(i0(),1);function d4(X){if(X.scheme!=="https"&&X.scheme!=="http")throw new V(`The HTTP client supports only "libsql:", "https:" and "http:" URLs, got ${JSON.stringify(X.scheme+":")}. For more information, please read ${i}`,"URL_SCHEME_NOT_SUPPORTED");if(X.encryptionKey!==void 0)throw new V("Encryption key is not supported by the remote client.","ENCRYPTION_KEY_NOT_SUPPORTED");if(X.scheme==="http"&&X.tls)throw new V('A "http:" URL cannot opt into TLS by using ?tls=1',"URL_INVALID");else if(X.scheme==="https"&&!X.tls)throw new V('A "https:" URL cannot opt out of TLS by using ?tls=0',"URL_INVALID");let $=$2(X.scheme,X.authority,X.path);return new n4($,X.authToken,X.intMode,X.fetch,X.concurrency)}var l4=30;class n4{#X;protocol;#$;#J;#Z;#K;#G;#z;constructor(X,$,J,Z,K){this.#$=X,this.#G=$,this.#J=J,this.#Z=Z,this.#K=K,this.#X=p0(this.#$,this.#G,this.#Z),this.#X.intMode=this.#J,this.protocol="http",this.#z=m4.default(this.#K)}async limit(X){return this.#z(X)}async execute(X,$){let J;if(typeof X==="string")J={sql:X,args:$||[]};else J=X;return this.limit(async()=>{try{let Z=e(J),K,G=this.#X.openStream();try{K=G.query(Z)}finally{G.closeGracefully()}let Y=await K;return o1(Y)}catch(Z){throw T(Z)}})}async batch(X,$="deferred"){return this.limit(async()=>{try{let Z=X.map((z)=>{if(Array.isArray(z))return{sql:z[0],args:z[1]||[]};return z}).map(e),K=await this.#X.getVersion(),G,Y=this.#X.openStream();try{new e1(Y,l4).apply(Z);let R=Y.batch(!1);G=t1($,K,R,Z)}finally{Y.closeGracefully()}return await G}catch(J){throw T(J)}})}async migrate(X){return this.limit(async()=>{try{let $=X.map(e),J=await this.#X.getVersion(),Z,K=this.#X.openStream();try{let Y=K.batch(!1);Z=t1("deferred",J,Y,$,!0)}finally{K.closeGracefully()}return await Z}catch($){throw T($)}})}async transaction(X="write"){return this.limit(async()=>{try{let $=await this.#X.getVersion();return new c4(this.#X.openStream(),X,$)}catch($){throw T($)}})}async executeMultiple(X){return this.limit(async()=>{try{let $,J=this.#X.openStream();try{$=J.sequence(X)}finally{J.closeGracefully()}await $}catch($){throw T($)}})}sync(){throw new V("sync not supported in http mode","SYNC_NOT_SUPPORTED")}close(){this.#X.close()}async reconnect(){try{if(!this.closed)this.#X.close()}finally{this.#X=p0(this.#$,this.#G,this.#Z),this.#X.intMode=this.#J}}get closed(){return this.#X.closed}}class c4 extends P2{#X;#$;constructor(X,$,J){super($,J);this.#X=X,this.#$=new e1(X,l4)}_getStream(){return this.#X}_getSqlCache(){return this.#$}close(){this.#X.close()}get closed(){return this.#X.closed}}function s4(X){return aJ(Z2(X,!0))}function aJ(X){if(X.scheme==="wss"||X.scheme==="ws")return p4(X);else if(X.scheme==="https"||X.scheme==="http")return d4(X);else return o6(X)}class tJ{client;dbPath;constructor(){let X=m0.join(process.cwd(),".sylphx-flow");if(!K0.existsSync(X))K0.mkdirSync(X,{recursive:!0});this.dbPath=m0.join(X,"memory.db"),this.client=s4({url:`file:${this.dbPath}`}),this.initializeTables()}async initializeTables(){await this.client.execute(`
      CREATE TABLE IF NOT EXISTS memory (
        key TEXT NOT NULL,
        namespace TEXT NOT NULL DEFAULT 'default',
        value TEXT NOT NULL,
        timestamp INTEGER NOT NULL,
        created_at TEXT NOT NULL,
        updated_at TEXT NOT NULL,
        PRIMARY KEY (key, namespace)
      )
    `),await this.client.execute(`
      CREATE INDEX IF NOT EXISTS idx_memory_namespace ON memory(namespace);
    `),await this.client.execute(`
      CREATE INDEX IF NOT EXISTS idx_memory_timestamp ON memory(timestamp);
    `),await this.client.execute(`
      CREATE INDEX IF NOT EXISTS idx_memory_key ON memory(key);
    `)}serializeValue(X){return JSON.stringify(X)}deserializeValue(X){try{return JSON.parse(X)}catch{return X}}async set(X,$,J="default"){let Z=new Date,K=Z.getTime(),G=Z.toISOString(),Y=G,_=this.serializeValue($);if(await this.get(X,J))await this.client.execute({sql:`
        UPDATE memory 
        SET value = ?, timestamp = ?, updated_at = ?
        WHERE key = ? AND namespace = ?
      `,args:[_,K,Y,X,J]});else await this.client.execute({sql:`
        INSERT INTO memory (key, namespace, value, timestamp, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?, ?)
      `,args:[X,J,_,K,G,Y]})}async get(X,$="default"){let Z=await this.client.execute({sql:`
      SELECT key, namespace, value, timestamp, created_at, updated_at
      FROM memory
      WHERE key = ? AND namespace = ?
    `,args:[X,$]});if(Z.rows.length===0)return null;let K=Z.rows[0];return{key:K.key,namespace:K.namespace,value:this.deserializeValue(K.value),timestamp:K.timestamp,created_at:K.created_at,updated_at:K.updated_at}}async getAll(){return(await this.client.execute(`
      SELECT key, namespace, value, timestamp, created_at, updated_at
      FROM memory
      ORDER BY timestamp DESC
    `)).rows.map((J)=>({key:J.key,namespace:J.namespace,value:this.deserializeValue(J.value),timestamp:J.timestamp,created_at:J.created_at,updated_at:J.updated_at}))}async search(X,$){let J=X.replace(/\*/g,"%"),Z=`
      SELECT key, namespace, value, timestamp, created_at, updated_at
      FROM memory
      WHERE key LIKE ? OR value LIKE ?
    `,K=[J,J];if($&&$!=="all")Z+=" AND namespace = ?",K.push($);return Z+=" ORDER BY timestamp DESC",(await this.client.execute({sql:Z,args:K})).rows.map((Y)=>({key:Y.key,namespace:Y.namespace,value:this.deserializeValue(Y.value),timestamp:Y.timestamp,created_at:Y.created_at,updated_at:Y.updated_at}))}async delete(X,$="default"){return(await this.client.execute({sql:`
      DELETE FROM memory
      WHERE key = ? AND namespace = ?
    `,args:[X,$]})).rowsAffected>0}async clear(X){if(X&&X!=="all")await this.client.execute({sql:"DELETE FROM memory WHERE namespace = ?",args:[X]});else await this.client.execute("DELETE FROM memory")}async getStats(){let $=(await this.client.execute("SELECT COUNT(*) as count FROM memory")).rows[0].count,J=await this.client.execute(`
      SELECT namespace, COUNT(*) as count
      FROM memory
      GROUP BY namespace
      ORDER BY namespace
    `),Z=J.rows.map((R)=>R.namespace),K={};J.rows.forEach((R)=>{K[R.namespace]=R.count});let Y=(await this.client.execute(`
      SELECT 
        MIN(created_at) as oldest,
        MAX(created_at) as newest
      FROM memory
    `)).rows[0],_=Y.oldest,z=Y.newest;return{totalEntries:$,namespaces:Z,namespaceCounts:K,oldestEntry:_,newestEntry:z}}async load(){let X=await this.getAll(),$={};return X.forEach((J)=>{if(!$[J.namespace])$[J.namespace]={};$[J.namespace][J.key]=J.value}),{namespaces:$}}async close(){}getDatabasePath(){return this.dbPath}}
export{tJ as c};
