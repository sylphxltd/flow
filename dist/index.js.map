{"version":3,"sources":["../src/cli.ts","../src/utils/command-builder.ts","../src/utils/error-handler.ts","../src/utils/help.ts","../src/core/sync.ts","../src/commands/sync-command.ts","../src/core/install.ts","../src/shared.ts","../src/utils/mcp-config.ts","../src/utils/jsonc.ts","../src/commands/install-command.ts","../src/commands/mcp-command.ts","../index.ts"],"sourcesContent":["import { Command } from 'commander';\nimport { createCommand } from './utils/command-builder.js';\nimport { showDefaultHelp } from './utils/help.js';\nimport { syncCommand } from './commands/sync-command.js';\nimport { installCommand } from './commands/install-command.js';\nimport { mcpCommand } from './commands/mcp-command.js';\n\nexport function createCLI(): Command {\n  const program = new Command();\n\n  program\n    .name('sylphx-flow')\n    .description('Sylphx Flow - Type-safe development flow CLI')\n    .version('1.0.0');\n\n  const commands = [syncCommand, installCommand, mcpCommand];\n  \n  commands.forEach(commandConfig => {\n    program.addCommand(createCommand(commandConfig));\n  });\n\n  program.action(() => {\n    showDefaultHelp();\n  });\n\n  return program;\n}\n\nexport function runCLI(): void {\n  const program = createCLI();\n  \n  if (process.argv.length === 2) {\n    program.help();\n  }\n  \n  program.parse();\n}","import { Command } from 'commander';\nimport { CommandConfig, CommandOptions } from '../types.js';\nimport { createAsyncHandler } from './error-handler.js';\n\nexport function createCommand(config: CommandConfig): Command {\n  const command = new Command(config.name);\n  \n  command.description(config.description);\n  \n  config.options.forEach(option => {\n    command.option(option.flags, option.description);\n  });\n  \n  const handler = createAsyncHandler(config.handler, config.name);\n  command.action(handler);\n  \n  if (config.validator) {\n    command.action((options: CommandOptions) => {\n      config.validator!(options);\n      return handler(options);\n    });\n  }\n  \n  return command;\n}\n\nexport const COMMON_OPTIONS = [\n  { flags: '--agent <type>', description: 'Force specific agent' },\n  { flags: '--verbose', description: 'Show detailed output' },\n  { flags: '--dry-run', description: 'Show what would be done without making changes' },\n  { flags: '--clear', description: 'Clear obsolete items before processing' },\n  { flags: '--merge', description: 'Merge all items into a single file' },\n  { flags: '--mcp [servers...]', description: 'Install MCP servers (memory, everything)' }\n] as const;","export class CLIError extends Error {\n  constructor(message: string, public code?: string) {\n    super(message);\n    this.name = 'CLIError';\n  }\n}\n\nexport function handleError(error: unknown, context?: string): never {\n  const message = error instanceof Error ? error.message : String(error);\n  const contextMsg = context ? ` (${context})` : '';\n  \n  console.error(`‚ùå Error${contextMsg}: ${message}`);\n  \n  if (error instanceof CLIError && error.code) {\n    console.error(`   Code: ${error.code}`);\n  }\n  \n  process.exit(1);\n}\n\nexport function createAsyncHandler<T extends Record<string, any>>(\n  handler: (options: T) => Promise<void>,\n  context?: string\n) {\n  return async (options: T): Promise<void> => {\n    try {\n      await handler(options);\n    } catch (error) {\n      handleError(error, context);\n    }\n  };\n}","export function showDefaultHelp(): void {\n  console.log('üöÄ Sylphx Flow CLI - Type-safe development flow');\n  console.log('=========================================');\n  console.log('');\n  console.log('Available commands:');\n  console.log('  sync     Sync development flow to your project');\n  console.log('  install  Install workflow agents for OpenCode');\n  console.log('  mcp      Start the MCP server');\n  console.log('');\n  console.log('Examples:');\n  console.log('  sylphx-flow sync');\n  console.log('  sylphx-flow mcp');\n  console.log('  sylphx-flow sync --agent cursor');\n  console.log('  sylphx-flow sync --dry-run');\n  console.log('  sylphx-flow sync --clear');\n  console.log('  sylphx-flow sync --merge');\n  console.log('  sylphx-flow install --agent opencode');\n  console.log('');\n  console.log('Run \"sylphx-flow <command> --help\" for more information about a command.');\n}","import * as fs from 'fs';\nimport * as path from 'path';\nimport * as readline from 'readline';\nimport * as cliProgress from 'cli-progress';\nimport Table from 'cli-table3';\nimport { fileURLToPath } from 'url';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\n// Types\ninterface AgentConfig {\n  name: string;\n  dir: string;\n  extension: string;\n  stripYaml: boolean;\n  flatten: boolean;\n  description: string;\n}\n\ninterface ProcessResult {\n  file: string;\n  status: string;\n  action: string;\n}\n\ninterface SyncOptions {\n  agent?: string;\n  verbose?: boolean;\n  dryRun?: boolean;\n  clear?: boolean;\n  merge?: boolean;\n}\n\ntype AgentType = 'cursor' | 'kilocode' | 'roocode';\n\n// Constants\nconst COLORS = {\n  red: '\\x1b[31m',\n  green: '\\x1b[32m',\n  yellow: '\\x1b[33m',\n  blue: '\\x1b[34m',\n  reset: '\\x1b[0m'\n} as const;\n\nconst AGENT_CONFIGS: Record<AgentType, AgentConfig> = {\n  cursor: {\n    name: 'Cursor',\n    dir: '.cursor',\n    extension: '.mdc',\n    stripYaml: false,\n    flatten: false,\n    description: 'Cursor (.cursor/rules/*.mdc with YAML front matter)'\n  },\n  kilocode: {\n    name: 'Kilocode',\n    dir: '.kilocode',\n    extension: '.md',\n    stripYaml: true,\n    flatten: true,\n    description: 'Kilocode (.kilocode/rules/*.md without YAML front matter, flattened with category prefix)'\n  },\n  roocode: {\n    name: 'RooCode',\n    dir: '.roo',\n    extension: '.md',\n    stripYaml: true,\n    flatten: true,\n    description: 'RooCode (.roo/rules/*.md without YAML front matter, flattened with category prefix)'\n  }\n};\n\nconst BATCH_SIZE = 5;\nconst RULES_DIR_NAME = 'rules';\n\n// Global state\nlet results: ProcessResult[] = [];\n\n// Utility functions\nconst log = (message: string, color: keyof typeof COLORS = 'reset'): void => {\n  console.log(`${COLORS[color]}${message}${COLORS.reset}`);\n};\n\nconst getSupportedAgents = (): AgentType[] => Object.keys(AGENT_CONFIGS) as AgentType[];\nconst getAgentConfig = (agent: AgentType): AgentConfig => AGENT_CONFIGS[agent];\n\n// ============================================================================\n// USER INTERACTION\n// ============================================================================\n\nasync function promptForAgent(): Promise<AgentType> {\n  const agents = getSupportedAgents();\n  const rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n  });\n\n  return new Promise((resolve) => {\n    console.log('\\nüöÄ Rules Sync Tool');\n    console.log('================');\n    console.log('Please select your AI agent:');\n    console.log('');\n\n    agents.forEach((agent, index) => {\n      const config = getAgentConfig(agent);\n      console.log(`${index + 1}. ${config.name} - ${config.description}`);\n    });\n\n    console.log('');\n\n    const askChoice = () => {\n      rl.question('Enter your choice (1-' + agents.length + '): ', (answer) => {\n        const choice = parseInt(answer.trim());\n        if (choice >= 1 && choice <= agents.length) {\n          rl.close();\n          resolve(agents[choice - 1]);\n        } else {\n          console.log(`‚ùå Invalid choice. Please enter a number between 1 and ${agents.length}.`);\n          askChoice();\n        }\n      });\n    };\n\n    askChoice();\n  });\n}\n\nfunction detectAgentTool(): AgentType {\n  const cwd = process.cwd();\n\n  // Check for explicit --agent argument (highest priority)\n  const agentArg = process.argv.find(arg => arg.startsWith('--agent='));\n  if (agentArg) {\n    const agent = agentArg.split('=')[1].toLowerCase() as AgentType;\n    if (getSupportedAgents().includes(agent)) {\n      return agent;\n    }\n  }\n\n  // Check for existing directories (in order of preference)\n  for (const agent of getSupportedAgents()) {\n    const config = getAgentConfig(agent);\n    if (fs.existsSync(path.join(cwd, config.dir))) {\n      return agent;\n    }\n  }\n\n  // Check for existing rules directories\n  for (const agent of getSupportedAgents()) {\n    const config = getAgentConfig(agent);\n    if (fs.existsSync(path.join(cwd, config.dir, RULES_DIR_NAME))) {\n      return agent;\n    }\n  }\n\n  // Default to Cursor if can't detect\n  return 'cursor';\n}\n\n// ============================================================================\n// FILE OPERATIONS\n// ============================================================================\n\nfunction getLocalFileInfo(filePath: string): { content: string; exists: true } | null {\n  try {\n    if (!fs.existsSync(filePath)) {\n      return null;\n    }\n    const content = fs.readFileSync(filePath, 'utf8');\n    return { content, exists: true };\n  } catch {\n    return null;\n  }\n}\n\nasync function getRuleFiles(): Promise<string[]> {\n  // Handle both development and built environments\n  const scriptDir = __dirname;\n  let projectRoot: string;\n  \n  // Check if we're in a built environment (dist/src/core)\n  if (scriptDir.includes('/dist/src/')) {\n    // Go up from dist/src/core to project root\n    projectRoot = path.resolve(scriptDir, '../../..');\n  } else {\n    // Development environment, go up from src/core to project root\n    projectRoot = path.resolve(scriptDir, '..');\n  }\n  \n  const docsRulesDir = path.join(projectRoot, 'docs', RULES_DIR_NAME);\n  const files: string[] = [];\n\n  const collectFiles = (dir: string, relativePath: string): void => {\n    try {\n      const items = fs.readdirSync(dir, { withFileTypes: true });\n      for (const item of items) {\n        const itemPath = path.join(dir, item.name);\n        const itemRelative = path.join(relativePath, item.name);\n        if (item.isDirectory()) {\n          collectFiles(itemPath, itemRelative);\n        } else if (item.isFile() && (item.name.endsWith('.mdc') || item.name.endsWith('.md'))) {\n          files.push(itemRelative);\n        }\n      }\n    } catch {\n      // Skip directories/files that can't be read\n    }\n  };\n\n  try {\n    collectFiles(docsRulesDir, RULES_DIR_NAME);\n  } catch {\n    console.warn('‚ö†Ô∏è  Could not read local rules directory, returning empty list');\n    return [];\n  }\n\n  return files;\n}\n\nfunction stripYamlFrontMatter(content: string): string {\n  const lines = content.split('\\n');\n  if (lines.length > 0 && lines[0].trim() === '---') {\n    for (let i = 1; i < lines.length; i++) {\n      if (lines[i].trim() === '---') {\n        return lines.slice(i + 1).join('\\n').trim();\n      }\n    }\n  }\n  return content;\n}\n\nfunction getDescriptionForFile(filePath?: string): string {\n  if (!filePath) return 'Development flow';\n  const baseName = path.basename(filePath, path.extname(filePath));\n  return `Development flow for ${baseName.replace(/-/g, ' ')}`;\n}\n\nfunction createContentProcessor(config: AgentConfig) {\n  return (content: string, filePath?: string): string => {\n    if (config.stripYaml) {\n      return stripYamlFrontMatter(content);\n    } else {\n      // For Cursor, add YAML front matter\n      const yamlFrontMatter = `---\ndescription: ${getDescriptionForFile(filePath)}\nglobs: [\"**/*\"]\nalwaysApply: true\n---\n\n`;\n      return yamlFrontMatter + content;\n    }\n  };\n}\n\nfunction getDestinationPath(filePath: string, rulesDir: string, config: AgentConfig): { relativePath: string; destPath: string; targetDir?: string } {\n  const relativeToRules = filePath.substring(`${RULES_DIR_NAME}/`.length);\n  const parsedPath = path.parse(relativeToRules);\n  const { name: baseName, dir } = parsedPath;\n\n  if (config.flatten) {\n    const flattenedName = dir ? `${dir.replace(/[\\/\\\\]/g, '-')}-${baseName}` : baseName;\n    const relativePath = `${flattenedName}${config.extension}`;\n    return { relativePath, destPath: path.join(rulesDir, relativePath) };\n  } else {\n    const targetDir = dir ? path.join(rulesDir, dir) : rulesDir;\n    const relativePath = path.join(dir, `${baseName}${config.extension}`);\n    return { relativePath, destPath: path.join(targetDir, `${baseName}${config.extension}`), targetDir };\n  }\n}\n\n// ============================================================================\n// FILE PROCESSING\n// ============================================================================\n\nasync function processFile(\n  filePath: string,\n  rulesDir: string,\n  config: AgentConfig,\n  processContent: (content: string, filePath?: string) => string,\n  progressBar: InstanceType<typeof cliProgress.SingleBar>\n): Promise<boolean> {\n  try {\n    const { relativePath, destPath, targetDir } = getDestinationPath(filePath, rulesDir, config);\n    \n    // Create directory if needed for non-flattened structure\n    if (targetDir && !fs.existsSync(targetDir)) {\n      fs.mkdirSync(targetDir, { recursive: true });\n    }\n\n    const localInfo = getLocalFileInfo(destPath);\n    const isNew = !localInfo;\n\n    // Read content from local package files\n    // Handle both development and built environments\n    let projectRoot: string;\n    if (__dirname.includes('/dist/src/')) {\n      // Go up from dist/src/core to project root\n      projectRoot = path.resolve(__dirname, '../../..');\n    } else {\n      // Development environment, go up from src/core to project root\n      projectRoot = path.resolve(__dirname, '..');\n    }\n    const sourcePath = path.join(projectRoot, 'docs', filePath);\n    let content = fs.readFileSync(sourcePath, 'utf8');\n    content = processContent(content, filePath);\n\n    const localProcessed = localInfo ? processContent(localInfo.content, filePath) : '';\n    const contentChanged = !localInfo || localProcessed !== content;\n\n    if (contentChanged) {\n      fs.writeFileSync(destPath, content, 'utf8');\n    }\n\n    results.push({\n      file: relativePath,\n      status: contentChanged ? (isNew ? 'added' : 'updated') : 'current',\n      action: contentChanged ? (isNew ? 'Added' : 'Updated') : 'Already current'\n    });\n\n    progressBar.increment();\n    return contentChanged;\n  } catch (error: any) {\n    results.push({\n      file: filePath,\n      status: 'error',\n      action: `Error: ${error.message}`\n    });\n    progressBar.increment();\n    return false;\n  }\n}\n\nasync function processBatch(\n  batch: string[],\n  rulesDir: string,\n  config: AgentConfig,\n  processContent: (content: string, filePath?: string) => string,\n  progressBar: InstanceType<typeof cliProgress.SingleBar>\n): Promise<void> {\n  const promises = batch.map(filePath =>\n    processFile(filePath, rulesDir, config, processContent, progressBar)\n  );\n  await Promise.all(promises);\n}\n\n// ============================================================================\n// OUTPUT DISPLAY\n// ============================================================================\n\nfunction createStatusTable(title: string, items: ProcessResult[]): void {\n  if (items.length === 0) return;\n\n  console.log(`\\n${title} (${items.length}):`);\n\n  const table = new Table({\n    head: ['File', 'Action'],\n    colWidths: [50, 20],\n    style: { head: ['cyan'], border: ['gray'] },\n    chars: {\n      'top': '‚ïê', 'top-mid': '‚ï§', 'top-left': '‚ïî', 'top-right': '‚ïó',\n      'bottom': '‚ïê', 'bottom-mid': '‚ïß', 'bottom-left': '‚ïö', 'bottom-right': '‚ïù',\n      'left': '‚ïë', 'left-mid': '', 'mid': '', 'mid-mid': '',\n      'right': '‚ïë', 'right-mid': '', 'middle': '‚îÇ'\n    }\n  });\n\n  items.forEach(result => {\n    table.push([\n      result.file.length > 47 ? result.file.substring(0, 47) + '...' : result.file,\n      { content: result.action, vAlign: 'center' }\n    ]);\n  });\n\n  console.log(table.toString());\n}\n\nfunction displayResults(results: ProcessResult[], rulesDir: string, agentName: string): void {\n  const statusGroups = {\n    removed: results.filter(r => r.status === 'removed'),\n    added: results.filter(r => r.status === 'added'),\n    updated: results.filter(r => r.status === 'updated'),\n    current: results.filter(r => r.status === 'current'),\n    errors: results.filter(r => r.status === 'error')\n  };\n\n  console.log('\\nüìä Sync Results:');\n\n  createStatusTable('üóëÔ∏è Removed', statusGroups.removed);\n  createStatusTable('üÜï Added', statusGroups.added);\n  createStatusTable('üîÑ Updated', statusGroups.updated);\n  createStatusTable('‚è≠Ô∏è Already Current', statusGroups.current);\n  if (statusGroups.errors.length > 0) createStatusTable('‚ùå Errors', statusGroups.errors);\n\n  console.log(`\\nüéâ Sync completed!`);\n  console.log(`üìç Location: ${rulesDir}`);\n\n  const summary = [\n    statusGroups.removed.length && `${statusGroups.removed.length} removed`,\n    statusGroups.added.length && `${statusGroups.added.length} added`,\n    statusGroups.updated.length && `${statusGroups.updated.length} updated`,\n    statusGroups.current.length && `${statusGroups.current.length} current`,\n    statusGroups.errors.length && `${statusGroups.errors.length} errors`\n  ].filter(Boolean);\n\n  console.log(`üìà Summary: ${summary.join(', ')}`);\n  console.log(`üí° Rules will be automatically loaded by ${agentName}`);\n}\n\n// ============================================================================\n// CLEAR OBSOLETE FILES\n// ============================================================================\n\nasync function clearObsoleteFiles(rulesDir: string, config: AgentConfig, merge: boolean): Promise<void> {\n  if (!fs.existsSync(rulesDir)) return;\n\n  console.log(`üßπ Clearing obsolete rules in ${rulesDir}...`);\n\n  let expectedFiles: Set<string>;\n\n  if (merge) {\n    expectedFiles = new Set([`all-rules${config.extension}`]);\n  } else {\n    const ruleFiles = await getRuleFiles();\n    expectedFiles = new Set(\n      ruleFiles.map(filePath => {\n        const { relativePath } = getDestinationPath(filePath, rulesDir, config);\n        return relativePath;\n      })\n    );\n  }\n\n  const existingFiles = fs.readdirSync(rulesDir, { recursive: true })\n    .filter((file): file is string => typeof file === 'string' && (file.endsWith('.mdc') || file.endsWith('.md')))\n    .map((file) => path.join(rulesDir, file));\n\n  for (const file of existingFiles) {\n    const relativePath = path.relative(rulesDir, file);\n    if (!expectedFiles.has(relativePath)) {\n      try {\n        fs.unlinkSync(file);\n        results.push({\n          file: relativePath,\n          status: 'removed',\n          action: 'Removed'\n        });\n      } catch (error: any) {\n        results.push({\n          file: relativePath,\n          status: 'error',\n          action: `Error removing: ${error.message}`\n        });\n      }\n    }\n  }\n}\n\n// ============================================================================\n// MERGE FUNCTIONALITY\n// ============================================================================\n\nasync function mergeAllRules(\n  ruleFiles: string[],\n  rulesDir: string,\n  config: AgentConfig,\n  processContent: (content: string, filePath?: string) => string\n): Promise<void> {\n  const mergedFileName = `all-rules${config.extension}`;\n  const mergedFilePath = path.join(rulesDir, mergedFileName);\n\n  console.log(`üìã Merging ${ruleFiles.length} files into ${mergedFileName}...`);\n\n  let mergedContent = `# Development Rules - Complete Collection\\n\\n`;\n  mergedContent += `Generated on: ${new Date().toISOString()}\\n\\n`;\n  mergedContent += `---\\n\\n`;\n\n  for (const filePath of ruleFiles) {\n    try {\n      // Handle both development and built environments\n      let projectRoot: string;\n      if (__dirname.includes('/dist/src/')) {\n        // Go up from dist/src/core to project root\n        projectRoot = path.resolve(__dirname, '../../..');\n      } else {\n        // Development environment, go up from src/core to project root\n        projectRoot = path.resolve(__dirname, '..');\n      }\n      const sourcePath = path.join(projectRoot, 'docs', filePath);\n      let content = fs.readFileSync(sourcePath, 'utf8');\n      content = processContent(content, filePath);\n\n      const relativeToRules = filePath.substring(`${RULES_DIR_NAME}/`.length);\n      const parsedPath = path.parse(relativeToRules);\n      const { name: baseName, dir } = parsedPath;\n\n      const sectionTitle = dir ? `${dir}/${baseName}` : baseName;\n      mergedContent += `## ${sectionTitle.replace(/-/g, ' ').toUpperCase()}\\n\\n`;\n      mergedContent += `${content}\\n\\n`;\n      mergedContent += `---\\n\\n`;\n    } catch (error: any) {\n      results.push({\n        file: filePath,\n        status: 'error',\n        action: `Error reading: ${error.message}`\n      });\n    }\n  }\n\n  const localInfo = getLocalFileInfo(mergedFilePath);\n  const localProcessed = localInfo ? processContent(localInfo.content, 'all-rules') : '';\n  const contentChanged = !localInfo || localProcessed !== mergedContent;\n\n  if (contentChanged) {\n    fs.writeFileSync(mergedFilePath, mergedContent, 'utf8');\n    results.push({\n      file: mergedFileName,\n      status: localInfo ? 'updated' : 'added',\n      action: localInfo ? 'Updated' : 'Created'\n    });\n  } else {\n    results.push({\n      file: mergedFileName,\n      status: 'current',\n      action: 'Already current'\n    });\n  }\n}\n\n// ============================================================================\n// MAIN SYNC FUNCTION\n// ============================================================================\n\nexport async function syncRules(options: SyncOptions): Promise<void> {\n  const cwd = process.cwd();\n  results = [];\n\n  // Determine agent\n  let agent: AgentType;\n  if (options.agent) {\n    agent = options.agent.toLowerCase() as AgentType;\n    if (!getSupportedAgents().includes(agent)) {\n      log(`‚ùå Unknown agent: ${agent}`, 'red');\n      log(`Supported agents: ${getSupportedAgents().join(', ')}`, 'yellow');\n      throw new Error(`Unknown agent: ${agent}`);\n    }\n  } else {\n    const detectedAgent = detectAgentTool();\n    if (detectedAgent !== 'cursor') {\n      agent = detectedAgent;\n      console.log(`üìù Detected agent: ${getAgentConfig(agent).name}`);\n    } else {\n      console.log('üìù No agent detected or defaulting to Cursor.');\n      agent = await promptForAgent();\n    }\n  }\n\n  const config = getAgentConfig(agent);\n  const rulesDir = path.join(cwd, config.dir, RULES_DIR_NAME);\n  const processContent = createContentProcessor(config);\n\n  // Clear obsolete rules if requested\n  if (options.clear) {\n    await clearObsoleteFiles(rulesDir, config, !!options.merge);\n  }\n\n  // Create rules directory\n  fs.mkdirSync(rulesDir, { recursive: true });\n\n  // Get rule files\n  const ruleFiles = await getRuleFiles();\n\n  // Show initial info\n  console.log(`üöÄ Rules Sync Tool`);\n  console.log(`================`);\n  console.log(`üìù Agent: ${config.name}`);\n  console.log(`üìÅ Target: ${rulesDir}`);\n  console.log(`üìã Files: ${ruleFiles.length}`);\n  if (options.merge) {\n    console.log(`üîó Mode: Merge all rules into single file`);\n  }\n  console.log('');\n\n  if (options.dryRun) {\n    console.log('‚úÖ Dry run completed - no files were modified');\n    return;\n  }\n\n  if (options.merge) {\n    await mergeAllRules(ruleFiles, rulesDir, config, processContent);\n  } else {\n    // Setup progress bar\n    const progressBar = new cliProgress.SingleBar({\n      format: 'üìã Processing | {bar} | {percentage}% | {value}/{total} files | {file}',\n      barCompleteChar: '\\u2588',\n      barIncompleteChar: '\\u2591',\n      hideCursor: true\n    });\n\n    progressBar.start(ruleFiles.length, 0, { file: 'Starting...' });\n\n    // Process files in batches\n    for (let i = 0; i < ruleFiles.length; i += BATCH_SIZE) {\n      const batch = ruleFiles.slice(i, i + BATCH_SIZE);\n      await processBatch(batch, rulesDir, config, processContent, progressBar);\n    }\n\n    progressBar.stop();\n  }\n\n  displayResults(results, rulesDir, config.name);\n}","import { syncRules } from './sync.js';\nimport { CommandOptions, CommandConfig } from '../types.js';\nimport { CLIError } from '../utils/error-handler.js';\nimport { COMMON_OPTIONS } from '../utils/command-builder.js';\n\nfunction validateSyncOptions(options: CommandOptions): void {\n  if (options.agent && !['cursor', 'kilocode', 'roocode'].includes(options.agent)) {\n    throw new CLIError(\n      `Invalid agent: ${options.agent}. Supported agents: cursor, kilocode, roocode`,\n      'INVALID_AGENT'\n    );\n  }\n}\n\nexport const syncCommand: CommandConfig = {\n  name: 'sync',\n  description: 'Sync development flow to your project',\n  options: [\n    { ...COMMON_OPTIONS[0], description: 'Force specific agent (cursor, kilocode, roocode)' },\n    ...COMMON_OPTIONS.slice(1)\n  ],\n  handler: syncRules,\n  validator: validateSyncOptions\n};","import fs from 'fs';\nimport path from 'path';\nimport { \n  ProcessResult, \n  CommonOptions,\n  log,\n  getSupportedAgents,\n  getAgentConfig,\n  promptForAgent as sharedPromptForAgent,\n  detectAgentTool as sharedDetectAgentTool,\n  getLocalFileInfo,\n  collectFiles,\n  displayResults,\n  processBatch,\n  createMergedContent,\n  clearObsoleteFiles\n} from '../shared.js';\n\n// Agent configurations - Currently only opencode\nconst AGENT_CONFIGS = {\n  opencode: {\n    name: 'OpenCode',\n    dir: '.opencode/agent',\n    extension: '.md',\n    stripYaml: false,\n    flatten: false,\n    description: 'OpenCode (.opencode/agent/*.md with YAML front matter for agents)'\n  }\n} as const;\n\ntype AgentType = keyof typeof AGENT_CONFIGS;\n\n// ============================================================================\n// AGENT-SPECIFIC FUNCTIONS\n// ============================================================================\n\nasync function getAgentFiles(): Promise<string[]> {\n  // Get agents directory from current working directory\n  const agentsDir = path.join(process.cwd(), 'agents');\n  \n  // Get all subdirectories in agents/ (excluding archived)\n  const subdirs = fs.readdirSync(agentsDir, { withFileTypes: true })\n    .filter(dirent => dirent.isDirectory() && dirent.name !== 'archived')\n    .map(dirent => dirent.name);\n  \n  const allFiles: string[] = [];\n  \n  // Collect files from each subdirectory\n  for (const subdir of subdirs) {\n    const subdirPath = path.join(agentsDir, subdir);\n    const files = collectFiles(subdirPath, ['.md']);\n    allFiles.push(...files.map(file => path.join(subdir, file)));\n  }\n  \n  return allFiles;\n}\n\nasync function promptForAgent(): Promise<AgentType> {\n  const result = await sharedPromptForAgent(AGENT_CONFIGS, 'Workflow Install Tool');\n  return result as AgentType;\n}\n\nfunction detectAgentTool(): AgentType {\n  const result = sharedDetectAgentTool(AGENT_CONFIGS, 'opencode');\n  return result as AgentType;\n}\n\n// ============================================================================\n// PLUGIN INSTALLATION\n// ============================================================================\n\nasync function installMemoryPlugin(cwd: string): Promise<void> {\n  const pluginDir = path.join(cwd, '.opencode', 'plugin');\n  const pluginFile = path.join(pluginDir, 'memory-tools.ts');\n  \n  // Create plugin directory\n  fs.mkdirSync(pluginDir, { recursive: true });\n  \n  // Check if plugin already exists\n  if (fs.existsSync(pluginFile)) {\n    console.log('üì¶ Memory plugin already exists, skipping...');\n    return;\n  }\n  \n  // Copy plugin file from project\n  const sourcePlugin = path.join(process.cwd(), 'src', 'opencode', 'plugins', 'memory-tools.ts');\n  \n  if (fs.existsSync(sourcePlugin)) {\n    fs.copyFileSync(sourcePlugin, pluginFile);\n    console.log('üì¶ Installed memory plugin for agent coordination');\n  } else {\n    // Create plugin file directly if source doesn't exist\n    const pluginContent = `import { type Plugin, tool } from \"@opencode-ai/plugin\"\n\n// Simple in-memory storage for coordination between agents\nconst memoryStore = new Map<string, any>()\n\nexport const MemoryToolsPlugin: Plugin = async () => {\n  return {\n    tool: {\n      // Store a value in memory\n      memory_set: tool({\n        description: \"Store a value in shared memory for agent coordination\",\n        args: {\n          key: tool.schema.string().describe(\"Memory key (e.g., 'swarm/coder/status')\"),\n          value: tool.schema.string().describe(\"Value to store (will be JSON stringified)\"),\n          namespace: tool.schema.string().optional().describe(\"Optional namespace for organization\"),\n        },\n        async execute(args) {\n          try {\n            const fullKey = args.namespace ? \\`\\${args.namespace}:\\${args.key}\\` : args.key\n            const parsedValue = JSON.parse(args.value)\n            memoryStore.set(fullKey, {\n              value: parsedValue,\n              timestamp: Date.now(),\n              namespace: args.namespace || 'default'\n            })\n            return \\`‚úÖ Stored memory: \\${fullKey}\\`\n          } catch (error: any) {\n            return \\`‚ùå Error storing memory: \\${error.message}\\`\n          }\n        },\n      }),\n\n      // Retrieve a value from memory\n      memory_get: tool({\n        description: \"Retrieve a value from shared memory\",\n        args: {\n          key: tool.schema.string().describe(\"Memory key to retrieve\"),\n          namespace: tool.schema.string().optional().describe(\"Optional namespace\"),\n        },\n        async execute(args) {\n          try {\n            const fullKey = args.namespace ? \\`\\${args.namespace}:\\${args.key}\\` : args.key\n            const memory = memoryStore.get(fullKey)\n            \n            if (!memory) {\n              return \\`‚ùå Memory not found: \\${fullKey}\\`\n            }\n            \n            return JSON.stringify({\n              key: fullKey,\n              value: memory.value,\n              timestamp: memory.timestamp,\n              namespace: memory.namespace,\n              age: Date.now() - memory.timestamp\n            }, null, 2)\n          } catch (error: any) {\n            return \\`‚ùå Error retrieving memory: \\${error.message}\\`\n          }\n        },\n      }),\n\n      // Search memory keys by pattern\n      memory_search: tool({\n        description: \"Search memory keys by pattern\",\n        args: {\n          pattern: tool.schema.string().describe(\"Search pattern (supports wildcards)\"),\n          namespace: tool.schema.string().optional().describe(\"Optional namespace to limit search\"),\n        },\n        async execute(args) {\n          try {\n            const searchPattern = args.namespace ? \\`\\${args.namespace}:\\${args.pattern}\\` : args.pattern\n            const regex = new RegExp(searchPattern.replace(/\\\\*/g, '.*'))\n            \n            const results = Array.from(memoryStore.entries())\n              .filter(([key]) => regex.test(key))\n              .map(([key, memory]) => ({\n                key,\n                value: memory.value,\n                timestamp: memory.timestamp,\n                namespace: memory.namespace,\n                age: Date.now() - memory.timestamp\n              }))\n            \n            return JSON.stringify({\n              pattern: searchPattern,\n              count: results.length,\n              results: results\n            }, null, 2)\n          } catch (error: any) {\n            return \\`‚ùå Error searching memory: \\${error.message}\\`\n          }\n        },\n      }),\n\n      // List all memory keys\n      memory_list: tool({\n        description: \"List all memory keys, optionally filtered by namespace\",\n        args: {\n          namespace: tool.schema.string().optional().describe(\"Optional namespace to filter\"),\n        },\n        async execute(args) {\n          try {\n            const entries = Array.from(memoryStore.entries())\n              .filter(([, memory]) => !args.namespace || memory.namespace === args.namespace)\n            \n            return JSON.stringify({\n              namespace: args.namespace || 'all',\n              count: entries.length,\n              keys: entries.map(([key, memory]) => ({\n                key,\n                namespace: memory.namespace,\n                timestamp: memory.timestamp,\n                age: Date.now() - memory.timestamp\n              }))\n            }, null, 2)\n          } catch (error: any) {\n            return \\`‚ùå Error listing memory: \\${error.message}\\`\n          }\n        },\n      }),\n\n      // Delete memory\n      memory_delete: tool({\n        description: \"Delete a memory entry\",\n        args: {\n          key: tool.schema.string().describe(\"Memory key to delete\"),\n          namespace: tool.schema.string().optional().describe(\"Optional namespace\"),\n        },\n        async execute(args) {\n          try {\n            const fullKey = args.namespace ? \\`\\${args.namespace}:\\${args.key}\\` : args.key\n            const deleted = memoryStore.delete(fullKey)\n            \n            if (deleted) {\n              return \\`‚úÖ Deleted memory: \\${fullKey}\\`\n            } else {\n              return \\`‚ùå Memory not found: \\${fullKey}\\`\n            }\n          } catch (error: any) {\n            return \\`‚ùå Error deleting memory: \\${error.message}\\`\n          }\n        },\n      }),\n\n      // Clear all memory or specific namespace\n      memory_clear: tool({\n        description: \"Clear all memory or specific namespace\",\n        args: {\n          namespace: tool.schema.string().optional().describe(\"Optional namespace to clear\"),\n          confirm: tool.schema.boolean().describe(\"Confirmation required for clearing all memory\"),\n        },\n        async execute(args) {\n          try {\n            if (!args.namespace && !args.confirm) {\n              return \\`‚ùå Confirmation required. Set confirm: true to clear all memory.\\`\n            }\n            \n            if (args.namespace) {\n              // Clear specific namespace\n              const keysToDelete = Array.from(memoryStore.entries())\n                .filter(([, memory]) => memory.namespace === args.namespace)\n                .map(([key]) => key)\n              \n              keysToDelete.forEach(key => memoryStore.delete(key))\n              return \\`‚úÖ Cleared \\${keysToDelete.length} memories from namespace: \\${args.namespace}\\`\n            } else {\n              // Clear all memory\n              const count = memoryStore.size\n              memoryStore.clear()\n              return \\`‚úÖ Cleared all \\${count} memory entries\\`\n            }\n          } catch (error: any) {\n            return \\`‚ùå Error clearing memory: \\${error.message}\\`\n          }\n        },\n      }),\n    },\n  }\n}`;\n    \n    fs.writeFileSync(pluginFile, pluginContent, 'utf8');\n    console.log('üì¶ Created memory plugin for agent coordination');\n  }\n}\n\n// ============================================================================\n// MAIN INSTALL FUNCTION\n// ============================================================================\n\nexport async function installAgents(options: CommonOptions): Promise<void> {\n  const cwd = process.cwd();\n  const results: ProcessResult[] = [];\n\n  // Determine agent\n  let agent: AgentType;\n  if (options.agent) {\n    agent = options.agent.toLowerCase() as AgentType;\n    if (!getSupportedAgents(AGENT_CONFIGS).includes(agent)) {\n      log(`‚ùå Unknown agent: ${agent}`, 'red');\n      log(`Supported agents: ${getSupportedAgents(AGENT_CONFIGS).join(', ')}`, 'yellow');\n      throw new Error(`Unknown agent: ${agent}`);\n    }\n  } else {\n    const detectedAgent = detectAgentTool();\n    if (detectedAgent !== 'opencode') {\n      agent = detectedAgent;\n      console.log(`üìù Detected agent: ${getAgentConfig(AGENT_CONFIGS, agent).name}`);\n    } else {\n      console.log('üìù No agent detected or defaulting to OpenCode.');\n      agent = await promptForAgent();\n    }\n  }\n\n  const config = getAgentConfig(AGENT_CONFIGS, agent);\n  const agentsDir = path.join(cwd, config.dir);\n  const processContent = (content: string) => {\n    // For OpenCode agents, preserve YAML front matter - no processing\n    return content;\n  };\n\n  // Clear obsolete agents if requested\n  if (options.clear && fs.existsSync(agentsDir)) {\n    let expectedFiles: Set<string>;\n\n    if (options.merge) {\n      // In merge mode, only expect the merged file\n      expectedFiles = new Set([`all-agents${config.extension}`]);\n    } else {\n      // Get source files for normal mode\n      const agentFiles = await getAgentFiles();\n      expectedFiles = new Set(\n        agentFiles.map(filePath => {\n          const parsedPath = path.parse(filePath);\n          const baseName = parsedPath.name;\n          const dir = parsedPath.dir;\n\n          if (config.flatten) {\n            const flattenedName = dir ? `${dir.replace(/[\\/\\\\]/g, '-')}-${baseName}` : baseName;\n            return `${flattenedName}${config.extension}`;\n          } else {\n            // Keep the relative path structure (sdd/file.md, core/file.md)\n            return filePath;\n          }\n        })\n      );\n    }\n\n    clearObsoleteFiles(agentsDir, expectedFiles, [config.extension], results);\n  }\n\n  // Create agents directory\n  fs.mkdirSync(agentsDir, { recursive: true });\n\n  // Install memory plugin\n  await installMemoryPlugin(cwd);\n\n  // Get agent files\n  const agentFiles = await getAgentFiles();\n\n  // Show initial info\n  console.log(`üöÄ Workflow Install Tool`);\n  console.log(`=====================`);\n  console.log(`üìù Agent: ${config.name}`);\n  console.log(`üìÅ Target: ${agentsDir}`);\n  console.log(`üìã Files: ${agentFiles.length}`);\n  if (options.merge) {\n    console.log(`üîó Mode: Merge all agents into single file`);\n  }\n  console.log('');\n\n  if (options.dryRun) {\n    console.log('‚úÖ Dry run completed - no files were modified');\n    return;\n  }\n\n  if (options.merge) {\n    // Merge all agents into a single file\n    const mergedFileName = `all-agents${config.extension}`;\n    const mergedFilePath = path.join(agentsDir, mergedFileName);\n\n    console.log(`üìã Merging ${agentFiles.length} files into ${mergedFileName}...`);\n\n    const pathPrefix = 'agents/';\n    const mergedContent = createMergedContent(\n      agentFiles.map(f => pathPrefix + f),\n      processContent,\n      'Development Workflow Agents - Complete Collection',\n      pathPrefix\n    );\n\n    // Check if file needs updating\n    const localInfo = getLocalFileInfo(mergedFilePath);\n    const localProcessed = localInfo ? processContent(localInfo.content) : '';\n    const contentChanged = !localInfo || localProcessed !== mergedContent;\n\n    if (contentChanged) {\n      fs.writeFileSync(mergedFilePath, mergedContent, 'utf8');\n      results.push({\n        file: mergedFileName,\n        status: localInfo ? 'updated' : 'added',\n        action: localInfo ? 'Updated' : 'Created'\n      });\n    } else {\n      results.push({\n        file: mergedFileName,\n        status: 'current',\n        action: 'Already current'\n      });\n    }\n\n    displayResults(results, agentsDir, config.name, 'Install');\n  } else {\n    // Process files individually - create both sdd/ and core/ subdirectory structures\n    await processBatch(\n      agentFiles, // Files with relative paths (sdd/file.md, core/file.md)\n      agentsDir, // Target to .opencode/agent/\n      config.extension,\n      processContent,\n      config.flatten,\n      results,\n      'agents/' // PathPrefix for source file reading\n    );\n\n    displayResults(results, agentsDir, config.name, 'Install');\n  }\n}","import fs from 'fs';\nimport path from 'path';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface ProcessResult {\n  file: string;\n  status: 'added' | 'updated' | 'current' | 'skipped';\n  action: string;\n}\n\nexport interface CommonOptions {\n  agent?: string;\n  dryRun?: boolean;\n  clear?: boolean;\n  merge?: boolean;\n  verbose?: boolean;\n  mcp?: string[] | null;\n}\n\nexport interface AgentConfig {\n  name: string;\n  dir: string;\n  extension: string;\n  stripYaml: boolean;\n  flatten: boolean;\n  description: string;\n}\n\nexport interface AgentConfigs {\n  [key: string]: AgentConfig;\n}\n\n// ============================================================================\n// LOGGING\n// ============================================================================\n\nexport function log(message: string, color: string = 'white'): void {\n  const colors = {\n    red: '\\x1b[31m',\n    green: '\\x1b[32m',\n    yellow: '\\x1b[33m',\n    blue: '\\x1b[34m',\n    magenta: '\\x1b[35m',\n    cyan: '\\x1b[36m',\n    white: '\\x1b[37m',\n    reset: '\\x1b[0m'\n  };\n  \n  const colorCode = colors[color as keyof typeof colors] || colors.white;\n  console.log(`${colorCode}${message}${colors.reset}`);\n}\n\n// ============================================================================\n// AGENT CONFIGURATION\n// ============================================================================\n\nexport function getSupportedAgents(configs: AgentConfigs): string[] {\n  return Object.keys(configs);\n}\n\nexport function getAgentConfig(configs: AgentConfigs, agent: string): AgentConfig {\n  const config = configs[agent];\n  if (!config) {\n    throw new Error(`Agent configuration not found: ${agent}`);\n  }\n  return config;\n}\n\nexport async function promptForAgent(configs: AgentConfigs, toolName: string): Promise<string> {\n  const supportedAgents = getSupportedAgents(configs);\n  \n  console.log(`\\nüìù ${toolName}`);\n  console.log('================');\n  console.log('Available agents:');\n  supportedAgents.forEach((agent, index) => {\n    const config = getAgentConfig(configs, agent);\n    console.log(`  ${index + 1}. ${config.name} - ${config.description}`);\n  });\n  \n  // For now, default to first agent\n  // In a real implementation, you might want to use readline or a CLI prompt library\n  return supportedAgents[0];\n}\n\nexport function detectAgentTool(configs: AgentConfigs, defaultAgent: string = 'opencode'): string {\n  // Simple detection logic - could be enhanced\n  // For now, return default\n  return defaultAgent;\n}\n\n// ============================================================================\n// FILE OPERATIONS\n// ============================================================================\n\nexport function collectFiles(dir: string, extensions: string[]): string[] {\n  if (!fs.existsSync(dir)) {\n    return [];\n  }\n  \n  const files: string[] = [];\n  \n  function traverse(currentDir: string): void {\n    const items = fs.readdirSync(currentDir);\n    \n    for (const item of items) {\n      const fullPath = path.join(currentDir, item);\n      const stat = fs.statSync(fullPath);\n      \n      if (stat.isDirectory()) {\n        traverse(fullPath);\n      } else if (extensions.some(ext => item.endsWith(ext))) {\n        // Get relative path from the base directory\n        const relativePath = path.relative(dir, fullPath);\n        files.push(relativePath);\n      }\n    }\n  }\n  \n  traverse(dir);\n  return files.sort();\n}\n\nexport function getLocalFileInfo(filePath: string): { content: string; mtime: Date } | null {\n  if (!fs.existsSync(filePath)) {\n    return null;\n  }\n  \n  const stat = fs.statSync(filePath);\n  const content = fs.readFileSync(filePath, 'utf8');\n  \n  return {\n    content,\n    mtime: stat.mtime\n  };\n}\n\nexport function clearObsoleteFiles(\n  targetDir: string,\n  expectedFiles: Set<string>,\n  extensions: string[],\n  results: ProcessResult[]\n): void {\n  if (!fs.existsSync(targetDir)) {\n    return;\n  }\n  \n  const items = fs.readdirSync(targetDir);\n  \n  for (const item of items) {\n    const itemPath = path.join(targetDir, item);\n    const stat = fs.statSync(itemPath);\n    \n    if (stat.isFile()) {\n      const hasValidExtension = extensions.some(ext => item.endsWith(ext));\n      \n      if (hasValidExtension && !expectedFiles.has(item)) {\n        fs.unlinkSync(itemPath);\n        results.push({\n          file: item,\n          status: 'skipped',\n          action: 'Removed obsolete file'\n        });\n      }\n    }\n  }\n}\n\nexport function createMergedContent(\n  filePaths: string[],\n  processContent: (content: string) => string,\n  title: string,\n  pathPrefix: string = ''\n): string {\n  const sections: string[] = [];\n  \n  // Add header\n  sections.push(`# ${title}`);\n  sections.push('');\n  sections.push(`*This file was automatically generated by merging multiple agent files.*`);\n  sections.push(`*Source path prefix: ${pathPrefix}*`);\n  sections.push('');\n  sections.push('---');\n  sections.push('');\n  \n  // Add each file\n  for (const filePath of filePaths) {\n    const fullPath = path.resolve(filePath);\n    if (fs.existsSync(fullPath)) {\n      const content = fs.readFileSync(fullPath, 'utf8');\n      const processedContent = processContent(content);\n      \n      sections.push(`## ${path.basename(filePath, '.md')}`);\n      sections.push('');\n      sections.push(processedContent);\n      sections.push('');\n      sections.push('---');\n      sections.push('');\n    }\n  }\n  \n  return sections.join('\\n');\n}\n\nexport async function processBatch(\n  filePaths: string[],\n  targetDir: string,\n  extension: string,\n  processContent: (content: string) => string,\n  flatten: boolean,\n  results: ProcessResult[],\n  pathPrefix: string = ''\n): Promise<void> {\n  for (const filePath of filePaths) {\n    // filePath is now just the filename (e.g., \"sdd-constitution.md\")\n    // not the full path with prefix\n    const destPath = flatten \n      ? path.join(targetDir, `${path.basename(filePath, path.extname(filePath))}${extension}`)\n      : path.join(targetDir, filePath);\n    \n    // Ensure destination directory exists\n    const destDir = path.dirname(destPath);\n    if (!fs.existsSync(destDir)) {\n      fs.mkdirSync(destDir, { recursive: true });\n    }\n    \n    const localInfo = getLocalFileInfo(destPath);\n    const isNew = !localInfo;\n\n    // Read content from source - construct the full path from project root\n    const projectRoot = process.cwd();\n    const sourcePath = path.join(projectRoot, pathPrefix, filePath);\n    let content = fs.readFileSync(sourcePath, 'utf8');\n    content = processContent(content);\n\n    const localProcessed = localInfo ? processContent(localInfo.content) : '';\n    const contentChanged = !localInfo || localProcessed !== content;\n\n    if (contentChanged) {\n      // Ensure destination directory exists\n      const destDirPath = path.dirname(destPath);\n      if (!fs.existsSync(destDirPath)) {\n        fs.mkdirSync(destDirPath, { recursive: true });\n      }\n\n      fs.writeFileSync(destPath, content, 'utf8');\n      results.push({\n        file: path.relative(targetDir, destPath),\n        status: isNew ? 'added' : 'updated',\n        action: isNew ? 'Created' : 'Updated'\n      });\n    } else {\n      results.push({\n        file: path.relative(targetDir, destPath),\n        status: 'current',\n        action: 'Already current'\n      });\n    }\n  }\n}\n\nexport function displayResults(\n  results: ProcessResult[],\n  targetDir: string,\n  agentName: string,\n  operation: string\n): void {\n  console.log(`\\nüìä ${operation} Results for ${agentName}`);\n  console.log('=====================================');\n  \n  const grouped = results.reduce((acc, result) => {\n    if (!acc[result.status]) {\n      acc[result.status] = [];\n    }\n    acc[result.status].push(result);\n    return acc;\n  }, {} as Record<string, ProcessResult[]>);\n  \n  const statusOrder = ['added', 'updated', 'current', 'skipped'];\n  const statusColors = {\n    added: 'green',\n    updated: 'yellow',\n    current: 'blue',\n    skipped: 'magenta'\n  };\n  \n  for (const status of statusOrder) {\n    const items = grouped[status];\n    if (items && items.length > 0) {\n      const color = statusColors[status as keyof typeof statusColors];\n      log(`${status.toUpperCase()} (${items.length}):`, color);\n      items.forEach(item => {\n        log(`  ${item.file} - ${item.action}`, color);\n      });\n      console.log('');\n    }\n  }\n  \n  const total = results.length;\n  const changed = results.filter(r => r.status === 'added' || r.status === 'updated').length;\n  \n  if (changed > 0) {\n    log(`‚úÖ ${operation} complete: ${changed}/${total} files modified`, 'green');\n  } else {\n    log(`‚úÖ ${operation} complete: All ${total} files already current`, 'blue');\n  }\n  \n  console.log(`üìÅ Target directory: ${targetDir}`);\n}","import path from 'path';\nimport { OpenCodeConfig } from '../types.js';\nimport { readJSONCFile, writeJSONCFile } from './jsonc.js';\n\n/**\n * MCP server configurations\n */\nexport const MCP_SERVERS = {\n  memory: {\n    name: 'flow_memory',\n    description: 'Flow memory MCP server for agent coordination',\n    config: {\n      type: 'local' as const,\n      command: ['npx', 'github:sylphxltd/flow', 'mcp'] as string[]\n    }\n  },\n  everything: {\n    name: 'mcp_everything',\n    description: 'MCP Everything server - comprehensive tool collection',\n    config: {\n      type: 'local' as const,\n      command: ['npx', '-y', '@modelcontextprotocol/server-everything'] as string[]\n    }\n  }\n} as const;\n\nexport type MCPServerType = keyof typeof MCP_SERVERS;\n\n/**\n * Get the opencode.jsonc file path\n */\nfunction getOpenCodeConfigPath(cwd: string): string {\n  return path.join(cwd, 'opencode.jsonc');\n}\n\n/**\n * Read the current opencode.jsonc configuration\n */\nasync function readOpenCodeConfig(cwd: string): Promise<OpenCodeConfig> {\n  const configPath = getOpenCodeConfigPath(cwd);\n  \n  try {\n    const { existsSync } = await import('fs');\n    if (!existsSync(configPath)) {\n      return {};\n    }\n    \n    return await readJSONCFile(configPath);\n  } catch (error) {\n    console.warn(`Warning: Could not read opencode.jsonc: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    return {};\n  }\n}\n\n/**\n * Write the opencode.jsonc configuration\n */\nasync function writeOpenCodeConfig(cwd: string, config: OpenCodeConfig): Promise<void> {\n  const configPath = getOpenCodeConfigPath(cwd);\n  const schema = 'https://opencode.ai/config.json';\n  \n  await writeJSONCFile(configPath, config, schema);\n}\n\n/**\n * Add MCP servers to the opencode.jsonc configuration\n */\nexport async function addMCPServers(\n  cwd: string, \n  serverTypes: MCPServerType[]\n): Promise<void> {\n  const config = await readOpenCodeConfig(cwd);\n  \n  // Initialize mcp section if it doesn't exist\n  if (!config.mcp) {\n    config.mcp = {};\n  }\n  \n  let addedCount = 0;\n  \n  // Add each requested server\n  for (const serverType of serverTypes) {\n    const server = MCP_SERVERS[serverType];\n    if (!server) {\n      console.warn(`Warning: Unknown MCP server type: ${serverType}`);\n      continue;\n    }\n    \n    if (config.mcp[server.name]) {\n      console.log(`‚ÑπÔ∏è  MCP server already exists: ${server.name}`);\n    } else {\n      config.mcp[server.name] = server.config;\n      console.log(`üì¶ Added MCP server: ${server.name} (${server.description})`);\n      addedCount++;\n    }\n  }\n  \n  // Write the updated configuration\n  await writeOpenCodeConfig(cwd, config);\n  console.log(`‚úÖ Updated opencode.jsonc with ${addedCount} new MCP server(s)`);\n}\n\n/**\n * Remove MCP servers from the opencode.jsonc configuration\n */\nexport async function removeMCPServers(\n  cwd: string, \n  serverTypes: MCPServerType[]\n): Promise<void> {\n  const config = await readOpenCodeConfig(cwd);\n  \n  if (!config.mcp) {\n    console.log('‚ÑπÔ∏è  No MCP servers configured');\n    return;\n  }\n  \n  let removedCount = 0;\n  \n  // Remove each requested server\n  for (const serverType of serverTypes) {\n    const server = MCP_SERVERS[serverType];\n    if (!server) {\n      console.warn(`Warning: Unknown MCP server type: ${serverType}`);\n      continue;\n    }\n    \n    if (config.mcp[server.name]) {\n      delete config.mcp[server.name];\n      console.log(`üóëÔ∏è  Removed MCP server: ${server.name}`);\n      removedCount++;\n    } else {\n      console.log(`‚ÑπÔ∏è  MCP server not found: ${server.name}`);\n    }\n  }\n  \n  // Remove mcp section if it's empty\n  if (Object.keys(config.mcp).length === 0) {\n    delete config.mcp;\n  }\n  \n  // Write the updated configuration\n  await writeOpenCodeConfig(cwd, config);\n  console.log(`‚úÖ Updated opencode.jsonc (removed ${removedCount} MCP server(s))`);\n}\n\n/**\n * List currently configured MCP servers\n */\nexport async function listMCPServers(cwd: string): Promise<void> {\n  const config = await readOpenCodeConfig(cwd);\n  \n  if (!config.mcp || Object.keys(config.mcp).length === 0) {\n    console.log('‚ÑπÔ∏è  No MCP servers configured');\n    return;\n  }\n  \n  console.log('üìã Currently configured MCP servers:');\n  console.log('');\n  \n  for (const [name, serverConfig] of Object.entries(config.mcp)) {\n    const command = serverConfig.command.join(' ');\n    console.log(`  ‚Ä¢ ${name}: ${command}`);\n    \n    // Find the server type for additional info\n    const serverInfo = Object.values(MCP_SERVERS).find(s => s.name === name);\n    if (serverInfo) {\n      console.log(`    ${serverInfo.description}`);\n    }\n    console.log('');\n  }\n}\n\n/**\n * Parse MCP server types from command line arguments\n */\nexport function parseMCPServerTypes(args: string[]): MCPServerType[] {\n  const servers: MCPServerType[] = [];\n  \n  for (const arg of args) {\n    if (arg in MCP_SERVERS) {\n      servers.push(arg as MCPServerType);\n    } else {\n      console.warn(`Warning: Unknown MCP server '${arg}'. Available: ${Object.keys(MCP_SERVERS).join(', ')}`);\n    }\n  }\n  \n  return servers;\n}","/**\n * JSONC (JSON with Comments) utilities\n * Provides functions to parse and stringify JSONC files while preserving comments\n */\n\n/**\n * Parse JSONC content (JSON with Comments)\n * @param content - The JSONC string to parse\n * @returns The parsed JavaScript object\n */\nexport function parseJSONC(content: string): any {\n  try {\n    // Remove single-line comments (//) but not inside strings\n    let cleaned = removeComments(content);\n    \n    // Remove trailing commas before closing brackets/braces\n    cleaned = cleaned.replace(/,(\\s*[}\\]])/g, '$1');\n    \n    return JSON.parse(cleaned);\n  } catch (error) {\n    throw new Error(`Failed to parse JSONC: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}\n\n/**\n * Remove comments from JSON content while preserving strings\n */\nfunction removeComments(content: string): string {\n  let result = '';\n  let inString = false;\n  let inSingleLineComment = false;\n  let inMultiLineComment = false;\n  let escapeNext = false;\n  \n  for (let i = 0; i < content.length; i++) {\n    const char = content[i];\n    const nextChar = content[i + 1];\n    \n    if (escapeNext) {\n      result += char;\n      escapeNext = false;\n      continue;\n    }\n    \n    if (char === '\\\\' && inString) {\n      result += char;\n      escapeNext = true;\n      continue;\n    }\n    \n    if (inString) {\n      if (char === '\"') {\n        inString = false;\n      }\n      result += char;\n      continue;\n    }\n    \n    if (inSingleLineComment) {\n      if (char === '\\n') {\n        inSingleLineComment = false;\n        result += char;\n      }\n      continue;\n    }\n    \n    if (inMultiLineComment) {\n      if (char === '*' && nextChar === '/') {\n        inMultiLineComment = false;\n        i++; // Skip the '/'\n      }\n      continue;\n    }\n    \n    if (char === '\"') {\n      inString = true;\n      result += char;\n      continue;\n    }\n    \n    if (char === '/' && nextChar === '/') {\n      inSingleLineComment = true;\n      i++; // Skip the second '/'\n      continue;\n    }\n    \n    if (char === '/' && nextChar === '*') {\n      inMultiLineComment = true;\n      i++; // Skip the '*'\n      continue;\n    }\n    \n    result += char;\n  }\n  \n  return result;\n}\n\n/**\n * Stringify an object to JSON format with optional schema\n * @param obj - The object to stringify\n * @param schema - Optional schema URL to include\n * @param indent - Indentation spaces (default: 2)\n * @returns The formatted JSON string\n */\nexport function stringifyJSONC(obj: any, schema?: string, indent: number = 2): string {\n  const config = { ...obj };\n  \n  // Add schema if provided and not already present\n  if (schema && !config.$schema) {\n    config.$schema = schema;\n  }\n  \n  const json = JSON.stringify(config, null, indent);\n  \n  // Add helpful comments for MCP configuration\n  if (config.mcp && Object.keys(config.mcp).length > 0) {\n    return json.replace(\n      /(\\s*)\"mcp\": {/,\n      `$1// MCP (Model Context Protocol) server configuration\n$1// See https://modelcontextprotocol.io for more information\n$1\"mcp\": {`\n    );\n  }\n  \n  return json;\n}\n\n/**\n * Read and parse a JSONC file\n * @param filePath - Path to the JSONC file\n * @returns The parsed object\n */\nexport async function readJSONCFile(filePath: string): Promise<any> {\n  const fs = await import('fs/promises');\n  const content = await fs.readFile(filePath, 'utf8');\n  return parseJSONC(content);\n}\n\n/**\n * Write an object to a JSONC file\n * @param filePath - Path to the JSONC file\n * @param obj - The object to write\n * @param schema - Optional schema URL\n * @param indent - Indentation spaces\n */\nexport async function writeJSONCFile(\n  filePath: string, \n  obj: any, \n  schema?: string, \n  indent: number = 2\n): Promise<void> {\n  const fs = await import('fs/promises');\n  const content = stringifyJSONC(obj, schema, indent);\n  await fs.writeFile(filePath, content, 'utf8');\n}","import { installAgents } from './install.js';\nimport { CommandOptions, CommandConfig } from '../types.js';\nimport { CLIError } from '../utils/error-handler.js';\nimport { parseMCPServerTypes, addMCPServers, listMCPServers } from '../utils/mcp-config.js';\n\nfunction validateInstallOptions(options: CommandOptions): void {\n  if (options.agent && options.agent !== 'opencode') {\n    throw new CLIError(\n      'Currently only opencode is supported for install.',\n      'UNSUPPORTED_AGENT'\n    );\n  }\n  \n  options.agent = options.agent || 'opencode';\n  \n  // Validate MCP servers if provided\n  if (options.mcp && Array.isArray(options.mcp) && options.mcp.length > 0) {\n    const validServers = parseMCPServerTypes(options.mcp);\n    if (validServers.length === 0) {\n      throw new CLIError(\n        'Invalid MCP servers. Available: memory, everything',\n        'INVALID_MCP_SERVERS'\n      );\n    }\n    options.mcp = validServers;\n  }\n}\n\nexport const installCommand: CommandConfig = {\n  name: 'install',\n  description: 'Install workflow agents for OpenCode',\n  options: [\n    { flags: '--agent <type>', description: 'Force specific agent (opencode)' },\n    { flags: '--verbose', description: 'Show detailed output' },\n    { flags: '--dry-run', description: 'Show what would be done without making changes' },\n    { flags: '--clear', description: 'Clear obsolete items before processing' },\n    { flags: '--merge', description: 'Merge all items into a single file' },\n    { flags: '--mcp [servers...]', description: 'Install MCP servers (memory, everything)' }\n  ],\n  handler: async (options: CommandOptions) => {\n    validateInstallOptions(options);\n    \n    // Handle MCP server operations\n    if (options.mcp) {\n      if (Array.isArray(options.mcp) && options.mcp.length > 0) {\n        // Install MCP servers\n        console.log('üîß Installing MCP servers...');\n        const serverTypes = parseMCPServerTypes(options.mcp);\n        if (serverTypes.length > 0) {\n          if (!options.dryRun) {\n            await addMCPServers(process.cwd(), serverTypes);\n          } else {\n            console.log('üîç Dry run: Would install MCP servers:', serverTypes.join(', '));\n          }\n          console.log('');\n        }\n      } else {\n        // List MCP servers (when --mcp is provided without arguments)\n        await listMCPServers(process.cwd());\n        return;\n      }\n    }\n    \n    await installAgents(options);\n  }\n};","import { CommandConfig, CommandHandler } from '../types.js';\n\nconst mcpHandler: CommandHandler = async () => {\n  // Import and start the Sylphx Flow MCP server\n  await import('../servers/sylphx-flow-mcp-server.js');\n  \n  console.log('üöÄ Starting Sylphx Flow MCP Server...');\n  console.log('üìç Database: .memory/memory.json');\n  console.log('üîß Available tools: memory_set, memory_get, memory_search, memory_list, memory_delete, memory_clear, memory_stats');\n  console.log('üí° Press Ctrl+C to stop the server');\n  \n  // The server is already initialized in the module\n  // We just need to keep the process alive\n  process.stdin.resume();\n};\n\nexport const mcpCommand: CommandConfig = {\n  name: 'mcp',\n  description: 'Start the Sylphx Flow MCP server for persistent agent coordination',\n  options: [],\n  handler: mcpHandler\n};","#!/usr/bin/env node\n// Simple relative import - should work for both local and npx\nimport { runCLI } from './src/cli.js';\n\nrunCLI();"],"mappings":"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","names":["Command","resolve","collectFiles","results","fs","path","fs","path","log","getSupportedAgents","getAgentConfig","promptForAgent","detectAgentTool","getLocalFileInfo","clearObsoleteFiles","results","processBatch","displayResults","AGENT_CONFIGS","path","fs","promptForAgent","detectAgentTool","results","getSupportedAgents","log","getAgentConfig","agentFiles","clearObsoleteFiles","getLocalFileInfo","displayResults","processBatch","path","fs","path","existsSync","Command"]}