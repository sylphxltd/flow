import{F as L}from"./index-ym2vpew4.js";import H from"node:fs/promises";import I from"node:path";var G;var M=L(()=>{G={getSecretsDir(q){return I.join(q,".secrets")},async ensureSecretsDir(q){let A=G.getSecretsDir(q);await H.mkdir(A,{recursive:!0})},async writeSecret(q,A,z){await G.ensureSecretsDir(q);let B=I.join(".secrets",A),E=I.join(q,B);return await H.writeFile(E,z.trim(),"utf8"),B},async readSecret(q,A){let z=I.resolve(q,A);try{return await H.readFile(z,"utf8")}catch(B){throw Error(`Failed to read secret file ${A}: ${B}`)}},toFileReference(q){return`{file:.secrets/${q}}`},isFileReference(q){return q.startsWith("{file:")&&q.endsWith("}")},extractFilePath(q){if(!G.isFileReference(q))throw Error(`Invalid file reference: ${q}`);return q.slice(6,-1)},async resolveFileReferences(q,A){if(typeof A==="string"&&G.isFileReference(A)){let z=G.extractFilePath(A);return await G.readSecret(q,z)}if(Array.isArray(A))return Promise.all(A.map((z)=>G.resolveFileReferences(q,z)));if(A&&typeof A==="object"){let z={};for(let[B,E]of Object.entries(A))z[B]=await G.resolveFileReferences(q,E);return z}return A},async convertSecretsToFileReferences(q,A){let z={};for(let[B,E]of Object.entries(A))if(E&&!G.isFileReference(E)){let J=await G.writeSecret(q,B,E);z[B]=G.toFileReference(B)}else z[B]=E;return z},async saveSecrets(q,A){for(let[z,B]of Object.entries(A))await G.writeSecret(q,z,B)},async loadSecrets(q){let A=G.getSecretsDir(q),z={};try{let B=await H.readdir(A);for(let E of B){let J=I.join(A,E);if((await H.stat(J)).isFile()){let K=await H.readFile(J,"utf8");z[E]=K.trim()}}}catch(B){}return z},async addToGitignore(q){let A=I.join(q,".gitignore");try{let z="";try{z=await H.readFile(A,"utf8")}catch{}let B=z.split(`
`).map((E)=>E.trim());if(!B.includes(".secrets")&&!B.includes(".secrets/"))z+=(z&&!z.endsWith(`
`)?`
`:"")+`.secrets/
`,await H.writeFile(A,z,"utf8")}catch(z){console.warn("Warning: Could not update .gitignore:",z)}}}});M();export{G as secretUtils};
export{G as r,M as s};
