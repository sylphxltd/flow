# Deep Refactoring - Functional Programming Principles

This document explains the comprehensive refactoring performed to align the codebase with functional programming principles.

## Overview

The refactoring follows these core principles from the CODER agent instructions:

### Programming Principles Applied

1. **Functional composition** - Pure functions, immutable data, explicit side effects
2. **Composition over inheritance** - Function composition, mixins, dependency injection
3. **Declarative over imperative** - Express what you want, not how
4. **Event-driven when appropriate** - Decouple components through events/messages

### Quality Principles Applied

1. **YAGNI** - Build what's needed now
2. **KISS** - Simple solutions over complex ones
3. **DRY** - Extract duplication on 3rd occurrence
4. **Separation of concerns** - Each module handles one responsibility
5. **Dependency inversion** - Depend on abstractions, not implementations

## Architecture Changes

### 1. Functional Core (`src/core/functional/`)

Created a comprehensive functional programming foundation:

#### Result Type (`result.ts`)
- Explicit error handling without exceptions
- Composable through `map`, `flatMap`, `pipe`
- Forces caller to handle errors
- Type-safe error propagation

```typescript
// Before (exception-based)
function divide(a: number, b: number): number {
  if (b === 0) throw new Error('Division by zero');
  return a / b;
}

// After (Result-based)
function divide(a: number, b: number): Result<number, string> {
  if (b === 0) return failure('Division by zero');
  return success(a / b);
}

// Usage - explicit error handling
const result = divide(10, 2);
if (isSuccess(result)) {
  console.log(result.value); // 5
} else {
  console.error(result.error);
}

// Composable
pipe(
  divide(10, 2),
  map(x => x * 2),
  map(x => x + 5),
  getOrElse(0)
); // 15
```

#### Either Type (`either.ts`)
- Generic sum type for two possibilities
- More general than Result
- Left/Right convention (Left = error, Right = value)

#### Option Type (`option.ts`)
- Makes absence of value explicit
- Eliminates null pointer errors
- Composable through `map`, `flatMap`

```typescript
// Before
function findUser(id: string): User | null {
  return users.find(u => u.id === id) || null;
}

const user = findUser('123');
if (user !== null) { // easy to forget null check
  console.log(user.name);
}

// After
function findUser(id: string): Option<User> {
  const user = users.find(u => u.id === id);
  return fromNullable(user);
}

pipe(
  findUser('123'),
  map(user => user.name),
  getOrElse('Unknown')
);
```

#### Pipe & Flow (`pipe.ts`)
- Left-to-right function composition
- Point-free style support
- More readable than nested function calls

```typescript
// Before (nested, hard to read)
const result = f4(f3(f2(f1(value))));

// After (pipeline, easy to follow)
const result = pipe(
  value,
  f1,
  f2,
  f3,
  f4
);

// Create reusable pipelines
const processUser = flow(
  validateUser,
  enrichUserData,
  saveUser,
  sendWelcomeEmail
);
```

#### Validation (`validation.ts`)
- Accumulates all errors, not just first
- Useful for form validation
- Composable validators

```typescript
const validateEmail = flow(
  nonEmpty('Email is required'),
  isEmail('Invalid email format')
);

const validatePassword = flow(
  nonEmpty('Password is required'),
  minLength(8, 'Password must be at least 8 characters'),
  matches(/[A-Z]/, 'Password must contain uppercase letter')
);
```

#### Error Types (`error-types.ts`)
- Typed errors for better error handling
- Discriminated union for all error types
- Enables type-safe error recovery

```typescript
// Before
throw new Error('Database error');

// After
return failure(databaseError(
  'Failed to fetch user',
  'findById',
  { table: 'users', cause: originalError }
));

// Type-safe error handling
if (error.kind === 'DatabaseError') {
  // Retry logic
} else if (error.kind === 'NetworkError') {
  // Show offline message
}
```

### 2. Repositories (`src/repositories/`)

#### Functional Repository (`base.repository.functional.ts`)
- Pure query building functions
- Side effects (execution) isolated
- Returns Result instead of throwing

```typescript
// Pure query building (no side effects, testable without DB)
const queryParts = buildSelectQuery('users', {
  where: { active: true },
  orderBy: 'created_at',
  limit: 10
});
// { query: 'SELECT * FROM users WHERE active = ? ORDER BY created_at LIMIT ?', params: [true, 10] }

// Side effects isolated
const result = await executeQuery(db, logger, 'users', queryParts.query, queryParts.params);
if (isSuccess(result)) {
  console.log(result.value); // User[]
} else {
  console.error(result.error); // DatabaseError
}

// Factory pattern with dependency injection
const userRepo = createRepository<User>(db, logger, 'users');
const result = await userRepo.findById('123');
```

**Benefits:**
- Query building testable without database
- Side effects explicit
- No hidden exceptions
- Composable queries

### 3. Services (`src/services/functional/`)

#### File Processor (`file-processor.ts`)
- Pure transformation functions
- Composable processing pipeline
- Testable without file system

```typescript
// Pure transformations (no I/O, fast tests)
const cleanup = composeTransforms(
  normalizeLineEndings,
  removeTrailingWhitespace,
  collapseBlankLines,
  ensureTrailingNewline
);

const cleaned = cleanup(rawContent);

// Validation without I/O
const validator = composeValidators(
  validateNotEmpty,
  validateSize(1024 * 1024), // 1MB max
  validatePattern(/^# /, 'Must start with heading')
);

// Processing pipeline
const result = processFileContent(
  { path: 'README.md', content: rawContent },
  cleanup,
  validator
);
```

**Benefits:**
- Fast unit tests (no I/O)
- Composable transformations
- Reusable validators
- Declarative pipelines

### 4. Composables (`src/composables/functional/`)

#### File System (`useFileSystem.ts`)
- Pure path operations
- Side effects return Result
- Type-safe file operations

```typescript
// Pure path operations (fast, deterministic)
const fullPath = joinPath('/home/user', 'documents', 'file.txt');
const dir = dirname(fullPath);
const name = basename(fullPath, '.txt');

// Side effects with explicit error handling
const result = await readFile('/path/to/file.txt');
if (isSuccess(result)) {
  console.log(result.value); // string
} else {
  console.error(result.error); // FileSystemError
}
```

#### Environment (`useEnvironment.ts`)
- Type-safe environment access
- Validation support
- Option type for optional values

```typescript
// Optional values
const apiKey = getEnvOpt('API_KEY'); // Option<string>

// Required values with validation
const port = getEnvNumber('PORT'); // Result<number, ConfigError>

// Multiple required values
const config = getEnvRequiredAll(['DB_HOST', 'DB_USER', 'DB_PASS']);
// Result<Record<string, string>, ConfigError>

// Enum validation
const env = getEnvEnum('NODE_ENV', ['development', 'production', 'test']);
// Result<'development' | 'production' | 'test', ConfigError>
```

### 5. Command Logic (`src/commands/functional/`)

#### Init Logic (`init-logic.ts`)
- Business logic as pure functions
- Testable without I/O
- Separated from UI/side effects

```typescript
// Pure business logic (fast tests)
const plan = buildInitPlan(options, targetSupportsMCP, implementedTargets);

// Validation (pure)
const validated = validateInitOptions(rawOptions);

// Selection logic (pure)
const selection = buildMCPServerSelection(
  selectedServers,
  allServers,
  serverRegistry
);

// Dry run output (pure)
const output = buildDryRunOutput(plan, serverRegistry);
```

**Benefits:**
- Fast unit tests (no I/O)
- Testable logic
- Clear separation of concerns
- Reusable business logic

### 6. Interfaces (`src/core/interfaces/`)

#### Repository Interface (`repository.interface.ts`)
- Abstract data access
- Enables in-memory testing
- Clear contract

#### Service Interfaces (`service.interface.ts`)
- Logger, Config, File, Validation, Events
- Dependency injection ready
- Testable with mocks

## Migration Guide

### For New Code

Use the functional patterns from day one:

```typescript
import { Result, success, failure } from '@/core/functional';
import { readFile } from '@/composables/functional';

async function loadConfig(path: string): Promise<Result<Config, AppError>> {
  const fileResult = await readFile(path);

  if (isFailure(fileResult)) {
    return fileResult;
  }

  return pipe(
    fileResult.value,
    parseJSON,
    flatMap(validateConfig),
    map(normalizeConfig)
  );
}
```

### For Existing Code

Gradual migration:

1. **Leaf functions first** - Start with pure functions that don't have many dependencies
2. **Repositories** - Migrate to functional repositories
3. **Services** - Extract pure logic, use functional patterns
4. **Commands** - Extract business logic to separate files
5. **Error handling** - Replace try/catch with Result

### Deprecated Patterns

These are marked `@deprecated` and will be removed:

- `utils/error-handler.ts` → Use `core/functional/error-handler.ts`
- `CLIError` class → Use `cliError` function
- `handleError` → Use `exitWithError`
- Throwing exceptions in business logic → Return `Result`

## Testing Strategy

### Pure Functions
Fast, deterministic, no mocks:

```typescript
describe('buildSelectQuery', () => {
  it('should build WHERE clause', () => {
    const { query, params } = buildSelectQuery('users', {
      where: { active: true, role: 'admin' }
    });

    expect(query).toContain('WHERE active = ? AND role = ?');
    expect(params).toEqual([true, 'admin']);
  });
});
```

### Side Effects
Explicit, use dependency injection:

```typescript
describe('userRepository', () => {
  it('should find user by id', async () => {
    const mockDb = {
      execute: vi.fn().mockResolvedValue({
        rows: [{ id: '123', name: 'John' }]
      })
    };

    const repo = createRepository(mockDb, mockLogger, 'users');
    const result = await repo.findById('123');

    expect(isSuccess(result)).toBe(true);
  });
});
```

## Performance Benefits

1. **Pure functions** - Easier to optimize, can be memoized
2. **Lazy evaluation** - Only compute what's needed
3. **Immutability** - Better for concurrency
4. **Type safety** - Catch errors at compile time

## Maintainability Benefits

1. **Testability** - Pure functions easy to test
2. **Composability** - Build complex from simple
3. **Reasoning** - Explicit dependencies and effects
4. **Refactoring** - Safe to change pure functions
5. **Documentation** - Types serve as documentation

## Next Steps

1. ✅ Create functional core (Result, Option, Either, pipe)
2. ✅ Refactor error handling
3. ✅ Create functional repositories
4. ✅ Extract command business logic
5. ✅ Create functional services
6. ✅ Implement dependency inversion
7. ✅ Create functional composables
8. 🔄 Migrate existing code gradually
9. 📋 Run full test suite
10. 📋 Update documentation

## Resources

- **Functional Programming**: Learn about map, flatMap, pipe, composition
- **Railway Oriented Programming**: Error handling with Result types
- **Dependency Inversion**: SOLID principles
- **Separation of Concerns**: Clean Architecture

## Questions?

Refer to the code examples in:
- `src/core/functional/` - Core abstractions
- `tests/core/functional/` - Usage examples
- `src/commands/functional/` - Real-world business logic
- `src/repositories/base.repository.functional.ts` - Data access patterns
