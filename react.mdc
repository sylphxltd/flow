---
description: React-specific rules and best practices
globs: ["**/*.{tsx,jsx}"]
alwaysApply: true
---

# React Rules

## ⚛️ Component Design
- Functional components with hooks
- TypeScript strict typing for props and state
- Single responsibility per component
- Props interface definitions
- Component composition over inheritance

## 🎣 Hooks Usage
- Built-in hooks preferred
- Custom hooks for reusable logic
- Rules of Hooks compliance
- Proper cleanup in effects

## 📊 State Management & Signals
- **Signals Approach**: Use modern state management patterns
- Local state with useState/useReducer
- Context API for app-wide state (with signals-like patterns)
- External state libraries when needed (Zustand, Redux Toolkit)
- Proper state update patterns with immutability

## 🔄 Side Effects
- useEffect sparingly and properly
- Dependency arrays always included
- Cleanup functions for subscriptions
- Avoid memory leaks

## 🚀 Performance
- React.memo for expensive components
- useMemo for cached calculations
- useCallback for stable references
- Lazy loading with React.lazy

## 🚫 Forbidden Practices
- Class components (use functional)
- Direct DOM manipulation (use refs)
- dangerouslySetInnerHTML without sanitization
- Legacy context API (use modern patterns)
- Complex logic in components (extract to hooks)
- Inline event handlers in render (use useCallback)
- Large component files (>300 lines)

## 🎯 Component Patterns
- Custom hooks for logic extraction
- Error boundaries for error handling
- Render props when appropriate
- Higher-order components sparingly

## 🧪 Testing
- Component testing in isolation
- Hook testing separately
- Integration tests for interactions
- Accessibility testing included