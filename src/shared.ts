import fs from 'node:fs';
import path from 'node:path';

// ============================================================================
// TYPES
// ============================================================================

export interface ProcessResult {
  file: string;
  status: 'added' | 'updated' | 'current' | 'skipped';
  action: string;
}

export interface CommonOptions {
  agent?: string;
  dryRun?: boolean;
  clear?: boolean;
  merge?: boolean;
  verbose?: boolean;
  quiet?: boolean;
  mcp?: string[] | null;
}

export interface AgentConfig {
  name: string;
  dir: string;
  extension: string;
  stripYaml: boolean;
  flatten: boolean;
  description: string;
}

export interface AgentConfigs {
  [key: string]: AgentConfig;
}

// ============================================================================
// LOGGING
// ============================================================================

export function log(message: string, color = 'white'): void {
  const colors = {
    red: '\x1b[31m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    magenta: '\x1b[35m',
    cyan: '\x1b[36m',
    white: '\x1b[37m',
    reset: '\x1b[0m',
  };

  const colorCode = colors[color as keyof typeof colors] || colors.white;
  console.log(`${colorCode}${message}${colors.reset}`);
}

// ============================================================================
// AGENT CONFIGURATION
// ============================================================================

export function getSupportedAgents(configs: AgentConfigs): string[] {
  return Object.keys(configs);
}

export function getAgentConfig(configs: AgentConfigs, agent: string): AgentConfig {
  const config = configs[agent];
  if (!config) {
    throw new Error(`Agent configuration not found: ${agent}`);
  }
  return config;
}

export async function promptForAgent(configs: AgentConfigs, toolName: string): Promise<string> {
  const supportedAgents = getSupportedAgents(configs);

  console.log(`\nüìù ${toolName}`);
  console.log('================');
  console.log('Available agents:');
  supportedAgents.forEach((agent, index) => {
    const config = getAgentConfig(configs, agent);
    console.log(`  ${index + 1}. ${config.name} - ${config.description}`);
  });

  // For now, default to first agent
  // In a real implementation, you might want to use readline or a CLI prompt library
  return supportedAgents[0];
}

export function detectAgentTool(_configs: AgentConfigs, defaultAgent = 'opencode'): string {
  // Simple detection logic - could be enhanced
  // For now, return default
  return defaultAgent;
}

// ============================================================================
// FILE OPERATIONS
// ============================================================================

export function collectFiles(dir: string, extensions: string[]): string[] {
  if (!fs.existsSync(dir)) {
    return [];
  }

  const files: string[] = [];

  function traverse(currentDir: string): void {
    const items = fs.readdirSync(currentDir);

    for (const item of items) {
      const fullPath = path.join(currentDir, item);
      const stat = fs.statSync(fullPath);

      if (stat.isDirectory()) {
        traverse(fullPath);
      } else if (extensions.some((ext) => item.endsWith(ext))) {
        // Get relative path from the base directory
        const relativePath = path.relative(dir, fullPath);
        files.push(relativePath);
      }
    }
  }

  traverse(dir);
  return files.sort();
}

export function getLocalFileInfo(filePath: string): { content: string; mtime: Date } | null {
  if (!fs.existsSync(filePath)) {
    return null;
  }

  const stat = fs.statSync(filePath);
  const content = fs.readFileSync(filePath, 'utf8');

  return {
    content,
    mtime: stat.mtime,
  };
}

export function clearObsoleteFiles(
  targetDir: string,
  expectedFiles: Set<string>,
  extensions: string[],
  results: ProcessResult[]
): void {
  if (!fs.existsSync(targetDir)) {
    return;
  }

  const items = fs.readdirSync(targetDir);

  for (const item of items) {
    const itemPath = path.join(targetDir, item);
    const stat = fs.statSync(itemPath);

    if (stat.isFile()) {
      const hasValidExtension = extensions.some((ext) => item.endsWith(ext));

      if (hasValidExtension && !expectedFiles.has(item)) {
        fs.unlinkSync(itemPath);
        results.push({
          file: item,
          status: 'skipped',
          action: 'Removed obsolete file',
        });
      }
    }
  }
}

export function createMergedContent(
  filePaths: string[],
  processContent: (content: string) => string,
  title: string,
  pathPrefix = ''
): string {
  const sections: string[] = [];

  // Add header
  sections.push(`# ${title}`);
  sections.push('');
  sections.push('*This file was automatically generated by merging multiple agent files.*');
  sections.push(`*Source path prefix: ${pathPrefix}*`);
  sections.push('');
  sections.push('---');
  sections.push('');

  // Add each file
  for (const filePath of filePaths) {
    const fullPath = path.resolve(filePath);
    if (fs.existsSync(fullPath)) {
      const content = fs.readFileSync(fullPath, 'utf8');
      const processedContent = processContent(content);

      sections.push(`## ${path.basename(filePath, '.md')}`);
      sections.push('');
      sections.push(processedContent);
      sections.push('');
      sections.push('---');
      sections.push('');
    }
  }

  return sections.join('\n');
}

export function processBatch(
  filePaths: string[],
  targetDir: string,
  extension: string,
  processContent: (content: string) => string,
  flatten: boolean,
  results: ProcessResult[],
  pathPrefix = ''
): void {
  for (const filePath of filePaths) {
    // filePath is now just the filename (e.g., "sdd-constitution.md")
    // not the full path with prefix
    const destPath = flatten
      ? path.join(targetDir, `${path.basename(filePath, path.extname(filePath))}${extension}`)
      : path.join(targetDir, filePath);

    // Ensure destination directory exists
    const destDir = path.dirname(destPath);
    if (!fs.existsSync(destDir)) {
      fs.mkdirSync(destDir, { recursive: true });
    }

    const localInfo = getLocalFileInfo(destPath);
    const isNew = !localInfo;

    // Read content from source - construct the full path from project root
    const projectRoot = process.cwd();
    const sourcePath = path.join(projectRoot, pathPrefix, filePath);
    let content = fs.readFileSync(sourcePath, 'utf8');
    content = processContent(content);

    const localProcessed = localInfo ? processContent(localInfo.content) : '';
    const contentChanged = !localInfo || localProcessed !== content;

    if (contentChanged) {
      // Ensure destination directory exists
      const destDirPath = path.dirname(destPath);
      if (!fs.existsSync(destDirPath)) {
        fs.mkdirSync(destDirPath, { recursive: true });
      }

      fs.writeFileSync(destPath, content, 'utf8');
      results.push({
        file: path.relative(targetDir, destPath),
        status: isNew ? 'added' : 'updated',
        action: isNew ? 'Created' : 'Updated',
      });
    } else {
      results.push({
        file: path.relative(targetDir, destPath),
        status: 'current',
        action: 'Already current',
      });
    }
  }
}

export function displayResults(
  results: ProcessResult[],
  targetDir: string,
  agentName: string,
  operation: string,
  verbose = false
): void {
  if (!verbose) {
    // Simple summary for non-verbose mode
    const total = results.length;
    const changed = results.filter((r) => r.status === 'added' || r.status === 'updated').length;
    
    if (changed > 0) {
      console.log(`‚úÖ ${changed} files updated`);
    } else {
      console.log(`‚úÖ All ${total} files already current`);
    }
    return;
  }

  console.log(`\nüìä ${operation} Results for ${agentName}`);
  console.log('=====================================');

  const grouped = results.reduce(
    (acc, result) => {
      if (!acc[result.status]) {
        acc[result.status] = [];
      }
      acc[result.status].push(result);
      return acc;
    },
    {} as Record<string, ProcessResult[]>
  );

  const statusOrder = ['added', 'updated', 'current', 'skipped'];
  const statusColors = {
    added: 'green',
    updated: 'yellow',
    current: 'blue',
    skipped: 'magenta',
  };

  for (const status of statusOrder) {
    const items = grouped[status];
    if (items && items.length > 0) {
      const color = statusColors[status as keyof typeof statusColors];
      log(`${status.toUpperCase()} (${items.length}):`, color);
      for (const item of items) {
        log(`  ${item.file} - ${item.action}`, color);
      }
      console.log('');
    }
  }

  const total = results.length;
  const changed = results.filter((r) => r.status === 'added' || r.status === 'updated').length;

  if (changed > 0) {
    log(`‚úÖ ${operation} complete: ${changed}/${total} files modified`, 'green');
  } else {
    log(`‚úÖ ${operation} complete: All ${total} files already current`, 'blue');
  }

  console.log(`üìÅ Target directory: ${targetDir}`);
}
